#line 1 "CubicTest-cpp.c"
#line 1 "<built-in>"
#line 1 "<command-line>"
#line 1 "/usr/include/stdc-predef.h"
#line 1 "<command-line>"
#line 1 "CubicTest-cpp.c"
#if _XOPEN_SOURCE < 700
  #undef _XOPEN_SOURCE
  #define _XOPEN_SOURCE 700
#endif
#if _GNU_SOURCE
#include <stdint.h>
#include <string.h>
#include <fenv.h>
#endif



#line 1 "/home/pwachara/basilisk/src/common.h"
typedef double number; 






number macro_min (number a, number b) { return a < b ? a : b; } 
number macro_sq (number x) { return x*x; } 
number macro_cube (number x) { return x*x*x; } 
int macro_sign (number x) { return (int)(x > 0 ? 1 : -1); } 
int macro_sign2 (number x) { return (int)(x > 0 ? 1 : x < 0 ? -1 : 0); } 
number macro_clamp (number x, number a, number b) {
  return x < a ? a : x > b ? b : x;
} 



#line 1 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/stdlib.h"
#include <stdlib.h>
#line 2 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/stdio.h"
#include <stdio.h>
#line 3 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/stddef.h"
#include <stddef.h>
#line 4 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/stdint.h"
#include <stdint.h>
#line 5 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/stdbool.h"
#include <stdbool.h>
#line 6 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/stdarg.h"
#include <stdarg.h>
#line 7 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/string.h"
#include <string.h>
#line 8 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/float.h"
#include <float.h>
#line 9 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/limits.h"
#include <limits.h>
#line 10 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/math.h"
#include <math.h>
#line 11 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/time.h"
#include <time.h>
#line 12 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/sys/time.h"
#include <sys/time.h>
#line 13 "/home/pwachara/basilisk/src/grid/config.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/sys/resource.h"
#include <sys/resource.h>
#line 14 "/home/pwachara/basilisk/src/grid/config.h"




#define unmap(x,y)
#define trash(x)


void macro_BEGIN_FOREACH() {;}
#line 41 "/home/pwachara/basilisk/src/grid/config.h"
# define OMP(x)
void macro_OMP_SERIAL() {;}

# include <mpi.h>
static int mpi_rank, mpi_npe;
# define tid() mpi_rank
# define pid() mpi_rank
# define npe() mpi_npe
#line 69 "/home/pwachara/basilisk/src/grid/config.h"
#define _NVARMAX 65536
#define is_constant(v) ((v).i >= _NVARMAX)
#define constant(v) (is_constant(v) ? _constant[(v).i - _NVARMAX] : 1e30f)

#define systderr stderr
#define systdout stdout

FILE * qstderr (void);
FILE * qstdout (void);
FILE * ferr = NULL, * fout = NULL;
#define not_mpi_compatible()\
do {\
  if (npe() > 1) {\
    fprintf (ferr, "%s() is not compatible with MPI (yet)\n", __func__);\
    exit (1);\
  }\
} while(0)\

#line 86

# define system(command) (pid() == 0 ? system(command) : 0)
#line 97 "/home/pwachara/basilisk/src/grid/config.h"
static inline void qassert (const char * file, int line, const char * cond) {
  fprintf (ferr, "%s:%d: Assertion `%s' failed.\n", file, line, cond);
  abort();
}







#define sysmalloc malloc
#define syscalloc calloc
#define sysrealloc realloc
#define sysfree free
#define systrdup strdup




# define pmalloc(s,func,file,line) malloc(s)
# define pcalloc(n,s,func,file,line) calloc(n,s)
# define prealloc(p,s,func,file,line) realloc(p,s)
# define pfree(p,func,file,line) free(p)
# define pstrdup(s,func,file,line) strdup(s)






#line 1 "/home/pwachara/basilisk/src/grid/array.h"


typedef struct {
  void * p;
  long max, len;
} Array;

Array * array_new()
{
  Array * a = ((Array *) pmalloc ((1)*sizeof(Array),__func__,__FILE__,__LINE__));
  a->p = NULL;
  a->max = a->len = 0;
  return a;
}

void array_free (Array * a)
{
  pfree (a->p,__func__,__FILE__,__LINE__);
  pfree (a,__func__,__FILE__,__LINE__);
}

void * array_append (Array * a, void * elem, size_t size)
{
  if (a->len + size >= a->max) {
    a->max += ( size > 4096 ? size : 4096);
    a->p = prealloc (a->p, a->max,__func__,__FILE__,__LINE__);
  }
  memcpy (((char *)a->p) + a->len, elem, size);
  a->len += size;
  return (void *)(((char *)a->p) + a->len - size);
}

void * array_shrink (Array * a)
{
  void * p = prealloc (a->p, a->len,__func__,__FILE__,__LINE__);
  pfree (a,__func__,__FILE__,__LINE__);
  return p;
}
#line 129 "/home/pwachara/basilisk/src/grid/config.h"
#line 372 "/home/pwachara/basilisk/src/grid/config.h"
# define tracing(...)
# define end_tracing(...)
#line 388 "/home/pwachara/basilisk/src/grid/config.h"
static bool in_prof = false;
static double prof_start, _prof;
#define prof_start(name)\
  if (!(!in_prof)) qassert ("/home/pwachara/basilisk/src/grid/config.h", 391, "!in_prof"); in_prof = true;\
  prof_start = MPI_Wtime();\

#line 393

#define prof_stop()\
  if (!(in_prof)) qassert ("/home/pwachara/basilisk/src/grid/config.h", 395, "in_prof"); in_prof = false;\
  _prof = MPI_Wtime();\
  mpi_time += _prof - prof_start;\

#line 398






     
int mpi_all_reduce0 (void *sendbuf, void *recvbuf, int count,
       MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)
{tracing("mpi_all_reduce0","/home/pwachara/basilisk/src/grid/config.h",405);
  { int _ret= MPI_Allreduce (sendbuf, recvbuf, count, datatype, op, comm);end_tracing("mpi_all_reduce0","/home/pwachara/basilisk/src/grid/config.h",408);return _ret;}
end_tracing("mpi_all_reduce0","/home/pwachara/basilisk/src/grid/config.h",409);}

#define mpi_all_reduce(v,type,op) {\
  prof_start ("mpi_all_reduce");\
  union { int a; float b; double c;} global;\
  mpi_all_reduce0 (&(v), &global, 1, type, op, MPI_COMM_WORLD);\
  memcpy (&(v), &global, sizeof (v));\
  prof_stop();\
}\

#line 418


     
void mpi_all_reduce_array (void * v, MPI_Datatype datatype, MPI_Op op, int elem)
{tracing("mpi_all_reduce_array","/home/pwachara/basilisk/src/grid/config.h",421);
  size_t size;
  if (datatype == MPI_DOUBLE) size = sizeof (double);
  else if (datatype == MPI_INT) size = sizeof (int);
  else if (datatype == MPI_LONG) size = sizeof (long);
  else if (datatype == MPI_C_BOOL) size = sizeof (bool);
  else if (datatype == MPI_UNSIGNED_CHAR) size = sizeof (unsigned char);
  else {
    fprintf (ferr, "unknown reduction type\n");
    fflush (ferr);
    abort();
  }
  void * global = pmalloc (elem*size,__func__,__FILE__,__LINE__), * tmp = pmalloc (elem*size,__func__,__FILE__,__LINE__);
  memcpy (tmp, v, elem*size);
  mpi_all_reduce0 (tmp, global, elem, datatype, op, MPI_COMM_WORLD);
  memcpy (v, global, elem*size);
  pfree (global,__func__,__FILE__,__LINE__), pfree (tmp,__func__,__FILE__,__LINE__);
end_tracing("mpi_all_reduce_array","/home/pwachara/basilisk/src/grid/config.h",439);}


#define QFILE FILE

FILE * qstderr (void)
{
  static QFILE * fp = NULL;
  if (!fp) {
    if (mpi_rank > 0) {
      char name[80];
      sprintf (name, "log-%d", mpi_rank);
      fp = fopen (name, "w");
    }
    else
      fp = systderr;
  }
  return fp;
}

FILE * qstdout (void)
{
  static QFILE * fp = NULL;
  if (!fp) {
    if (mpi_rank > 0) {
      char name[80];
      sprintf (name, "out-%d", mpi_rank);
      fp = fopen (name, "w");
    }
    else
      fp = systdout;
  }
  return fp;
}

static void finalize (void)
{
  MPI_Finalize();
}

void mpi_init()
{
  int initialized;
  MPI_Initialized (&initialized);
  if (!initialized) {
    MPI_Init (NULL, NULL);
    MPI_Comm_set_errhandler (MPI_COMM_WORLD, MPI_ERRORS_ARE_FATAL);
    atexit (finalize);
  }
  MPI_Comm_rank (MPI_COMM_WORLD, &mpi_rank);
  MPI_Comm_size (MPI_COMM_WORLD, &mpi_npe);
  srand (mpi_rank + 1);
  if (ferr == NULL) {
    if (mpi_rank > 0) {
      ferr = fopen ("/dev/null", "w");
      fout = fopen ("/dev/null", "w");
    }
    else {
      ferr = systderr;
      fout = systdout;
    }
    char * etrace = getenv ("MALLOC_TRACE"), name[80];
    if (etrace && mpi_rank > 0) {
      sprintf (name, "%s-%d", etrace, mpi_rank);
      setenv ("MALLOC_TRACE", name, 1);
    }
#line 519 "/home/pwachara/basilisk/src/grid/config.h"
  }
}
#line 532 "/home/pwachara/basilisk/src/grid/config.h"
void macro_OMP_PARALLEL() {;}
#define OMP_PARALLEL(...) OMP(omp parallel __VA_ARGS__)

#define NOT_UNUSED(x) (void)(x)

void macro1_VARIABLES() { ; }
#define _index(a,m) (a.i)
#define val(a,k,l,m) data(k,l,m)[_index(a,m)]

double _val_higher_dimension = 0.;
#line 550 "/home/pwachara/basilisk/src/grid/config.h"
#if (_GNU_SOURCE || __APPLE__) && !_OPENMP && !_CADNA
double undefined;
# if __APPLE__
# include <stdint.h>
# include "fp_osx.h"
# endif
#if _GPU
# define enable_fpe(flags)
#else
# define enable_fpe(flags) feenableexcept (flags)
#endif
# define disable_fpe(flags) fedisableexcept (flags)
static void set_fpe (void) {
  int64_t lnan = 0x7ff0000000000001;
  if (!(sizeof (int64_t) == sizeof (double))) qassert ("/home/pwachara/basilisk/src/grid/config.h", 564, "sizeof (int64_t) == sizeof (double)");
  memcpy (&undefined, &lnan, sizeof (double));
  enable_fpe (FE_DIVBYZERO|FE_INVALID);
}
#else
# define undefined ((double) DBL_MAX)
# define enable_fpe(flags)
# define disable_fpe(flags)
static void set_fpe (void) {}
#endif



static FILE ** qpopen_pipes = NULL;

FILE * qpopen (const char * command, const char * type)
{
  if (pid() > 0)
    return fopen ("/dev/null", type);
  FILE * fp = popen (command, type);
  if (fp) {
    FILE ** i = qpopen_pipes;
    int n = 0;
    while (i && *i) { n++; i++; }
    qpopen_pipes = (FILE * *) prealloc (qpopen_pipes, (n + 2)*sizeof(FILE *),__func__,__FILE__,__LINE__);
    qpopen_pipes[n] = fp;
    qpopen_pipes[n+1] = NULL;
  }
  return fp;
}

int qpclose (FILE * fp)
{
  if (pid() > 0)
    return fclose (fp);
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i == fp)
      *i = (FILE *) 1;
    i++;
  }
  return pclose (fp);
}

static void qpclose_all()
{
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i != (FILE *) 1)
      pclose (*i);
    i++;
  }
  pfree (qpopen_pipes,__func__,__FILE__,__LINE__);
  qpopen_pipes = NULL;
}






FILE * lfopen (const char * name, const char * mode)
{
  char fname[80];
  sprintf (fname, "%s-%d", name, pid());
  return fopen (fname, mode);
}

#line 1 "/home/pwachara/basilisk/src/grid/../ast/symbols.h"

const char * symbol_name (int sym);
int token_symbol (int token);
enum yysymbol_kind_t
{
  sym_YYEMPTY = -2,
  sym_YYEOF = 0,
  sym_YYerror = 1,
  sym_YYUNDEF = 2,
  sym_IDENTIFIER = 3,
  sym_I_CONSTANT = 4,
  sym_F_CONSTANT = 5,
  sym_STRING_LITERAL = 6,
  sym_FUNC_NAME = 7,
  sym_SIZEOF = 8,
  sym_PTR_OP = 9,
  sym_INC_OP = 10,
  sym_DEC_OP = 11,
  sym_LEFT_OP = 12,
  sym_RIGHT_OP = 13,
  sym_LE_OP = 14,
  sym_GE_OP = 15,
  sym_EQ_OP = 16,
  sym_NE_OP = 17,
  sym_AND_OP = 18,
  sym_OR_OP = 19,
  sym_MUL_ASSIGN = 20,
  sym_DIV_ASSIGN = 21,
  sym_MOD_ASSIGN = 22,
  sym_ADD_ASSIGN = 23,
  sym_SUB_ASSIGN = 24,
  sym_LEFT_ASSIGN = 25,
  sym_RIGHT_ASSIGN = 26,
  sym_AND_ASSIGN = 27,
  sym_XOR_ASSIGN = 28,
  sym_OR_ASSIGN = 29,
  sym_TYPEDEF_NAME = 30,
  sym_ENUMERATION_CONSTANT = 31,
  sym_TYPEDEF = 32,
  sym_EXTERN = 33,
  sym_STATIC = 34,
  sym_AUTO = 35,
  sym_REGISTER = 36,
  sym_INLINE = 37,
  sym_CONST = 38,
  sym_RESTRICT = 39,
  sym_VOLATILE = 40,
  sym_BOOL = 41,
  sym_CHAR = 42,
  sym_SHORT = 43,
  sym_INT = 44,
  sym_LONG = 45,
  sym_SIGNED = 46,
  sym_UNSIGNED = 47,
  sym_FLOAT = 48,
  sym_DOUBLE = 49,
  sym_VOID = 50,
  sym_COMPLEX = 51,
  sym_IMAGINARY = 52,
  sym_STRUCT = 53,
  sym_UNION = 54,
  sym_ENUM = 55,
  sym_ELLIPSIS = 56,
  sym_CASE = 57,
  sym_DEFAULT = 58,
  sym_IF = 59,
  sym_ELSE = 60,
  sym_SWITCH = 61,
  sym_WHILE = 62,
  sym_DO = 63,
  sym_FOR = 64,
  sym_GOTO = 65,
  sym_CONTINUE = 66,
  sym_BREAK = 67,
  sym_RETURN = 68,
  sym_ALIGNAS = 69,
  sym_ALIGNOF = 70,
  sym_ATOMIC = 71,
  sym_GENERIC = 72,
  sym_NORETURN = 73,
  sym_STATIC_ASSERT = 74,
  sym_THREAD_LOCAL = 75,
  sym_MAYBECONST = 76,
  sym_NEW_FIELD = 77,
  sym_TRACE = 78,
  sym_FOREACH_DIMENSION = 79,
  sym_REDUCTION = 80,
  sym_MACRO = 81,
  sym_ELLIPSIS_MACRO = 82,
  sym_MACRODEF = 83,
  sym_foreach_statement = 84,
  sym_85_ = 85,
  sym_86_ = 86,
  sym_87_ = 87,
  sym_88_ = 88,
  sym_89_ = 89,
  sym_90_ = 90,
  sym_91_ = 91,
  sym_92_ = 92,
  sym_93_ = 93,
  sym_94_ = 94,
  sym_95_ = 95,
  sym_96_ = 96,
  sym_97_ = 97,
  sym_98_ = 98,
  sym_99_ = 99,
  sym_100_ = 100,
  sym_101_ = 101,
  sym_102_ = 102,
  sym_103_ = 103,
  sym_104_ = 104,
  sym_105_ = 105,
  sym_106_ = 106,
  sym_107_ = 107,
  sym_108_ = 108,
  sym_YYACCEPT = 109,
  sym_translation_unit = 110,
  sym_primary_expression = 111,
  sym_expression_error = 112,
  sym_constant = 113,
  sym_enumeration_constant = 114,
  sym_string = 115,
  sym_generic_selection = 116,
  sym_generic_assoc_list = 117,
  sym_generic_association = 118,
  sym_postfix_expression = 119,
  sym_postfix_initializer = 120,
  sym_array_access = 121,
  sym_function_call = 122,
  sym_member_identifier = 123,
  sym_argument_expression_list = 124,
  sym_argument_expression_list_item = 125,
  sym_unary_expression = 126,
  sym_unary_operator = 127,
  sym_cast_expression = 128,
  sym_multiplicative_expression = 129,
  sym_additive_expression = 130,
  sym_shift_expression = 131,
  sym_relational_expression = 132,
  sym_equality_expression = 133,
  sym_and_expression = 134,
  sym_exclusive_or_expression = 135,
  sym_inclusive_or_expression = 136,
  sym_logical_and_expression = 137,
  sym_logical_or_expression = 138,
  sym_conditional_expression = 139,
  sym_assignment_expression = 140,
  sym_assignment_operator = 141,
  sym_expression = 142,
  sym_constant_expression = 143,
  sym_declaration = 144,
  sym_declaration_specifiers = 145,
  sym_init_declarator_list = 146,
  sym_init_declarator = 147,
  sym_storage_class_specifier = 148,
  sym_type_specifier = 149,
  sym_types = 150,
  sym_struct_or_union_specifier = 151,
  sym_struct_or_union = 152,
  sym_struct_declaration_list = 153,
  sym_struct_declaration = 154,
  sym_specifier_qualifier_list = 155,
  sym_struct_declarator_list = 156,
  sym_struct_declarator = 157,
  sym_enum_specifier = 158,
  sym_enumerator_list = 159,
  sym_enumerator = 160,
  sym_atomic_type_specifier = 161,
  sym_type_qualifier = 162,
  sym_function_specifier = 163,
  sym_alignment_specifier = 164,
  sym_declarator = 165,
  sym_direct_declarator = 166,
  sym_generic_identifier = 167,
  sym_pointer = 168,
  sym_type_qualifier_list = 169,
  sym_parameter_type_list = 170,
  sym_parameter_list = 171,
  sym_parameter_declaration = 172,
  sym_identifier_list = 173,
  sym_type_name = 174,
  sym_abstract_declarator = 175,
  sym_direct_abstract_declarator = 176,
  sym_type_not_specified = 177,
  sym_initializer = 178,
  sym_initializer_list = 179,
  sym_designation = 180,
  sym_designator_list = 181,
  sym_designator = 182,
  sym_static_assert_declaration = 183,
  sym_statement = 184,
  sym_labeled_statement = 185,
  sym_compound_statement = 186,
  sym_187_1 = 187,
  sym_block_item_list = 188,
  sym_block_item = 189,
  sym_expression_statement = 190,
  sym_selection_statement = 191,
  sym_for_scope = 192,
  sym_iteration_statement = 193,
  sym_for_declaration_statement = 194,
  sym_jump_statement = 195,
  sym_external_declaration = 196,
  sym_function_declaration = 197,
  sym_function_definition = 198,
  sym_declaration_list = 199,
  sym_basilisk_statements = 200,
  sym_macro_statement = 201,
  sym_reduction_list = 202,
  sym_reduction = 203,
  sym_reduction_operator = 204,
  sym_reduction_array = 205,
  sym_foreach_dimension_statement = 206,
  sym_forin_declaration_statement = 207,
  sym_forin_statement = 208,
  sym_forin_arguments = 209,
  sym_event_definition = 210,
  sym_event_parameters = 211,
  sym_event_parameter = 212,
  sym_boundary_definition = 213,
  sym_external_foreach_dimension = 214,
  sym_attribute = 215,
  sym_new_field = 216,
  sym_root = 217
};
#line 633 "/home/pwachara/basilisk/src/grid/config.h"

enum typedef_kind_t {
  sym_SCALAR = sym_root + 1,
  sym_VECTOR,
  sym_TENSOR,
  sym_COORD,
  sym__COORD,
  sym_VEC4,
  sym_IVEC
};

#define attroffset(x) (offsetof(_Attributes,x))




typedef int Reduce;

void macro_foreach_face (char flags, Reduce reductions,
   const char * order)
{;}
void macro_einstein_sum() {;}
void macro_diagonalize (int a) {;}




#define dimensional(...)

#define show_dimension_internal(...)
#define display_value(...)
#define interpreter_verbosity(...)
#line 20 "/home/pwachara/basilisk/src/common.h"

static inline double noise() { return 1. - 2.*rand()/(double)RAND_MAX; }


typedef struct {
  long n;
  long tn;
  int depth;
  int maxdepth;
} Grid;
Grid * grid = NULL;

double X0 = 0., Y0 = 0., Z0 = 0.;

double L0 = 1.;




int N = 16;


typedef struct { int i; } scalar;

typedef struct {
  scalar x;

  scalar y;


  scalar z;

} vector;

typedef struct {
  scalar * x;

  scalar * y;


  scalar * z;

} vectorl;

typedef struct {
  vector x;

  vector y;


  vector z;

} tensor;

struct { int x, y, z; } Period = {false, false, false};

typedef struct {
  double x, y, z;
} coord;

OMP(omp declare reduction (+ : coord :
      omp_out.x += omp_in.x,
      omp_out.y += omp_in.y,
      omp_out.z += omp_in.z))
#line 96 "/home/pwachara/basilisk/src/common.h"
void normalize (coord * n)
{
  double norm = 0.;
  
    norm += ( (n->x)*(n->x));    norm += ( (n->y)*(n->y));    norm += ( (n->z)*(n->z));
  norm = sqrt(norm);
  
    n->x /= norm;    n->y /= norm;    n->z /= norm;
}

void origin (double x, double y, double z) {
  X0 = x; Y0 = y; Z0 = z;
}

void size (double L) {
  L0 = L;
}

double zero (double s0, double s1, double s2) { return 0.; }
#line 123 "/home/pwachara/basilisk/src/common.h"
  enum { right, left, top, bottom, front, back };

int nboundary = 2*3;



double * _constant = NULL;
size_t datasize = 0;
typedef struct _Point Point;

#line 1 "/home/pwachara/basilisk/src/grid/boundaries.h"


typedef struct _Boundary Boundary;

struct _Boundary {
  void (* destroy) (Boundary * b);
  void (* level) (const Boundary * b, scalar * list, int l);

  void (* restriction) (const Boundary * b, scalar * list, int l);
};

static Boundary ** boundaries = NULL;

void add_boundary (Boundary * b) {
  int len = 0;
  if (boundaries) {
    Boundary ** i = boundaries;
    while (*i++) len++;
  }
  boundaries = (Boundary * *) prealloc (boundaries, (len + 2)*sizeof(Boundary *),__func__,__FILE__,__LINE__);
  boundaries[len] = b;
  boundaries[len+1] = NULL;
}

void free_boundaries() {
  if (!boundaries)
    return;
  Boundary ** i = boundaries, * b;
  while ((b = *i++))
    if (b->destroy)
      b->destroy (b);
    else
      pfree (b,__func__,__FILE__,__LINE__);
  pfree (boundaries,__func__,__FILE__,__LINE__);
  boundaries = NULL;
}
#line 47 "/home/pwachara/basilisk/src/grid/boundaries.h"
typedef struct {
  Boundary parent;
  int d;
} BoxBoundary;
#line 134 "/home/pwachara/basilisk/src/common.h"



typedef struct {
  int x;

  int y;


  int z;

} ivec;
typedef double (* BoundaryFunc) (Point, Point, scalar, bool *);
typedef struct {
  BoundaryFunc * boundary;
  BoundaryFunc * boundary_homogeneous;
  double (* gradient) (double, double, double);
  void (* delete) (scalar);
  char * name;
  ivec d;
  vector v;
  int face;
  bool nodump, freed;
  int block;
  scalar * depends;  
#line 19 "/home/pwachara/basilisk/src/grid/stencils.h"
bool input, output, nowarning;
  int width;
  int dirty;  
#line 21 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
void (* prolongation) (Point, scalar);
  void (* restriction) (Point, scalar);
  
#line 178 "/home/pwachara/basilisk/src/embed.h"
bool third;  
#line 28 "/home/pwachara/basilisk/src/vof.h"
scalar * tracers, c;
  bool inverse;  
#line 21 "/home/pwachara/basilisk/src/iforce.h"
scalar phi;
  
#line 460 "/home/pwachara/basilisk/src/heights.h"
vector height;  
#line 22 "/home/pwachara/basilisk/src/tension.h"
double sigma;

#line 159 "/home/pwachara/basilisk/src/common.h"
} _Attributes;

static _Attributes * _attribute = NULL;
#line 171 "/home/pwachara/basilisk/src/common.h"
ivec Dimensions = {1,1,1};




int list_len (scalar * list)
{
  if (!list) return 0;
  int ns = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ ns++;}}
  return ns;
}

scalar * list_append (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) prealloc (list, (len + 2)*sizeof(scalar),__func__,__FILE__,__LINE__);
  list[len] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_prepend (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) prealloc (list, (len + 2)*sizeof(scalar),__func__,__FILE__,__LINE__);
  for (int i = len; i >= 1; i--)
    list[i] = list[i-1];
  list[0] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_add (scalar * list, scalar s)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
    if (t.i == s.i)
      return list;}}
  return list_append (list, s);
}

int list_lookup (scalar * l, scalar s)
{
  if (l != NULL)
    {scalar*_i=(scalar*)( l);if(_i)for(scalar s1=*_i;(&s1)->i>=0;s1=*++_i){
      if (s1.i == s.i)
 return true;}}
  return false;
}

scalar * list_copy (scalar * l)
{
  scalar * list = NULL;
  if (l != NULL)
    {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      list = list_append (list, s);}}
  return list;
}

scalar * list_concat (scalar * l1, scalar * l2)
{
  scalar * l3 = list_copy (l1);
  {scalar*_i=(scalar*)( l2);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    l3 = list_append (l3, s);}}
  return l3;
}

void list_print (scalar * l, FILE * fp)
{
  int i = 0;
  {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    fprintf (fp, "%s%s", i++ == 0 ? "{" : ",", _attribute[s.i].name);}}
  fputs (i > 0 ? "}\n" : "{}\n", fp);
}

int vectors_len (vector * list)
{
  if (!list) return 0;
  int nv = 0;
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){ nv++;}}
  return nv;
}

vector * vectors_append (vector * list, vector v)
{
  int len = vectors_len (list);
  list = (vector *) prealloc (list, (len + 2)*sizeof(vector),__func__,__FILE__,__LINE__);
  list[len] = v;
  list[len + 1] = (vector){{-1}};
  return list;
}

vector * vectors_add (vector * list, vector v)
{
  {vector*_i=(vector*)( list);if(_i)for(vector w=*_i;(&w)->x.i>=0;w=*++_i){ {
    bool id = true;
    
      if (w.x.i != v.x.i)
 id = false;      
#line 268
if (w.y.i != v.y.i)
 id = false;      
#line 268
if (w.z.i != v.z.i)
 id = false;
    if (id)
      return list;
  }}}
  return vectors_append (list, v);
}

vector * vectors_copy (vector * l)
{
  vector * list = NULL;
  if (l != NULL)
    {vector*_i=(vector*)( l);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
      list = vectors_append (list, v);}}
  return list;
}

vector * vectors_from_scalars (scalar * s)
{
  vector * list = NULL;
  while (s->i >= 0) {
    vector v;
     {
      if (!(s->i >= 0)) qassert ("/home/pwachara/basilisk/src/common.h", 291, "s->i >= 0");
      v.x = *s++;
    } 
#line 290
{
      if (!(s->i >= 0)) qassert ("/home/pwachara/basilisk/src/common.h", 291, "s->i >= 0");
      v.y = *s++;
    } 
#line 290
{
      if (!(s->i >= 0)) qassert ("/home/pwachara/basilisk/src/common.h", 291, "s->i >= 0");
      v.z = *s++;
    }
    list = vectors_append (list, v);
  }
  return list;
}

int tensors_len (tensor * list)
{
  if (!list) return 0;
  int nt = 0;
  {tensor*_i=(tensor*)( list);if(_i)for(tensor t=*_i;(&t)->x.x.i>=0;t=*++_i){ nt++;}}
  return nt;
}

tensor * tensors_append (tensor * list, tensor t)
{
  int len = tensors_len (list);
  list = (tensor *) prealloc (list, (len + 2)*sizeof(tensor),__func__,__FILE__,__LINE__);
  list[len] = t;
  list[len + 1] = (tensor){{{-1}}};
  return list;
}

tensor * tensors_from_vectors (vector * v)
{
  tensor * list = NULL;
  while (v->x.i >= 0) {
    tensor t;
     {
      if (!(v->x.i >= 0)) qassert ("/home/pwachara/basilisk/src/common.h", 322, "v->x.i >= 0");
      t.x = *v++;
    } 
#line 321
{
      if (!(v->y.i >= 0)) qassert ("/home/pwachara/basilisk/src/common.h", 322, "v->x.i >= 0");
      t.y = *v++;
    } 
#line 321
{
      if (!(v->z.i >= 0)) qassert ("/home/pwachara/basilisk/src/common.h", 322, "v->x.i >= 0");
      t.z = *v++;
    }
    list = tensors_append (list, t);
  }
  return list;
}

static inline bool is_vertex_scalar (scalar s)
{
  
    if (_attribute[s.i].d.x != -1)
      return false;    
#line 333
if (_attribute[s.i].d.y != -1)
      return false;    
#line 333
if (_attribute[s.i].d.z != -1)
      return false;
  return true;
}

scalar * all = NULL;
scalar * baseblock = NULL;



scalar (* init_scalar) (scalar, const char *);
scalar (* init_vertex_scalar) (scalar, const char *);
vector (* init_vector) (vector, const char *);
vector (* init_face_vector) (vector, const char *);
tensor (* init_tensor) (tensor, const char *);
void (* scalar_clone) (scalar, scalar);






static double mpi_time = 0.;


typedef struct {
  clock_t c;
  struct timeval tv;
  double tm;
} timer;

timer timer_start (void)
{
  timer t;
  t.c = clock();
  gettimeofday (&t.tv, NULL);

  t.tm = mpi_time;

  return t;
}

double timer_elapsed (timer t)
{
  struct timeval tvend;
  gettimeofday (&tvend, NULL);
  return ((tvend.tv_sec - t.tv.tv_sec) +
   (tvend.tv_usec - t.tv.tv_usec)/1e6);
}



const vector zerof = {{_NVARMAX+4},{_NVARMAX+5},{_NVARMAX+6}};
const vector unityf = {{_NVARMAX+7},{_NVARMAX+8},{_NVARMAX+9}};
const scalar unity = {_NVARMAX+10};
const scalar zeroc = {_NVARMAX+11};



        vector fm = {{_NVARMAX+12},{_NVARMAX+13},{_NVARMAX+14}};
        scalar cm = {_NVARMAX+15};
#line 407 "/home/pwachara/basilisk/src/common.h"
void * matrix_new (int n, int p, size_t size)
{
  void ** m = ((void * *) pmalloc ((n)*sizeof(void *),__func__,__FILE__,__LINE__));
  char * a = ((char *) pmalloc ((n*p*size)*sizeof(char),__func__,__FILE__,__LINE__));
  for (int i = 0; i < n; i++)
    m[i] = a + i*p*size;
  return m;
}

double matrix_inverse (double ** m, int n, double pivmin)
{
  int indxc[n], indxr[n], ipiv[n];
  int i, icol = 0, irow = 0, j, k, l, ll;
  double big, dum, pivinv, minpiv = 1e30f;

  for (j = 0; j < n; j++)
    ipiv[j] = -1;

  for (i = 0; i < n; i++) {
    big = 0.0;
    for (j = 0; j < n; j++)
      if (ipiv[j] != 0)
 for (k = 0; k < n; k++) {
   if (ipiv[k] == -1) {
     if (fabs (m[j][k]) >= big) {
       big = fabs (m[j][k]);
       irow = j;
       icol = k;
     }
   }
 }
    ipiv[icol]++;
    if (irow != icol)
      for (l = 0; l < n; l++)
 do { double _tmp_ = m[irow][l]; m[irow][l] = m[icol][l]; m[icol][l] = _tmp_; } while(false);
    indxr[i] = irow;
    indxc[i] = icol;
    if (fabs (m[icol][icol]) <= pivmin)
      return 0.;
    if (fabs (m[icol][icol]) < minpiv)
      minpiv = fabs (m[icol][icol]);
    pivinv = 1.0/m[icol][icol];
    m[icol][icol] = 1.0;
    for (l = 0; l < n; l++) m[icol][l] *= pivinv;
    for (ll = 0; ll < n; ll++)
      if (ll != icol) {
 dum = m[ll][icol];
 m[ll][icol] = 0.0;
 for (l = 0; l < n; l++)
   m[ll][l] -= m[icol][l]*dum;
      }
  }
  for (l = n - 1; l >= 0; l--) {
    if (indxr[l] != indxc[l])
      for (k = 0; k < n; k++)
 do { double _tmp_ = m[k][indxr[l]]; m[k][indxr[l]] = m[k][indxc[l]]; m[k][indxc[l]] = _tmp_; } while(false);
  }
  return minpiv;
}

void matrix_free (void * m)
{
  pfree (((void **) m)[0],__func__,__FILE__,__LINE__);
  pfree (m,__func__,__FILE__,__LINE__);
}



typedef void (* free_solver_func) (void);

static Array * free_solver_funcs = NULL;

void free_solver_func_add (free_solver_func func)
{
  if (!free_solver_funcs)
    free_solver_funcs = array_new();
  array_append (free_solver_funcs, &func, sizeof(free_solver_func));
}



static char * display_defaults = NULL;

static void free_display_defaults() {
  pfree (display_defaults,__func__,__FILE__,__LINE__);
}

void display (const char * commands, bool overwrite)
{
  if (display_defaults == NULL)
    free_solver_func_add (free_display_defaults);
  if (overwrite) {
    pfree (display_defaults,__func__,__FILE__,__LINE__);
    display_defaults = pmalloc (strlen(commands) + 2,__func__,__FILE__,__LINE__);
    strcpy (display_defaults, "@");
    strcat (display_defaults, commands);
  }
  else {
    if (!display_defaults)
      display_defaults = pstrdup ("@",__func__,__FILE__,__LINE__);
    display_defaults =
      prealloc (display_defaults,
        strlen(display_defaults) + strlen(commands) + 1,__func__,__FILE__,__LINE__);
    strcat (display_defaults, commands);
  }
}



typedef struct {
  double x;

  double y;


  double z;

} _coord;



typedef struct {
  float r, g, b, a;
} vec4;
#line 540 "/home/pwachara/basilisk/src/common.h"
typedef struct {
  coord x, y, z;
} mat3;

OMP(omp declare reduction (+ : mat3 :
      omp_out.x.x += omp_in.x.x,
      omp_out.x.y += omp_in.x.y,
      omp_out.x.z += omp_in.x.z,
      omp_out.y.x += omp_in.y.x,
      omp_out.y.y += omp_in.y.y,
      omp_out.y.z += omp_in.y.z,
      omp_out.z.x += omp_in.z.x,
      omp_out.z.y += omp_in.z.y,
      omp_out.z.z += omp_in.z.z
      ))

typedef struct {
  uint32_t s;
} Adler32Hash;

static
inline void a32_hash_init (Adler32Hash * hash)
{
  hash->s = 0;
}

static
inline void a32_hash_add (Adler32Hash * hash, const void * data, size_t size)
{
  const uint8_t * buffer = (const uint8_t*) data;
  for (size_t n = 0; n < size; n++, buffer++)
    hash->s = *buffer + (hash->s << 6) + (hash->s << 16) - hash->s;
}

static
inline uint32_t a32_hash (const Adler32Hash * hash)
{
  return hash->s;
}
#line 14 "CubicTest-cpp.c"
#line 1 "CubicTest.c"
#line 1 "grid/multigrid3D.h"
#line 1 "/home/pwachara/basilisk/src/grid/multigrid3D.h"

#line 1 "grid/multigrid.h"
#line 1 "/home/pwachara/basilisk/src/grid/multigrid.h"



typedef double real;
#line 29 "/home/pwachara/basilisk/src/grid/multigrid.h"
int Dimensions_scale = 1;


typedef struct {
  Grid g;
  char * d;
  size_t * shift;
} Multigrid;

struct _Point {
  int i;

  int j;


  int k;

  int level;





  struct { int x, y, z; } n;





  #define _BLOCK_INDEX

};
static Point last_point;
#line 85 "/home/pwachara/basilisk/src/grid/multigrid.h"
#undef val
#define val(a,l,m,o) (((real *)((Multigrid *)grid)->d)[point.k + (o) +\
       (((size_t)(1 << point.level)) + 2*2)*\
       (point.j + (m) +\
        (point.i + (l))*(((size_t)(1 << point.level)) + 2*2)) +\
       ((Multigrid *)grid)->shift[point.level] +\
       _index(a,0)*((Multigrid *)grid)->shift[depth() + 1]])\

#line 92

#line 121 "/home/pwachara/basilisk/src/grid/multigrid.h"
#define allocated(a,l,m) (point.i+(a) >= 0 &&\
         point.i+(a) < ((size_t)(1 << point.level)) + 2*2 &&\
         point.j+(l) >= 0 &&\
         point.j+(l) < ((size_t)(1 << point.level)) + 2*2 &&\
         point.k+(m) >= 0 &&\
         point.k+(m) < ((size_t)(1 << point.level)) + 2*2)\

#line 127


#define allocated_child(a,l,m) (level < depth() &&\
         point.i > 0 && point.i <= ((size_t)(1 << point.level)) + 2 &&\
         point.j > 0 && point.j <= ((size_t)(1 << point.level)) + 2 &&\
         point.k > 0 && point.k <= ((size_t)(1 << point.level)) + 2)\

#line 133




#define depth() (grid->depth)
#line 186 "/home/pwachara/basilisk/src/grid/multigrid.h"
#define fine(a,l,m,o)\
(((real *)((Multigrid *)grid)->d)[2*point.k - 2 + (o) +\
   (((size_t)(1 << point.level))*2 + 2*2)*\
   (2*point.j - 2 + (m) +\
    (2*point.i - 2 + (l))*(((size_t)(1 << point.level))*2 + 2*2)) +\
   ((Multigrid *)grid)->shift[point.level + 1] +\
   _index(a,0)*((Multigrid *)grid)->shift[depth() + 1]])\

#line 193

#define coarse(a,l,m,o)\
(((real *)((Multigrid *)grid)->d)[(point.k + 2)/2 + (o) +\
   (((size_t)(1 << point.level))/2 + 2*2)*\
   ((point.j + 2)/2 + (m) +\
    ((point.i + 2)/2 + (l))*(((size_t)(1 << point.level))/2 + 2*2)) +\
   ((Multigrid *)grid)->shift[point.level - 1] +\
   _index(a,0)*((Multigrid *)grid)->shift[depth() + 1]])\

#line 201


void macro_POINT_VARIABLES (Point point)
{ 
  
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
}
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
void macro_foreach_level (int l, char flags, Reduce reductions) {
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++)


   ;
    }
  }
}

void macro_foreach (char flags, Reduce reductions) {
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)


     ;
      }
  }
}

#define is_active(cell) (true)
#define is_leaf(cell) (point.level == depth())
#define is_local(cell) (true)
#define leaf 2
#define refine_cell(...) do {\
  fprintf (stderr, "grid depths do not match. Aborting.\n");\
  if (!(0)) qassert ("/home/pwachara/basilisk/src/grid/multigrid.h", 292, "0");\
} while (0)\

#line 294

#define tree ((Multigrid *)grid)
#line 1 "grid/foreach_cell.h"
#line 1 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
#line 66 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
void macro_foreach_cell_root (Point root)
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {

 ;

 if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}

void macro_foreach_cell()
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
      
#line 136
{ 
  
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 136 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
;} 
#line 91
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}

void macro_foreach_cell_all() {
  {
    Point root = {0};
    for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++)

      for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++)


 for (root.k = 2*Period.z; root.k <= 2*(2 - Period.z); root.k++) 
#line 22 "/home/pwachara/basilisk/src/grid/config.h"
{

#line 67 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
     
#line 151
{ 
  
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 151 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
;} 
#line 91
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
#line 22 "/home/pwachara/basilisk/src/grid/config.h"
}
  
#line 152 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
}
}

void macro_foreach_cell_post_root (bool condition, Point root)
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   if (condition)
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 210 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;
      case 4:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 break;
      case 5:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;
      case 6:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 break;
      case 7:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 8; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;

      default:
 ;

      }
    }
  }
}

void macro_foreach_cell_post (bool condition)
{
  {





    Point root = {2,2,2,0};
#line 156
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   if (condition)
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 210 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;
      case 4:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 break;
      case 5:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;
      case 6:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 break;
      case 7:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 8; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;

      default:
      
#line 265
{ 
  
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 265 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
;}      
#line 249
}
    }
  }
}
  
#line 266
}
}

void macro_foreach_cell_post_all (bool condition)
{
  {
    Point root = {0};
    for (root.i = 0; root.i <= 2*2; root.i++)

      for (root.j = 0; root.j <= 2*2; root.j++)


 for (root.k = 0; root.k <= 2*2; root.k++) 
#line 22 "/home/pwachara/basilisk/src/grid/config.h"
{

#line 156 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
 if (point.level == grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 8; };
 }
 else {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   if (condition)
     { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 210 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;
      case 2:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 break;
      case 3:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;
      case 4:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 break;
      case 5:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;
      case 6:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 break;
      case 7:
 { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 8; };
 if (condition)
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; };
 break;

      default:
     
#line 281
{ 
  
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 281 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
;}      
#line 249
}
    }
  }
}
#line 22 "/home/pwachara/basilisk/src/grid/config.h"
}
  
#line 282 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
}
}

void macro_foreach_leaf()
{
#line 126
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: {
    
#line 288
{ 
  
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 288 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (is_leaf (cell)) {
      if (is_active(cell) && is_local(cell))
 ;
      continue;
    }} 
#line 91
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}

#line 293
}
#line 297 "/home/pwachara/basilisk/src/grid/multigrid.h"

void macro_foreach_face_generic (char flags, Reduce reductions,
    const char * order)
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)


     ;
      }
  }
}

#define is_coarse() (point.level < depth())
#line 385 "/home/pwachara/basilisk/src/grid/multigrid.h"
void macro_is_face_x (Point p) {
  if (p.j < p.n.y + 2 && p.k < p.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    ;
  }
}

void macro_is_face_y (Point p) {
  if (p.i < p.n.x + 2 && p.k < p.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    ;
  }
}

void macro_is_face_z (Point p) {
  if (p.i < p.n.x + 2 && p.j < p.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    ;
  }
}

void macro_foreach_child (Point point)
{
  {
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n; 
  
   
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
   
#line 419
;
 }
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }
}


#if TRASH
# undef trash
# define trash(list) reset(list, undefined)
#endif

#line 1 "grid/neighbors.h"
#line 1 "/home/pwachara/basilisk/src/grid/neighbors.h"
#line 33 "/home/pwachara/basilisk/src/grid/neighbors.h"
void macro_foreach_neighbor (int _s,
    Point point) {
  {
    const int _nn = _s;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n; 
  
   
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 45 "/home/pwachara/basilisk/src/grid/neighbors.h"
;
 }
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
}
#line 436 "/home/pwachara/basilisk/src/grid/multigrid.h"

void reset (void * alist, double val)
{
  scalar * list = (scalar *) alist;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s))
      for (int b = 0; b < _attribute[s.i].block; b++) {
 real * data = (real *) ((Multigrid *)grid)->d;
 data += (s.i + b)*((Multigrid *)grid)->shift[depth() + 1];
 for (size_t i = 0; i < ((Multigrid *)grid)->shift[depth() + 1]; i++, data++)
   *data = val;
      }}}
}
#line 519 "/home/pwachara/basilisk/src/grid/multigrid.h"
void macro_foreach_boundary_dir (int l, int d, Reduce reductions) {
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l < 0 ? depth() : l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int * _i = &point.j, * _j = &point.k;
    int _n[2] = { point.n.y, point.n.z };
    if (d == left) {
      point.i = 2;
      ig = -1;
    }
    else if (d == right) {
      point.i = point.n.x + 2 - 1;
      ig = 1;
    }
    else if (d == bottom) {
      point.j = 2;
      _i = &point.i, _n[0] = point.n.x;
      jg = -1;
    }
    else if (d == top) {
      point.j = point.n.y + 2 - 1;
      _i = &point.i, _n[0] = point.n.x;
      jg = 1;
    }
    else if (d == back) {
      point.k = 2;
      _i = &point.i; _j = &point.j;
      _n[0] = point.n.x, _n[1] = point.n.y;
      kg = -1;
    }
    else if (d == front) {
      point.k = point.n.z + 2 - 1;
      _i = &point.i; _j = &point.j;
      _n[0] = point.n.x, _n[1] = point.n.y;
      kg = 1;
    }
    int _l;
    OMP(omp for schedule(static))
      for (_l = 0; _l < _n[0] + 2*2; _l++) {
 *_i = _l;
 for (int _m = 0; _m < _n[1] + 2*2; _m++) {
   *_j = _m;
   ;
 }
      }
  }
}

#define neighbor(o,p,q)\
  ((Point){point.i+o, point.j+p, point.k+q, point.level, point.n _BLOCK_INDEX})\

#line 571

#define is_boundary(point) (point.i < 2 || point.i >= point.n.x + 2 ||\
    point.j < 2 || point.j >= point.n.y + 2 ||\
    point.k < 2 || point.k >= point.n.z + 2)\

#line 575




extern double (* default_scalar_bc[]) (Point, Point, scalar, bool *);
static double periodic_bc (Point point, Point neighbor, scalar s, bool * data);

void macro_foreach_boundary (int b, Reduce reductions)
{
  if (default_scalar_bc[b] != periodic_bc) 
#line 22 "/home/pwachara/basilisk/src/grid/config.h"
{ 
#line 519 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = (
#line 585
depth()
#line 523
) < 0 ? depth() : (
#line 585
depth()
#line 523
);
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int * _i = &point.j, * _j = &point.k;
    int _n[2] = { point.n.y, point.n.z };
    if (b == left) {
      point.i = 2;
      ig = -1;
    }
    else if (b == right) {
      point.i = point.n.x + 2 - 1;
      ig = 1;
    }
    else if (b == bottom) {
      point.j = 2;
      _i = &point.i, _n[0] = point.n.x;
      jg = -1;
    }
    else if (b == top) {
      point.j = point.n.y + 2 - 1;
      _i = &point.i, _n[0] = point.n.x;
      jg = 1;
    }
    else if (b == back) {
      point.k = 2;
      _i = &point.i; _j = &point.j;
      _n[0] = point.n.x, _n[1] = point.n.y;
      kg = -1;
    }
    else if (b == front) {
      point.k = point.n.z + 2 - 1;
      _i = &point.i; _j = &point.j;
      _n[0] = point.n.x, _n[1] = point.n.y;
      kg = 1;
    }
    int _l;
    OMP(omp for schedule(static))
      for (_l = 0; _l < _n[0] + 2*2; _l++) {
 *_i = _l;
 for (int _m = 0; _m < _n[1] + 2*2; _m++) {
   *_j = _m;
      
#line 586
{  
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 586
if (!is_boundary(point))
 ;} 
#line 564
}
      }
  }
}
#line 22 "/home/pwachara/basilisk/src/grid/config.h"
}

#line 588 "/home/pwachara/basilisk/src/grid/multigrid.h"
}

#define neighborp(k,l,o) neighbor(k,l,o)

static void box_boundary_level (const Boundary * b, scalar * scalars, int l)
{
  disable_fpe (FE_DIVBYZERO|FE_INVALID);
  for (int d = 0; d < 2*3; d++)
    if (default_scalar_bc[d] == periodic_bc)
      {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 if (!is_constant(s) && _attribute[s.i].block > 0) {
   if (is_vertex_scalar (s))
     _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = NULL;
   else if (_attribute[s.i].face) {
     vector v = _attribute[s.i].v;
     _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = NULL;
   }
 }}}
  for (int bghost = 1; bghost <= 2; bghost++)
    for (int d = 0; d < 2*3; d++) {

      scalar * list = NULL, * listb = NULL;
      {scalar*_i=(scalar*)( scalars);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 if (!is_constant(s) && _attribute[s.i].block > 0) {
   scalar sb = s;

   if (_attribute[s.i].v.x.i >= 0) {

     int j = 0;
     while ((&_attribute[s.i].v.x)[j].i != s.i) j++;
     sb = (&_attribute[s.i].v.x)[(j - d/2 + 3) % 3];
   }

   if (_attribute[sb.i].boundary[d] && _attribute[sb.i].boundary[d] != periodic_bc) {
     list = list_append (list, s);
     listb = list_append (listb, sb);
   }
 }}}

      if (list) { 
#line 519
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l < 0 ? depth() : l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int * _i = &point.j, * _j = &point.k;
    int _n[2] = { point.n.y, point.n.z };
    if (d == left) {
      point.i = 2;
      ig = -1;
    }
    else if (d == right) {
      point.i = point.n.x + 2 - 1;
      ig = 1;
    }
    else if (d == bottom) {
      point.j = 2;
      _i = &point.i, _n[0] = point.n.x;
      jg = -1;
    }
    else if (d == top) {
      point.j = point.n.y + 2 - 1;
      _i = &point.i, _n[0] = point.n.x;
      jg = 1;
    }
    else if (d == back) {
      point.k = 2;
      _i = &point.i; _j = &point.j;
      _n[0] = point.n.x, _n[1] = point.n.y;
      kg = -1;
    }
    else if (d == front) {
      point.k = point.n.z + 2 - 1;
      _i = &point.i; _j = &point.j;
      _n[0] = point.n.x, _n[1] = point.n.y;
      kg = 1;
    }
    int _l;
    OMP(omp for schedule(static))
      for (_l = 0; _l < _n[0] + 2*2; _l++) {
 *_i = _l;
 for (int _m = 0; _m < _n[1] + 2*2; _m++) {
   *_j = _m; 
#line 628
{  
#line 537 "/home/pwachara/basilisk/src/grid/config.h"
;  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 628
{
   scalar s, sb;
   {scalar*_i0=listb;scalar*_i1= list;if(_i0)for(sb=*_i0,s=*_i1;_i0->i>= 0;sb=*++_i0,s=*++_i1){ {
     if ((_attribute[s.i].face && sb.i == _attribute[s.i].v.x.i) || is_vertex_scalar (s)) {

       if (bghost == 1)
 
    val(s,(ig + 1)/2,(jg + 1)/2,(kg + 1)/2) =
    _attribute[sb.i].boundary[d] (point, neighborp(ig,jg,kg), s, NULL);
     }
     else

      
  val(s,bghost*ig,bghost*jg,bghost*kg) =
  _attribute[sb.i].boundary[d] (neighborp((1 - bghost)*ig,
       (1 - bghost)*jg,
       (1 - bghost)*kg),
    neighborp(bghost*ig,bghost*jg,bghost*kg),
    s, NULL);
   }}}
 }} 
#line 564
}
      }
  }
}
 
#line 649
pfree (list,__func__,__FILE__,__LINE__);
 pfree (listb,__func__,__FILE__,__LINE__);
      }
    }
  enable_fpe (FE_DIVBYZERO|FE_INVALID);
}
#line 786 "/home/pwachara/basilisk/src/grid/multigrid.h"
void free_grid (void)
{
  if (!grid)
    return;
  free_boundaries();
  Multigrid * m = ((Multigrid *)grid);
  pfree (m->d,__func__,__FILE__,__LINE__);
  pfree (m->shift,__func__,__FILE__,__LINE__);
  pfree (m,__func__,__FILE__,__LINE__);
  grid = NULL;
}

int log_base2 (int n) {
  int m = n, r = 0;
  while (m > 1)
    m /= 2, r++;
  return (1 << r) < n ? r + 1 : r;
}

void init_grid (int n)
{
  free_grid();
  Multigrid * m = ((Multigrid *) pmalloc ((1)*sizeof(Multigrid),__func__,__FILE__,__LINE__));
  grid = (Grid *) m;
  grid->depth = grid->maxdepth = log_base2(n/Dimensions.x);
  N = (1 << grid->depth)*Dimensions.x;
#line 820 "/home/pwachara/basilisk/src/grid/multigrid.h"
  Boundary * b = ((Boundary *) pcalloc (1, sizeof(Boundary),__func__,__FILE__,__LINE__));
  b->level = box_boundary_level;
  add_boundary (b);

  Boundary * mpi_boundary_new();
  mpi_boundary_new();
#line 835 "/home/pwachara/basilisk/src/grid/multigrid.h"
  m->shift = ((size_t *) pmalloc ((depth() + 2)*sizeof(size_t),__func__,__FILE__,__LINE__));
  size_t totalsize = 0;
  for (int l = 0; l <= depth() + 1; l++) {
    m->shift[l] = totalsize;
    struct _Point point = { .level = l };
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    size_t size = 1;
    
      size *= point.n.x + 2*2;      size *= point.n.y + 2*2;      size *= point.n.z + 2*2;
    totalsize += size;
  }
  m->d = (char *) pmalloc(m->shift[depth() + 1]*datasize,__func__,__FILE__,__LINE__);
  reset (all, 0.);
}

void realloc_scalar (int size)
{
  Multigrid * p = ((Multigrid *)grid);
  datasize += size;
  p->d = (char *) prealloc (p->d, (p->shift[depth() + 1]*datasize)*sizeof(char),__func__,__FILE__,__LINE__);
}


int mpi_coords[3];
#line 867 "/home/pwachara/basilisk/src/grid/multigrid.h"
Point locate (double xp, double yp, double zp)
{
  Point point = {0};
  point.level = depth();
  point.n.x = point.n.y = point.n.z = 1 << point.level;
  point.level = -1;

  point.i = (xp - X0)/L0*point.n.x*Dimensions.x + 2 - mpi_coords[0]*point.n.x;
  if (point.i < 2 || point.i >= point.n.x + 2)
    return point;

  point.j = (yp - Y0)/L0*point.n.x*Dimensions.x + 2 - mpi_coords[1]*point.n.x;
  if (point.j < 2 || point.j >= point.n.y + 2)
    return point;


  point.k = (zp - Z0)/L0*point.n.x*Dimensions.x + 2 - mpi_coords[2]*point.n.x;
  if (point.k < 2 || point.k >= point.n.z + 2)
    return point;
#line 902 "/home/pwachara/basilisk/src/grid/multigrid.h"
  point.level = depth();
  return point;
}




#line 1 "grid/multigrid-common.h"
#line 1 "/home/pwachara/basilisk/src/grid/multigrid-common.h"


#line 1 "grid/variables.h"
#line 1 "/home/pwachara/basilisk/src/grid/variables.h"
void macro2_VARIABLES (Point point, int _ig, int _jg, int _kg)
{
  double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((_ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((_jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((_kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
}
#line 4 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
#line 1 "grid/cartesian-common.h"
#line 1 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
#line 1 "grid/events.h"
#line 1 "/home/pwachara/basilisk/src/grid/events.h"
typedef struct _Event Event;
typedef int (* Expr) (int *, double *, Event *);

struct _Event {
  int last, nexpr;
  int (* action) (const int, const double, Event *);
  Expr expr[3];
  int * arrayi;
  double * arrayt;
  char * file;
  int line;
  char * name;
  double t;
  int i, a;
  void * data;
  Event * next;
};

static Event * Events = NULL;

int iter = 0, inext = 0;
double t = 0, tnext = 0;
void init_events (void);
void event_register (Event event);
static void _init_solver (void);





static int END_EVENT = 1234567890;
static double TEND_EVENT = 1234567890;
static double TEPS = 1e-9;

static void event_error (Event * ev, const char * s)
{
  fprintf (ferr, "%s:%d: error: %s\n", ev->file, ev->line, s);
  exit (1);
}

static void init_event (Event * ev)
{
  if (ev->arrayi || ev->arrayt) {
    ev->i = -1; ev->t = - TEND_EVENT;
    if (ev->arrayi)
      ev->i = ev->arrayi[0];
    else
      ev->t = ev->arrayt[0];
    ev->a = 1;
    ev->expr[1] = NULL;
  }
  else {
    if (ev->nexpr > 0) {
      Expr init = NULL, cond = NULL, inc = NULL;
      for (int j = 0; j < ev->nexpr; j++) {
 int i = -123456; double t = - TEND_EVENT;
 (* ev->expr[j]) (&i, &t, ev);
 if (i == -123456 && t == - TEND_EVENT) {

   if (cond)
     event_error (ev, "events can only use a single condition");
   cond = ev->expr[j];
 }
 else {

   int i1 = i; double t1 = t;
   (* ev->expr[j]) (&i1, &t1, ev);
   if (i1 == i && t1 == t) {


     if (init)
       event_error (ev, "events can only use a single initialisation");
     init = ev->expr[j];
   }
   else {

     if (inc)
       event_error (ev, "events can only use a single increment");
     inc = ev->expr[j];
   }
 }
      }
      ev->expr[0] = init;
      ev->expr[1] = cond;
      ev->expr[2] = inc;
      ev->nexpr = 0;
    }
    ev->i = -1; ev->t = - TEND_EVENT;
    if (ev->expr[0]) {
      (* ev->expr[0]) (&ev->i, &ev->t, ev);
      if (ev->i == END_EVENT || ev->t == TEND_EVENT) {
 ev->i = END_EVENT; ev->t = - TEND_EVENT;
      }
    }
    else if (ev->expr[2]) {
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (ev->i != -1)
 ev->i = 0;
      if (ev->t != - TEND_EVENT)
 ev->t = 0;
    }
  }
}

enum { event_done, event_alive, event_stop };

static int event_finished (Event * ev)
{
  ev->i = -1; ev->t = - TEND_EVENT;
  return event_done;
}

void event_register (Event event) {
  if (!(Events)) qassert ("/home/pwachara/basilisk/src/grid/events.h", 114, "Events");
  if (!(!event.last)) qassert ("/home/pwachara/basilisk/src/grid/events.h", 115, "!event.last");
  int n = 0, parent = -1;
  for (Event * ev = Events; !ev->last; ev++) {
    if (!strcmp (event.name, ev->name)) {
      if (!(parent < 0)) qassert ("/home/pwachara/basilisk/src/grid/events.h", 119, "parent < 0");
      parent = n;
    }
    n++;
  }
  if (parent < 0) {
    Events = (Event *) prealloc (Events, (n + 2)*sizeof(Event),__func__,__FILE__,__LINE__);
    Events[n] = event;
    Events[n].next = NULL;
    Events[n + 1].last = true;
    init_event (&Events[n]);
  }
  else {
    Event * ev = ((Event *) pcalloc (1, sizeof(Event),__func__,__FILE__,__LINE__));
    *ev = Events[parent];
    Events[parent] = event;
    Events[parent].next = ev;
    init_event (&Events[parent]);
  }
}

static int event_cond (Event * ev, int i, double t)
{
  if (!ev->expr[1])
    return true;
  return (* ev->expr[1]) (&i, &t, ev);
}
#line 162 "/home/pwachara/basilisk/src/grid/events.h"
static bool overload_event() { return true; }

static int event_do (Event * ev, bool action)
{
  if ((iter > ev->i && t > ev->t) || !event_cond (ev, iter, t))
    return event_finished (ev);
  if (!overload_event() || iter == ev->i || fabs (t - ev->t) <= TEPS*t) {
    if (action) {
      bool finished = false;
      for (Event * e = ev; e; e = e->next) {



 if ((* e->action) (iter, t, e))
   finished = true;
      }
      if (finished) {
 event_finished (ev);
 return event_stop;
      }
    }
    if (ev->arrayi) {
      ev->i = ev->arrayi[ev->a++];
      if (ev->i < 0)
 return event_finished (ev);
    }
    if (ev->arrayt) {
      ev->t = ev->arrayt[ev->a++];
      if (ev->t < 0)
 return event_finished (ev);
    }
    else if (ev->expr[2]) {
      int i0 = ev->i;
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (i0 == -1 && ev->i != i0)
 ev->i += iter + 1;
      if (!event_cond (ev, iter + 1, ev->t))
 return event_finished (ev);
    }
    else if (ev->expr[0] && !ev->expr[1])
      return event_finished (ev);
  }
  return event_alive;
}

static void end_event_do (bool action)
{




  for (Event * ev = Events; !ev->last; ev++)
    if (ev->i == END_EVENT && action)
      for (Event * e = ev; e; e = e->next) {



 e->action (iter, t, e);
      }
}

int events (bool action)
{





  if (iter == 0)
    for (Event * ev = Events; !ev->last; ev++)
      init_event (ev);

  int cond = 0, cond1 = 0;
  inext = END_EVENT; tnext = 1e30f;
  for (Event * ev = Events; !ev->last && !cond; ev++)
    if (ev->i != END_EVENT &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond = 1;
  for (Event * ev = Events; !ev->last; ev++) {
    int status = event_do (ev, action);
    if (status == event_stop) {
      end_event_do (action);
      return 0;
    }
    if (status == event_alive && ev->i != END_EVENT &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond1 = 1;
    if (ev->t > t && ev->t < tnext)
      tnext = ev->t;
    if (ev->i > iter && ev->i < inext)
      inext = ev->i;
  }
  if (overload_event() && (!cond || cond1) && (tnext != 1e30f || inext != END_EVENT)) {
    inext = iter + 1;
    return 1;
  }
  end_event_do (action);
  return 0;
}

void event (const char * name)
{
  for (Event * ev = Events; !ev->last; ev++)
    if (!strcmp (ev->name, name))
      for (Event * e = ev; e; e = e->next) {



 (* e->action) (0, 0, e);
      }
}

double dtnext (double dt)
{
  if (tnext != 1e30f && tnext > t) {
    if (!(dt > 0.)) qassert ("/home/pwachara/basilisk/src/grid/events.h", 277, "dt > 0.");
    unsigned int n = (tnext - t)/dt;
    if (!(n < INT_MAX)) qassert ("/home/pwachara/basilisk/src/grid/events.h", 279, "n < INT_MAX");
    if (n == 0)
      dt = tnext - t;
    else {
      double dt1 = (tnext - t)/n;
      if (dt1 > dt*(1. + TEPS))
 dt = (tnext - t)/(n + 1);
      else if (dt1 < dt)
 dt = dt1;
      tnext = t + dt;
    }
  }
  else
    tnext = t + dt;
  return dt;
}

void init_solver()
{
  Events = pmalloc (sizeof (Event),__func__,__FILE__,__LINE__);
  Events[0].last = 1;
  _attribute = pcalloc (datasize/sizeof(real), sizeof (_Attributes),__func__,__FILE__,__LINE__);
  int n = datasize/sizeof(real);
  all = (scalar *) pmalloc (sizeof (scalar)*(n + 1),__func__,__FILE__,__LINE__);
  baseblock = (scalar *) pmalloc (sizeof (scalar)*(n + 1),__func__,__FILE__,__LINE__);
  for (int i = 0; i < n; i++)
    baseblock[i].i = all[i].i = i;
  baseblock[n].i = all[n].i = -1;




  mpi_init();





}
#line 2 "/home/pwachara/basilisk/src/grid/cartesian-common.h"

void (* debug) (Point);

#define _val_constant(a,k,l,m) ((const double) _constant[a.i -_NVARMAX])
#define val_diagonal(a,k,l,m) ((k) == 0 && (l) == 0 && (m) == 0)

#line 1 "grid/fpe.h"
#line 1 "/home/pwachara/basilisk/src/grid/fpe.h"


#include <signal.h>
#include <unistd.h>

static int gdb()
{
  if (last_point.level >= 0) {
    debug (last_point);
    fputc ('\n', ferr);
    fflush (ferr);
  }
  char command[80];
  sprintf (command, "exec xterm -e 'gdb -p %d' & xterm -e 'gnuplot plot -'",
    getpid());
  return system (command);
}

static void caught_abort (int sig)
{
  fprintf (ferr, "Caught signal %d (Aborted)\n", sig);
  gdb();
}

static void caught_fpe (int sig)
{
  fprintf (ferr, "Caught signal %d (Floating Point Exception)\n", sig);
  gdb();
  exit (1);
}

static void caught_segfault (int sig)
{
  fprintf (ferr, "Caught signal %d (Segmentation Fault)\n", sig);
  gdb();
  exit (2);
}

void catch_fpe (void)
{
  struct sigaction act;
  act.sa_handler = caught_fpe;
  sigemptyset (&act.sa_mask);
  act.sa_flags = 0;
  last_point.level = -1;
  sigaction (8, &act, NULL);
  act.sa_handler = caught_segfault;
  sigaction (11, &act, NULL);
  act.sa_handler = caught_abort;
  act.sa_flags = SA_RESETHAND;
  sigaction (6, &act, NULL);
}
#line 9 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
#line 1 "grid/stencils.h"
#line 1 "/home/pwachara/basilisk/src/grid/stencils.h"
#line 17 "/home/pwachara/basilisk/src/grid/stencils.h"










typedef struct _External External;

struct _External {
  char * name;
  void * pointer;
  int type;
  int nd;
  char reduct;
  char global;
  void * data;
  scalar s;
  External * externals, * next;
  int used;
};

typedef struct {
  const char * fname;
  int line;
  int first;
  int face;
  bool vertex;
  int parallel;
  scalar * listc;
  vectorl listf;
  scalar * dirty;
  void * data;
} ForeachData;







static inline bool scalar_is_dirty (scalar s)
{
  if (_attribute[s.i].dirty)
    return true;
  scalar * depends = _attribute[s.i].depends;
  {scalar*_i=(scalar*)( depends);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
    if (_attribute[d.i].dirty)
      return true;}}
  return false;
}




static inline bool scalar_depends_from (scalar a, scalar b)
{
  scalar * depends = _attribute[a.i].depends;
  {scalar*_i=(scalar*)( depends);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (s.i == b.i)
      return true;}}
  return false;
}







void boundary_internal (scalar * list, const char * fname, int line);
void (* boundary_face) (vectorl);







void check_stencil (ForeachData * loop)
{
  loop->listf = (vectorl){NULL};




  {scalar*_i=(scalar*)( baseblock);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    bool write = _attribute[s.i].output, read = _attribute[s.i].input;




    {





      if (read && scalar_is_dirty (s)) {





 if (_attribute[s.i].face) {
   if (_attribute[s.i].width > 0)
     loop->listc = list_append (loop->listc, s);
   else if (!write) {
     scalar sn = _attribute[s.i].v.x.i >= 0 ? _attribute[s.i].v.x : s;
     
       if (_attribute[s.i].v.x.i == s.i) {




  if (_attribute[sn.i].boundary[left] || _attribute[sn.i].boundary[right])
    loop->listc = list_append (loop->listc, s);
  else if (_attribute[s.i].dirty != 2)
    loop->listf.x = list_append (loop->listf.x, s);
       }       
#line 130
if (_attribute[s.i].v.y.i == s.i) {




  if (_attribute[sn.i].boundary[bottom] || _attribute[sn.i].boundary[top])
    loop->listc = list_append (loop->listc, s);
  else if (_attribute[s.i].dirty != 2)
    loop->listf.y = list_append (loop->listf.y, s);
       }       
#line 130
if (_attribute[s.i].v.z.i == s.i) {




  if (_attribute[sn.i].boundary[back] || _attribute[sn.i].boundary[front])
    loop->listc = list_append (loop->listc, s);
  else if (_attribute[s.i].dirty != 2)
    loop->listf.z = list_append (loop->listf.z, s);
       }
   }
 }





 else if (_attribute[s.i].width > 0)
   loop->listc = list_append (loop->listc, s);
      }





      if (write) {
 if (3 > 1 && !loop->vertex && loop->first && !_attribute[s.i].nowarning) {
   bool vertex = true;
   
     if (_attribute[s.i].d.x != -1)
       vertex = false;     
#line 159
if (_attribute[s.i].d.y != -1)
       vertex = false;     
#line 159
if (_attribute[s.i].d.z != -1)
       vertex = false;
   if (vertex)
     fprintf (ferr,
       "%s:%d: warning: vertex scalar '%s' should be assigned with"
       " a foreach_vertex() loop\n",
       loop->fname, loop->line, _attribute[s.i].name);
 }
 if (_attribute[s.i].face) {
   if (loop->face == 0 && loop->first && !_attribute[s.i].nowarning)
     fprintf (ferr,
       "%s:%d: warning: face vector '%s' should be assigned with"
       " a foreach_face() loop\n",
       loop->fname, loop->line, _attribute[s.i].name);
 }
 else if (loop->face) {
   if (_attribute[s.i].v.x.i < 0) {
     int d = 1, i = 0;
      {
       if (loop->face == d) {
  _attribute[s.i].face = 2, _attribute[s.i].v.x.i = s.i;
  _attribute[s.i].boundary[left] = _attribute[s.i].boundary[right] = NULL;





       }
       d *= 2, i++;
     } 
#line 177
{
       if (loop->face == d) {
  _attribute[s.i].face = 2, _attribute[s.i].v.y.i = s.i;
  _attribute[s.i].boundary[bottom] = _attribute[s.i].boundary[top] = NULL;





       }
       d *= 2, i++;
     } 
#line 177
{
       if (loop->face == d) {
  _attribute[s.i].face = 2, _attribute[s.i].v.z.i = s.i;
  _attribute[s.i].boundary[back] = _attribute[s.i].boundary[front] = NULL;





       }
       d *= 2, i++;
     }
     if (!_attribute[s.i].face && loop->first && !_attribute[s.i].nowarning)
       fprintf (ferr,
         "%s:%d: warning: scalar '%s' should be assigned with "
         "a foreach_face(x|y|z) loop\n",
         loop->fname, loop->line, _attribute[s.i].name);
   }
   else {
     char * name = NULL;
     if (_attribute[s.i].name) {
       name = pstrdup (_attribute[s.i].name,__func__,__FILE__,__LINE__);
       char * s = name + strlen(name) - 1;
       while (s != name && *s != '.') s--;
       if (s != name) *s = '\0';
     }
     struct { int x, y, z; } input, output;
     vector v = _attribute[s.i].v;

     
       input.x = _attribute[v.x.i].input, output.x = _attribute[v.x.i].output;       input.y = _attribute[v.y.i].input, output.y = _attribute[v.y.i].output;       input.z = _attribute[v.z.i].input, output.z = _attribute[v.z.i].output;

     init_face_vector (v, name);


     
       _attribute[v.x.i].input = input.x, _attribute[v.x.i].output = output.x;       _attribute[v.y.i].input = input.y, _attribute[v.y.i].output = output.y;       _attribute[v.z.i].input = input.z, _attribute[v.z.i].output = output.z;





     pfree (name,__func__,__FILE__,__LINE__);
   }
 }
 else if (loop->vertex) {
   bool vertex = true;
   
     if (_attribute[s.i].d.x != -1)
       vertex = false;     
#line 225
if (_attribute[s.i].d.y != -1)
       vertex = false;     
#line 225
if (_attribute[s.i].d.z != -1)
       vertex = false;
   if (!vertex) {
     char * name = NULL;
     if (_attribute[s.i].name) name = pstrdup (_attribute[s.i].name,__func__,__FILE__,__LINE__);
     init_vertex_scalar (s, name);
     
       _attribute[s.i].v.x.i = -1;       _attribute[s.i].v.y.i = -1;       _attribute[s.i].v.z.i = -1;




     pfree (name,__func__,__FILE__,__LINE__);
   }
 }





 loop->dirty = list_append (loop->dirty, s);
 {scalar*_i=(scalar*)( baseblock);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
   if (scalar_depends_from (d, s))
     loop->dirty = list_append (loop->dirty, d);}}
      }
    }
  }}}
}




void boundary_stencil (ForeachData * loop)
{
  bool flux = false;
  
    if (loop->listf.x)
      flux = true;    
#line 261
if (loop->listf.y)
      flux = true;    
#line 261
if (loop->listf.z)
      flux = true;
  if (flux) {
#line 276 "/home/pwachara/basilisk/src/grid/stencils.h"
    boundary_face (loop->listf);
    
      pfree (loop->listf.x,__func__,__FILE__,__LINE__), loop->listf.x = NULL;      pfree (loop->listf.y,__func__,__FILE__,__LINE__), loop->listf.y = NULL;      pfree (loop->listf.z,__func__,__FILE__,__LINE__), loop->listf.z = NULL;
  }




  if (loop->listc) {






    boundary_internal (loop->listc, loop->fname, loop->line);
    pfree (loop->listc,__func__,__FILE__,__LINE__), loop->listc = NULL;
  }





  if (loop->dirty) {






    {scalar*_i=(scalar*)( loop->dirty);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = true;}}
    pfree (loop->dirty,__func__,__FILE__,__LINE__), loop->dirty = NULL;
  }
}

void macro_foreach_stencil (char flags, Reduce reductions)
{
  {
    static int _first = 1.;
    ForeachData _loop = {
      .fname = __FILE__, .line = __LINE__, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);

    ;

    check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
}

void macro_foreach_vertex_stencil (char flags, Reduce reductions) {  
#line 314
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/grid/stencils.h", .line = 335, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
    ;
  }    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }







}

void macro_foreach_face_stencil (char flags, Reduce reductions, const char * order) {  
#line 314
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/grid/stencils.h", .line = 342, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 343
;    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 344
}

void macro_foreach_level_stencil (int l, char flags, Reduce reductions) {
  if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    ;
  }
}

void macro_foreach_coarse_level_stencil (int l, char flags, Reduce reductions) {  
#line 347
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    





;  
#line 352
}





}

void macro_foreach_level_or_leaf_stencil (int l, char flags, Reduce reductions) {  
#line 347
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 362
;  
#line 352
}










}

void macro_foreach_point_stencil (double xp, double yp, double zp, char flags, Reduce reductions)
{  
#line 314
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/grid/stencils.h", .line = 367, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 368
;    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 369
}

void macro_foreach_region_stencil (coord p, coord box[2], coord n, char flags, Reduce reductions)
{  
#line 314
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/grid/stencils.h", .line = 373, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 374
;    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 375
}

void macro__stencil_is_face_x (ForeachData l) { l.face |= (1 << 0); ; }
void macro__stencil_is_face_y (ForeachData l) { l.face |= (1 << 1); ; }
void macro__stencil_is_face_z (ForeachData l) { l.face |= (1 << 2); ; }

void stencil_val (Point p, scalar s, int i, int j, int k,
    const char * file, int line, bool overflow);
void stencil_val_a (Point p, scalar s, int i, int j, int k, bool input,
      const char * file, int line);

#define _stencil_val(a,_i,_j,_k)\
  stencil_val (point, a, _i, _j, _k, __FILE__, __LINE__, false)\

#line 508

#define _stencil_val_o(a,_i,_j,_k)\
  stencil_val (point, a, _i, _j, _k, __FILE__, __LINE__, true)\

#line 511

#define _stencil_val_a(a,_i,_j,_k)\
  stencil_val_a (point, a, _i, _j, _k, false, __FILE__, __LINE__)\

#line 514

#define _stencil_val_r(a,_i,_j,_k)\
  stencil_val_a (point, a, _i, _j, _k, true, __FILE__, __LINE__)\

#line 517


#define _stencil_fine(a,_i,_j,_k) _stencil_val(a,_i,_j,_k)
#define _stencil_fine(a,_i,_j,_k) _stencil_val(a,_i,_j,_k)
#define _stencil_fine_a(a,_i,_j,_k) _stencil_val_a(a,_i,_j,_k)
#define _stencil_fine_r(a,_i,_j,_k) _stencil_val_r(a,_i,_j,_k)

#define _stencil_coarse(a,_i,_j,_k) _stencil_val(a,_i,_j,_k)
#define _stencil_coarse_a(a,_i,_j,_k) _stencil_val_a(a,_i,_j,_k)
#define _stencil_coarse_r(a,_i,_j,_k) _stencil_val_r(a,_i,_j,_k)

#define r_assign(x)
#define _assign(x)

#define _stencil_neighbor(i,j,k)
#define _stencil_child(i,j,k)
#define _stencil_aparent(i,j,k)
#define _stencil_aparent_a(i,j,k)
#define _stencil_aparent_r(i,j,k)

#define _stencil_allocated(i,j,k) true

#define _stencil_neighborp(i,j,k) neighborp(i,j,k)

int _stencil_nop;
#define _stencil_val_higher_dimension (_stencil_nop = 1)
#define _stencil__val_constant(a,_i,_j,_k) (_stencil_nop = 1)
#define _stencil_val_diagonal(a,_i,_j,_k) (_stencil_nop = 1)

typedef void _stencil_undefined;

#define o_stencil -3
#line 10 "/home/pwachara/basilisk/src/grid/cartesian-common.h"

void macro_foreach_point (double _x, double _y, double _z,
        char flags, Reduce reductions)
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    coord _p = { _x, _y, _z };
    Point point = locate (_p.x, _p.y, _p.z);
    if (point.level >= 0)
      ;
  }
}

void macro_foreach_region (coord p, coord box[2], coord n,
         char flags, Reduce reductions)
{
  {
    if (n.x < 1) n.x = 1;
    if (n.y < 1) n.y = 1;
    if (n.z < 1) n.z = 1;

    for (int _i = 0; _i < (int) n.x; _i++) {
      p.x = box[0].x + (box[1].x - box[0].x)/n.x*(_i + 0.5);
      for (int _j = 0; _j < (int) n.y; _j++) {
 p.y = box[0].y + (box[1].y - box[0].y)/n.y*(_j + 0.5);
 for (int _k = 0; _k < (int) n.z; _k++) {
   p.z = box[0].z + (box[1].z - box[0].z)/n.z*(_k + 0.5);
   Point point = locate (p.x, p.y, p.z);
   if (point.level >= 0) {
     int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
     ;
   }
 }
      }
    }
  }
}




static inline
double dirichlet (double expr, Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 54 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
return 2.*expr - val(s,0,0,0);
}

static inline
double dirichlet_homogeneous (double expr, Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 60 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
return - val(s,0,0,0);
}

static inline
double dirichlet_face (double expr)
{
  return expr;
}

static inline
double dirichlet_face_homogeneous (double expr)
{
  return 0.;
}

static inline
double neumann (double expr, Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 78 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
return Delta*expr + val(s,0,0,0);
}

static inline
double neumann_homogeneous (double expr, Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 84 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
return val(s,0,0,0);
}
#line 145 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
static void init_block_scalar (scalar sb, const char * name, const char * ext,
          int n, int block)
{
  char bname[strlen(name) + strlen(ext) + 10];
  if (n == 0) {
    strcat (strcpy (bname, name), ext);
    _attribute[sb.i].block = block;
    baseblock = list_append (baseblock, sb);
  }
  else {
    sprintf (bname, "%s%d%s", name, n, ext);
    _attribute[sb.i].block = - n;
  }
  _attribute[sb.i].name = pstrdup (bname,__func__,__FILE__,__LINE__);
  all = list_append (all, sb);
}

#define interpreter_set_int(...)
#define interpreter_reset_scalar(...)

scalar alloc_block_scalar (const char * name, const char * ext, int block)
{
  interpreter_set_int (&block);
  int nvar = datasize/sizeof(real);

  scalar s = {0};
  while (s.i < nvar) {
    int n = 0;
    scalar sb = s;
    while (sb.i < nvar && n < block && _attribute[sb.i].freed)
      n++, sb.i++;
    if (n >= block) {
      memset (&_attribute[s.i], 0, block*sizeof (_Attributes));
      for (sb.i = s.i, n = 0; n < block; n++, sb.i++) {
 init_block_scalar (sb, name, ext, n, block);
 interpreter_reset_scalar (sb);
      }
      trash (((scalar []){s, {-1}}));
      return s;
    }
    s.i = sb.i + 1;
  }


  s = (scalar){nvar};
  if (!(nvar + block <= _NVARMAX)) qassert ("/home/pwachara/basilisk/src/grid/cartesian-common.h", 190, "nvar + block <= _NVARMAX");

  if (_attribute == NULL)
    _attribute = (_Attributes *) pcalloc (nvar + block + 1, sizeof (_Attributes),__func__,__FILE__,__LINE__);
  else
    _attribute = (_Attributes *)
      prealloc (_attribute, (nvar + block + 1)*sizeof (_Attributes),__func__,__FILE__,__LINE__);
  memset (&_attribute[nvar], 0, block*sizeof (_Attributes));
  for (int n = 0; n < block; n++, nvar++) {
    scalar sb = (scalar){nvar};
    init_block_scalar (sb, name, ext, n, block);
  }

  realloc_scalar (block*sizeof(real));
  trash (((scalar []){s, {-1}}));
  return s;
}

scalar new_block_scalar (const char * name, const char * ext, int block)
{
  scalar s = alloc_block_scalar (name, ext, block), sb;
  int n = 0;
  for (sb.i = s.i, n = 0; n < block; n++, sb.i++)
    init_scalar (sb, NULL);
  return s;
}

scalar new_scalar (const char * name)
{
  return init_scalar (alloc_block_scalar (name, "", 1), NULL);
}

scalar new_vertex_scalar (const char * name)
{
  return init_vertex_scalar (alloc_block_scalar (name, "", 1), NULL);
}

static vector alloc_block_vector (const char * name, int block)
{
  vector v;
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  
    v.x = alloc_block_scalar (name, ext.x, block);    v.y = alloc_block_scalar (name, ext.y, block);    v.z = alloc_block_scalar (name, ext.z, block);
  return v;
}

vector new_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_vector (v, NULL);
  return v;
}

vector new_face_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_face_vector (v, NULL);
  return v;
}

vector new_block_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;
    
      vb.x.i = v.x.i + i;      vb.y.i = v.y.i + i;      vb.z.i = v.z.i + i;
    init_vector (vb, NULL);
    
      _attribute[vb.x.i].block = - i;      _attribute[vb.y.i].block = - i;      _attribute[vb.z.i].block = - i;
  }
  
    _attribute[v.x.i].block = block;    _attribute[v.y.i].block = block;    _attribute[v.z.i].block = block;
  return v;
}

vector new_block_face_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;
    
      vb.x.i = v.x.i + i;      vb.y.i = v.y.i + i;      vb.z.i = v.z.i + i;
    init_face_vector (vb, NULL);
    
      _attribute[vb.x.i].block = - i;      _attribute[vb.y.i].block = - i;      _attribute[vb.z.i].block = - i;
  }
  
    _attribute[v.x.i].block = block;    _attribute[v.y.i].block = block;    _attribute[v.z.i].block = block;
  return v;
}

tensor new_tensor (const char * name)
{
  char cname[strlen(name) + 3];
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  tensor t;
   {
    strcat (strcpy (cname, name), ext.x);
    t.x = alloc_block_vector (cname, 1);
  } 
#line 287
{
    strcat (strcpy (cname, name), ext.y);
    t.y = alloc_block_vector (cname, 1);
  } 
#line 287
{
    strcat (strcpy (cname, name), ext.z);
    t.z = alloc_block_vector (cname, 1);
  }
  init_tensor (t, NULL);
  return t;
}

tensor new_symmetric_tensor (const char * name)
{
  struct { char * x, * y, * z; } ext = {".x.x", ".y.y", ".z.z"};
  tensor t;
  
    t.x.x = alloc_block_scalar (name, ext.x, 1);    t.y.y = alloc_block_scalar (name, ext.y, 1);    t.z.z = alloc_block_scalar (name, ext.z, 1);

    t.x.y = alloc_block_scalar (name, ".x.y", 1);
    t.y.x = t.x.y;


    t.x.z = alloc_block_scalar (name, ".x.z", 1);
    t.z.x = t.x.z;
    t.y.z = alloc_block_scalar (name, ".y.z", 1);
    t.z.y = t.y.z;




  init_tensor (t, NULL);
  return t;
}

static int nconst = 0;

void init_const_scalar (scalar s, const char * name, double val)
{
  if (s.i - _NVARMAX >= nconst) {
    _constant = (double *) prealloc (_constant, (s.i - _NVARMAX + 1)*sizeof(double),__func__,__FILE__,__LINE__);
    for (int i = nconst; i < s.i - _NVARMAX; i++)
      _constant[i] = 0.;
    nconst = s.i - _NVARMAX + 1;
  }
  _constant[s.i - _NVARMAX] = val;
}

scalar new_const_scalar (const char * name, int i, double val)
{
  scalar s = (scalar){i + _NVARMAX};
  init_const_scalar (s, name, val);
  return s;
}

void init_const_vector (vector v, const char * name, double * val)
{
  
    init_const_scalar (v.x, name, *val++);    init_const_scalar (v.y, name, *val++);    init_const_scalar (v.z, name, *val++);
}

vector new_const_vector (const char * name, int i, double * val)
{
  vector v;
  
    v.x.i = _NVARMAX + i++;    v.y.i = _NVARMAX + i++;    v.z.i = _NVARMAX + i++;
  init_const_vector (v, name, val);
  return v;
}

static void cartesian_scalar_clone (scalar clone, scalar src)
{
  char * cname = _attribute[clone.i].name;
  BoundaryFunc * boundary = _attribute[clone.i].boundary;
  BoundaryFunc * boundary_homogeneous = _attribute[clone.i].boundary_homogeneous;
  if (!(_attribute[src.i].block > 0 && _attribute[clone.i].block == _attribute[src.i].block)) qassert ("/home/pwachara/basilisk/src/grid/cartesian-common.h", 358, "src.block > 0 && clone.block == src.block");
  pfree (_attribute[clone.i].depends,__func__,__FILE__,__LINE__);
  _attribute[clone.i] = _attribute[src.i];
  _attribute[clone.i].name = cname;
  _attribute[clone.i].boundary = boundary;
  _attribute[clone.i].boundary_homogeneous = boundary_homogeneous;
  for (int i = 0; i < nboundary; i++) {
    _attribute[clone.i].boundary[i] = _attribute[src.i].boundary[i];
    _attribute[clone.i].boundary_homogeneous[i] = _attribute[src.i].boundary_homogeneous[i];
  }
  _attribute[clone.i].depends = list_copy (_attribute[src.i].depends);
}

scalar * list_clone (scalar * l)
{
  scalar * list = NULL;
  int nvar = datasize/sizeof(real), map[nvar];
  for (int i = 0; i < nvar; i++)
    map[i] = -1;
  {scalar*_i=(scalar*)( l);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    scalar c = _attribute[s.i].block > 1 ? new_block_scalar("c", "", _attribute[s.i].block) : new_scalar("c");
    scalar_clone (c, s);
    map[s.i] = c.i;
    list = list_append (list, c);
  }}}
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    {
      if (_attribute[s.i].v.x.i >= 0 && map[_attribute[s.i].v.x.i] >= 0)
 _attribute[s.i].v.x.i = map[_attribute[s.i].v.x.i];      
#line 385
if (_attribute[s.i].v.y.i >= 0 && map[_attribute[s.i].v.y.i] >= 0)
 _attribute[s.i].v.y.i = map[_attribute[s.i].v.y.i];      
#line 385
if (_attribute[s.i].v.z.i >= 0 && map[_attribute[s.i].v.z.i] >= 0)
 _attribute[s.i].v.z.i = map[_attribute[s.i].v.z.i];}}}
  return list;
}

void delete (scalar * list)
{
  if (all == NULL)
    return;

  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    for (int i = 0; i < _attribute[f.i].block; i++) {
      scalar fb = {f.i + i};
      if (_attribute[f.i].delete)
 _attribute[f.i].delete (fb);
      pfree (_attribute[fb.i].name,__func__,__FILE__,__LINE__); _attribute[fb.i].name = NULL;
      pfree (_attribute[fb.i].boundary,__func__,__FILE__,__LINE__); _attribute[fb.i].boundary = NULL;
      pfree (_attribute[fb.i].boundary_homogeneous,__func__,__FILE__,__LINE__); _attribute[fb.i].boundary_homogeneous = NULL;
      pfree (_attribute[fb.i].depends,__func__,__FILE__,__LINE__); _attribute[fb.i].depends = NULL;
      _attribute[fb.i].freed = true;
    }
  }}}

  if (list == all) {
    all[0].i = -1;
    baseblock[0].i = -1;
    return;
  }

  trash (list);
  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    if (_attribute[f.i].block > 0) {
      scalar * s;
      for (s = all; s->i >= 0 && s->i != f.i; s++);
      if (s->i == f.i) {
 for (; s[_attribute[f.i].block].i >= 0; s++)
   s[0] = s[_attribute[f.i].block];
 s->i = -1;
      }
      for (s = baseblock; s->i >= 0 && s->i != f.i; s++);
      if (s->i == f.i) {
 for (; s[1].i >= 0; s++)
   s[0] = s[1];
 s->i = -1;
      }
    }
  }}}
}

void free_solver()
{
  if (!(_val_higher_dimension == 0.)) qassert ("/home/pwachara/basilisk/src/grid/cartesian-common.h", 436, "_val_higher_dimension == 0.");

  if (free_solver_funcs) {
    free_solver_func * a = (free_solver_func *) free_solver_funcs->p;
    for (int i = 0; i < free_solver_funcs->len/sizeof(free_solver_func); i++)
      a[i] ();
    array_free (free_solver_funcs);
  }

  delete (all);
  pfree (all,__func__,__FILE__,__LINE__); all = NULL;
  pfree (baseblock,__func__,__FILE__,__LINE__); baseblock = NULL;
  for (Event * ev = Events; !ev->last; ev++) {
    Event * e = ev->next;
    while (e) {
      Event * next = e->next;
      pfree (e,__func__,__FILE__,__LINE__);
      e = next;
    }
  }

  pfree (Events,__func__,__FILE__,__LINE__); Events = NULL;
  pfree (_attribute,__func__,__FILE__,__LINE__); _attribute = NULL;
  pfree (_constant,__func__,__FILE__,__LINE__); _constant = NULL;




  free_grid();
  qpclose_all();
#if TRACE
  trace_off();
#endif
#if MTRACE
  pmuntrace();
#endif
#if _CADNA
  cadna_end();
#endif
}



void (* boundary_level) (scalar *, int l);
void (* boundary_face) (vectorl);




void boundary_flux (vector * list) __attribute__ ((deprecated));

void boundary_flux (vector * list)
{
  vectorl list1 = {NULL};
  {vector*_i=(vector*)( list);if(_i)for(vector v=*_i;(&v)->x.i>=0;v=*++_i){
    {
      list1.x = list_append (list1.x, v.x);      list1.y = list_append (list1.y, v.y);      list1.z = list_append (list1.z, v.z);}}}
  boundary_face (list1);
  
    pfree (list1.x,__func__,__FILE__,__LINE__);    pfree (list1.y,__func__,__FILE__,__LINE__);    pfree (list1.z,__func__,__FILE__,__LINE__);
}

static scalar * list_add_depends (scalar * list, scalar s)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
    if (t.i == s.i)
      return list;}}
  scalar * list1 = list;
  {scalar*_i=(scalar*)( _attribute[s.i].depends);if(_i)for(scalar d=*_i;(&d)->i>=0;d=*++_i){
    if (_attribute[d.i].dirty)
      list1 = list_add_depends (list1, d);}}
  return list_append (list1, s);
}

     
void boundary_internal (scalar * list, const char * fname, int line)
{tracing("boundary_internal","/home/pwachara/basilisk/src/grid/cartesian-common.h",511);
  if (list == NULL)
    {end_tracing("boundary_internal","/home/pwachara/basilisk/src/grid/cartesian-common.h",514);return;}
  scalar * listc = NULL;
  vectorl listf = {NULL};
  bool flux = false;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].block > 0) {
      if (scalar_is_dirty (s)) {
 if (_attribute[s.i].face && _attribute[s.i].dirty != 2)
   {
     if (_attribute[s.i].v.x.i == s.i)
       listf.x = list_add (listf.x, s), flux = true;     
#line 523
if (_attribute[s.i].v.y.i == s.i)
       listf.y = list_add (listf.y, s), flux = true;     
#line 523
if (_attribute[s.i].v.z.i == s.i)
       listf.z = list_add (listf.z, s), flux = true;}
 if (!is_constant(cm) && _attribute[cm.i].dirty)
   listc = list_add_depends (listc, cm);
 if (_attribute[s.i].face != 2)
   listc = list_add_depends (listc, s);
      }




    }}}
  if (flux) {
    boundary_face (listf);
    
      pfree (listf.x,__func__,__FILE__,__LINE__);      pfree (listf.y,__func__,__FILE__,__LINE__);      pfree (listf.z,__func__,__FILE__,__LINE__);
  }
  if (listc) {






    boundary_level (listc, -1);
    {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = false;}}
    pfree (listc,__func__,__FILE__,__LINE__);
  }
end_tracing("boundary_internal","/home/pwachara/basilisk/src/grid/cartesian-common.h",552);}

void cartesian_boundary_level (scalar * list, int l)
{
  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, l); };
}

void cartesian_boundary_face (vectorl list)
{
  
    {scalar*_i=(scalar*)( list.x);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}    
#line 562
{scalar*_i=(scalar*)( list.y);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}    
#line 562
{scalar*_i=(scalar*)( list.z);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].dirty = 2;}}
}

static double symmetry (Point point, Point neighbor, scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 568 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
return val(s,0,0,0);
}

static double antisymmetry (Point point, Point neighbor, scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 573 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
return -val(s,0,0,0);
}

BoundaryFunc default_scalar_bc[] = {
  symmetry, symmetry, symmetry, symmetry, symmetry, symmetry
};

scalar cartesian_init_scalar (scalar s, const char * name)
{

  char * pname;
  if (name) {
    pfree (_attribute[s.i].name,__func__,__FILE__,__LINE__);
    pname = pstrdup (name,__func__,__FILE__,__LINE__);
  }
  else
    pname = _attribute[s.i].name;
  int block = _attribute[s.i].block;
  BoundaryFunc * boundary = _attribute[s.i].boundary;
  BoundaryFunc * boundary_homogeneous = _attribute[s.i].boundary_homogeneous;
  _attribute[s.i].name = pname;
  if (block < 0)
    _attribute[s.i].block = block;
  else
    _attribute[s.i].block = block > 0 ? block : 1;

  _attribute[s.i].boundary = boundary ? boundary : (BoundaryFunc *) pmalloc (nboundary*sizeof (BoundaryFunc),__func__,__FILE__,__LINE__);
  _attribute[s.i].boundary_homogeneous = boundary_homogeneous ? boundary_homogeneous :
    (BoundaryFunc *) pmalloc (nboundary*sizeof (BoundaryFunc),__func__,__FILE__,__LINE__);
  for (int b = 0; b < nboundary; b++)
    _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] =
      b < 2*3 ? default_scalar_bc[b] : symmetry;
  _attribute[s.i].gradient = NULL;
   {
    _attribute[s.i].d.x = 0;
    _attribute[s.i].v.x.i = -1;
  } 
#line 606
{
    _attribute[s.i].d.y = 0;
    _attribute[s.i].v.y.i = -1;
  } 
#line 606
{
    _attribute[s.i].d.z = 0;
    _attribute[s.i].v.z.i = -1;
  }
  _attribute[s.i].face = false;
  return s;
}

scalar cartesian_init_vertex_scalar (scalar s, const char * name)
{
  cartesian_init_scalar (s, name);
  
    _attribute[s.i].d.x = -1;    _attribute[s.i].d.y = -1;    _attribute[s.i].d.z = -1;
  for (int d = 0; d < nboundary; d++)
    _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = NULL;
  return s;
}

BoundaryFunc default_vector_bc[] = {
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry
};

vector cartesian_init_vector (vector v, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
   {
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.x);
      cartesian_init_scalar (v.x, cname);
    }
    else
      cartesian_init_scalar (v.x, NULL);
    _attribute[v.x.i].v = v;
  } 
#line 633
{
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.y);
      cartesian_init_scalar (v.y, cname);
    }
    else
      cartesian_init_scalar (v.y, NULL);
    _attribute[v.y.i].v = v;
  } 
#line 633
{
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.z);
      cartesian_init_scalar (v.z, cname);
    }
    else
      cartesian_init_scalar (v.z, NULL);
    _attribute[v.z.i].v = v;
  }

  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] =
      d < 2*3 ? default_vector_bc[d] : antisymmetry;
  return v;
}

vector cartesian_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_vector (v, name);
   {
    _attribute[v.x.i].d.x = -1;
    _attribute[v.x.i].face = true;
  } 
#line 653
{
    _attribute[v.y.i].d.y = -1;
    _attribute[v.y.i].face = true;
  } 
#line 653
{
    _attribute[v.z.i].d.z = -1;
    _attribute[v.z.i].face = true;
  }
  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = NULL;
  return v;
}

tensor cartesian_init_tensor (tensor t, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
   {
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.x);
      cartesian_init_vector (t.x, cname);
    }
    else
      cartesian_init_vector (t.x, NULL);
  } 
#line 665
{
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.y);
      cartesian_init_vector (t.y, cname);
    }
    else
      cartesian_init_vector (t.y, NULL);
  } 
#line 665
{
    if (name) {
      char cname[strlen(name) + 3];
      strcat (strcpy (cname, name), ext.z);
      cartesian_init_vector (t.z, cname);
    }
    else
      cartesian_init_vector (t.z, NULL);
  }
#line 689 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
    if (!(false)) qassert ("/home/pwachara/basilisk/src/grid/cartesian-common.h", 689, "false");

  return t;
}

void output_cells (FILE * fp, coord c, double size)
{ 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 696 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 696 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{
    bool inside = true;
    coord o = {x,y,z};
    
      if (inside && size > 0. &&
   (o.x > c.x + size || o.x < c.x - size))
 inside = false;      
#line 700
if (inside && size > 0. &&
   (o.y > c.y + size || o.y < c.y - size))
 inside = false;      
#line 700
if (inside && size > 0. &&
   (o.z > c.z + size || o.z < c.z - size))
 inside = false;
    if (inside) {
      Delta /= 2.;
#line 715 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
      for (int i = -1; i <= 1; i += 2) {
 fprintf (fp, "%g %g %g\n%g %g %g\n%g %g %g\n%g %g %g\n%g %g %g\n\n",
   x - Delta, y - Delta, z + i*Delta,
   x - Delta, y + Delta, z + i*Delta,
   x + Delta, y + Delta, z + i*Delta,
   x + Delta, y - Delta, z + i*Delta,
   x - Delta, y - Delta, z + i*Delta);
 for (int j = -1; j <= 1; j += 2)
   fprintf (fp, "%g %g %g\n%g %g %g\n\n",
     x + i*Delta, y + j*Delta, z - Delta,
     x + i*Delta, y + j*Delta, z + Delta);
      }

    }
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
  
#line 730 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
fflush (fp);
}
#line 740 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
static char * replace_ (const char * vname)
{
  char * name = pstrdup (vname,__func__,__FILE__,__LINE__), * c = name;
  while (*c != '\0') {
    if (*c == '.')
      *c = '_';
    c++;
  }
  return name;
}

static void debug_plot (FILE * fp, const char * name, const char * cells,
   const char * stencil)
{
  char * vname = replace_ (name);
  fprintf (fp,
    "  load 'debug.plot'\n"
    "  v=%s\n"







    "  splot '%s' w l lc 0, "
    "'%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 1"
           " title columnhead(4+4*v)",

    vname, cells, stencil);
  pfree (vname,__func__,__FILE__,__LINE__);
}

void cartesian_debug (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 775 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
char name[80] = "cells";
  if (pid() > 0)
    sprintf (name, "cells-%d", pid());
  FILE * fp = fopen (name, "w");
  output_cells (fp, (coord){x,y,z}, 4.*Delta);
  fclose (fp);

  char stencil[80] = "stencil";
  if (pid() > 0)
    sprintf (stencil, "stencil-%d", pid());
  fp = fopen (stencil, "w");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){





    fprintf (fp, "x y z %s ", _attribute[v.i].name);}}

  fputc ('\n', fp);
#line 821 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
    for (int k = -2; k <= 2; k++)
      for (int l = -2; l <= 2; l++)
 for (int m = -2; m <= 2; m++) {
   {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){ {
     fprintf (fp, "%g %g %g ",
       x + k*Delta + _attribute[v.i].d.x*Delta/2.,
       y + l*Delta + _attribute[v.i].d.y*Delta/2.,
       z + m*Delta + _attribute[v.i].d.z*Delta/2.);
     if (allocated(k,l,m))
       fprintf (fp, "%g ", val(v,k,l,m));
     else
       fputs ("n/a ", fp);
   }}}
   fputc ('\n', fp);
 }

  fclose (fp);

  fp = fopen ("debug.plot", "w");
  fprintf (fp,
    "set term x11\n"
    "set size ratio -1\n"
    "set key outside\n");
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    char * name = replace_ (_attribute[s.i].name);
    fprintf (fp, "%s = %d\n", name, s.i);
    pfree (name,__func__,__FILE__,__LINE__);
  }}}
  fclose (fp);

  fprintf (ferr, "Last point stencils can be displayed using (in gnuplot)\n");
  debug_plot (ferr, _attribute[0].name, name, stencil);
  fflush (ferr);

  fp = fopen ("plot", "w");
  debug_plot (fp, _attribute[0].name, name, stencil);
  fclose (fp);
}

void cartesian_methods()
{
  init_scalar = cartesian_init_scalar;
  init_vertex_scalar = cartesian_init_vertex_scalar;
  init_vector = cartesian_init_vector;
  init_face_vector = cartesian_init_face_vector;
  init_tensor = cartesian_init_tensor;
  boundary_level = cartesian_boundary_level;
  boundary_face = cartesian_boundary_face;
  scalar_clone = cartesian_scalar_clone;
  debug = cartesian_debug;
}

tensor init_symmetric_tensor (tensor t, const char * name)
{
  return init_tensor (t, name);
}

static double interpolate_linear (Point point, scalar v,
      double xp, double yp, double zp)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 896 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
  x = (xp - x)/Delta - _attribute[v.i].d.x/2.;
  y = (yp - y)/Delta - _attribute[v.i].d.y/2.;
  z = (zp - z)/Delta - _attribute[v.i].d.z/2.;
  int i = ( (int)(x > 0 ? 1 : -1)), j = ( (int)(y > 0 ? 1 : -1)), k = ( (int)(z > 0 ? 1 : -1));
  x = fabs(x); y = fabs(y); z = fabs(z);

  return (((val(v,0,0,0)*(1. - x) + val(v,i,0,0)*x)*(1. - y) +
    (val(v,0,j,0)*(1. - x) + val(v,i,j,0)*x)*y)*(1. - z) +
   ((val(v,0,0,k)*(1. - x) + val(v,i,0,k)*x)*(1. - y) +
    (val(v,0,j,k)*(1. - x) + val(v,i,j,k)*x)*y)*z);

}
#line 878
static void _stencil_interpolate_linear (Point point, scalar v,
_stencil_undefined * xp,_stencil_undefined * yp,_stencil_undefined * zp)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;                              
#line 896 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
        
        
        
  
          

_stencil_val(v,0,0,0);_stencil_val(v, o_stencil,0,0);
_stencil_val(v,0,o_stencil,0); _stencil_val(v,o_stencil,o_stencil,0);
_stencil_val(v,0,0,o_stencil); _stencil_val(v,o_stencil,0,o_stencil);
_stencil_val(v,0,o_stencil,o_stencil); _stencil_val(v,o_stencil,o_stencil,o_stencil);  
#line 902
return           
              
    
    ;

}

     
double interpolate (scalar v, double xp, double yp, double zp,
      bool linear)
{tracing("interpolate","/home/pwachara/basilisk/src/grid/cartesian-common.h",910);
  double val = 1e30f;  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/grid/cartesian-common.h", .line = 914, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 915 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{ _stencil_interpolate_linear (point, v, NULL, NULL, NULL); _stencil_val(v,0,0,0);    }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 13 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    coord _p = { xp, yp, zp };
    Point point = locate (_p.x, _p.y, _p.z);
    if (point.level >= 0)
    
#line 915
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 915 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
val = linear ? interpolate_linear (point, v, xp, yp, zp) : val(v,0,0,0);}  
#line 20
}
}
#line 915
{mpi_all_reduce_array(&val,MPI_DOUBLE,MPI_MIN,1);}
  {end_tracing("interpolate","/home/pwachara/basilisk/src/grid/cartesian-common.h",916);return val;}
end_tracing("interpolate","/home/pwachara/basilisk/src/grid/cartesian-common.h",917);}

     
void interpolate_array (scalar * list, coord * a, int n, double * v,
   bool linear)
{tracing("interpolate_array","/home/pwachara/basilisk/src/grid/cartesian-common.h",920);
  int len = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    len++;}}
  for (int i = 0; i < n; i++) {
    double * w = v;
#line 937 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      *(w++) = 1e30f;}}    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/grid/cartesian-common.h", .line = 939, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 939 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{   
      
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 { _stencil_val(s,0,0,0); _stencil_interpolate_linear (point, s, NULL, NULL, NULL);    }}}
    }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 13 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    coord _p = { (
#line 939
a[i].x
#line 16
), (
#line 939
a[i].y
#line 16
), (
#line 939
a[i].z
#line 16
) };
    Point point = locate (_p.x, _p.y, _p.z);
    if (point.level >= 0) 
#line 939
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 939 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{
      int j = 0;
      {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 v[j++] = !linear ? val(s,0,0,0) : interpolate_linear (point, s, a[i].x, a[i].y, a[i].z);}}
    }}  
#line 20
}
}
#line 943
{mpi_all_reduce_array(v,MPI_DOUBLE,MPI_MIN,len);}

    v = w;
  }
end_tracing("interpolate_array","/home/pwachara/basilisk/src/grid/cartesian-common.h",947);}



typedef int bid;

bid new_bid()
{
  int b = nboundary++;
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].boundary = (BoundaryFunc *) prealloc (_attribute[s.i].boundary, nboundary*sizeof (BoundaryFunc),__func__,__FILE__,__LINE__);
    _attribute[s.i].boundary_homogeneous = (BoundaryFunc *)
      prealloc (_attribute[s.i].boundary_homogeneous, nboundary*sizeof (BoundaryFunc),__func__,__FILE__,__LINE__);
  }}}
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    if (_attribute[s.i].v.x.i < 0)
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] = symmetry;
    else if (_attribute[s.i].v.x.i == s.i) {
      vector v = _attribute[s.i].v;
      
 _attribute[v.y.i].boundary[b] = _attribute[v.y.i].boundary_homogeneous[b] = symmetry; _attribute[v.z.i].boundary[b] = _attribute[v.z.i].boundary_homogeneous[b] = symmetry; _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] = symmetry;
      _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] =
 _attribute[v.x.i].face ? NULL : antisymmetry;
    }
  }}}
  return b;
}



static double periodic_bc (Point point, Point neighbor, scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 979 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
return val(s,0,0,0);
}

static void periodic_boundary (int d)
{

  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (is_vertex_scalar (s))
      _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = NULL;
    else
      _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = periodic_bc;}}

  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (_attribute[s.i].face) {
      vector v = _attribute[s.i].v;
      _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = NULL;
    }}}

  default_scalar_bc[d] = periodic_bc;
  default_vector_bc[d] = periodic_bc;
}

void periodic (int dir)
{





    if (!(dir <= back)) qassert ("/home/pwachara/basilisk/src/grid/cartesian-common.h", 1008, "dir <= back");


  int c = dir/2;
  periodic_boundary (2*c);
  periodic_boundary (2*c + 1);
  (&Period.x)[c] = true;
}


double getvalue (Point point, scalar s, int i, int j, int k)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 1020 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
return val(s,i,j,k);
}

void default_stencil (Point p, scalar * list)
{
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    if (_attribute[s.i].v.x.i != -1) {
      vector v = _attribute[s.i].v;
      {scalar*_i=(scalar*)(((vector[]) {v,{{-1},{-1},{-1}}}));if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){
 _attribute[c.i].input = _attribute[c.i].output = _attribute[c.i].nowarning = true, _attribute[c.i].width = 2;}}
    }
    else
      _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = true, _attribute[s.i].width = 2;
  }}}
}




static void write_stencil_index (int * index)
{
  fprintf (qstderr(), "[%d", index[0]);
  for (int d = 1; d < 3; d++)
    fprintf (qstderr(), ",%d", index[d]);
  fputs ("]", qstderr());
}

void stencil_val (Point p, scalar s, int i, int j, int k,
    const char * file, int line, bool overflow)
{
  if (is_constant(s) || s.i < 0)
    return;
  if (_attribute[s.i].block < 0)
    s.i += _attribute[s.i].block;
  if (!_attribute[s.i].name) {
    fprintf (ferr, "%s:%d: error: trying to access a deleted field\n",
      file, line);
    exit (1);
  }
  int index[] = {i, j, k};
  for (int d = 0; d < 3; d++) {
    if (index[d] == o_stencil)
      index[d] = 2;
    else
      index[d] += (&p.i)[d];
  }
  bool central = true;
  for (int d = 0; d < 3; d++) {
    if (!overflow && (index[d] > 2 || index[d] < - 2)) {
      fprintf (qstderr(), "%s:%d: error: stencil overflow: %s",
        file, line, _attribute[s.i].name);
      write_stencil_index (index);
      fprintf (qstderr(), "\n");
      fflush (qstderr());
      abort();
    }
    if (index[d] != 0)
      central = false;
  }
  if (central) {
    if (!_attribute[s.i].output)
      _attribute[s.i].input = true;
  }
  else {
    _attribute[s.i].input = true;
    int d = 0;
     {
      if ((!_attribute[s.i].face || _attribute[s.i].v.x.i != s.i) && abs(index[d]) > _attribute[s.i].width)
 _attribute[s.i].width = abs(index[d]);
      d++;
    } 
#line 1086
{
      if ((!_attribute[s.i].face || _attribute[s.i].v.y.i != s.i) && abs(index[d]) > _attribute[s.i].width)
 _attribute[s.i].width = abs(index[d]);
      d++;
    } 
#line 1086
{
      if ((!_attribute[s.i].face || _attribute[s.i].v.z.i != s.i) && abs(index[d]) > _attribute[s.i].width)
 _attribute[s.i].width = abs(index[d]);
      d++;
    }
  }
}

void stencil_val_a (Point p, scalar s, int i, int j, int k, bool input,
      const char * file, int line)
{
  if (is_constant(s) || s.i < 0) {
    fprintf (ferr, "%s:%d: error: trying to modify a%s field\n",
      file, line, s.i < 0 ? "n undefined" : " constant");
    exit (1);
  }
  if (_attribute[s.i].block < 0)
    s.i += _attribute[s.i].block;
  if (!_attribute[s.i].name) {
    fprintf (ferr, "%s:%d: error: trying to access a deleted field\n",
      file, line);
    exit (1);
  }
  int index[] = {i, j, k};
  for (int d = 0; d < 3; d++)
    index[d] += (&p.i)[d];
  for (int d = 0; d < 3; d++)
    if (index[d] != 0) {
      fprintf (qstderr(), "%s:%d: error: illegal write: %s",
        file, line, _attribute[s.i].name);
      write_stencil_index (index);
      fprintf (qstderr(), "\n");
      fflush (qstderr());
      abort();
    }
  if (input && !_attribute[s.i].output)
    _attribute[s.i].input = true;
  _attribute[s.i].output = true;
} 
#line 5 "/home/pwachara/basilisk/src/grid/multigrid-common.h"

void macro_foreach_level_or_leaf (int l, char flags, Reduce reductions)
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 9 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 9 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
;}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
} 

void macro_foreach_coarse_level (int l, char flags, Reduce reductions)
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 15 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 15 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
;}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 16 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}










void (* restriction) (scalar *);

static inline void restriction_average (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 31 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
double sum = 0.;
  
  
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;    
#line 33 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
sum += val(s,0,0,0);
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }  
#line 34 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = sum/(1 << 3);
}
#line 29
static void _stencil_restriction_average (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
     
  
  
#line 408
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;    
#line 33 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(s,0,0,0); }
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }  
#line 34 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
_stencil_val_a(s,0,0,0);    
}

static inline void restriction_volume_average (Point point, scalar s)
{if(!is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 39 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
double sum = 0.;
  
  
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;    
#line 41 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
sum += val(cm,0,0,0)*val(s,0,0,0);
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }  
#line 42 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = sum/(1 << 3)/(val(cm,0,0,0) + 1e-30);
}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
#line 38
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 39 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
double sum = 0.;
  
  
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;    
#line 41 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
sum += _const_cm*val(s,0,0,0);
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }  
#line 42 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = sum/(1 << 3)/(_const_cm + 1e-30);
}}}

static inline void face_average (Point point, vector v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 47 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{







      val(v.x,0,0,0) = (fine(v.x,0,0,0) + fine(v.x,0,1,0) +
        fine(v.x,0,0,1) + fine(v.x,0,1,1))/4.;
      val(v.x,1,0,0) = (fine(v.x,2,0,0) + fine(v.x,2,1,0) +
  fine(v.x,2,0,1) + fine(v.x,2,1,1))/4.;

  } 
#line 47
{







      val(v.y,0,0,0) = (fine(v.y,0,0,0) + fine(v.y,0,0,1) +
        fine(v.y,1,0,0) + fine(v.y,1,0,1))/4.;
      val(v.y,0,1,0) = (fine(v.y,0,2,0) + fine(v.y,0,2,1) +
  fine(v.y,1,2,0) + fine(v.y,1,2,1))/4.;

  } 
#line 47
{







      val(v.z,0,0,0) = (fine(v.z,0,0,0) + fine(v.z,1,0,0) +
        fine(v.z,0,1,0) + fine(v.z,1,1,0))/4.;
      val(v.z,0,0,1) = (fine(v.z,0,0,2) + fine(v.z,1,0,2) +
  fine(v.z,0,1,2) + fine(v.z,1,1,2))/4.;

  }
}

static inline void restriction_face (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 65 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
face_average (point, _attribute[s.i].v);
}

static inline void restriction_vertex (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 70 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
for (int i = 0; i <= 1; i++) {
    val(s,i,0,0) = fine(s,2*i,0,0);

    val(s,i,1,0) = fine(s,2*i,2,0);


    for (int j = 0; j <= 1; j++)
      val(s,i,j,1) = fine(s,2*i,2*j,2);

  }
}

static inline void no_restriction (Point point, scalar s) {}

static inline void no_data (Point point, scalar s) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
  
#line 408
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;    
#line 86 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = 1e30f;
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }
#line 87 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}

void wavelet (scalar s, scalar w)
{
  restriction (((scalar[]){s,{-1}}));
  for (int l = grid->maxdepth - 1; l >= 0; l--) {
  
  
    
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 93 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
  
      
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;        
#line 95 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(s,0,0,0);_stencil_val_a(w,0,0,0); }
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }
#line 96 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
default_stencil (      point,((scalar[]){ s,{-1}}));
  
      
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
#line 97 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
         _stencil_val(s,0,0,0); 
_stencil_val(w,0,0,0);        _stencil_val_a(s,0,0,0); 

        _stencil_val_r(w,0,0,0);  
      }
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }    
#line 103 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 13 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 93 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 93 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
  
      
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;        
#line 95 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(w,0,0,0) = val(s,0,0,0);
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }      
#line 96 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
_attribute[s.i].prolongation (point, s);
  
      
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
#line 97 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
        double sp = val(s,0,0,0);
        val(s,0,0,0) = val(w,0,0,0);

        val(w,0,0,0) -= sp;
      }
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }    
#line 103 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 16 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
    
#line 104
boundary_level (((scalar[]){w,{-1}}), l + 1);
  }
  

  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 108 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(s,0,0,0);_stencil_val_a(w,0,0,0); }
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
} 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = 0;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 108 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 108 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(w,0,0,0) = val(s,0,0,0);}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 109 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
boundary_level (((scalar[]){w,{-1}}), 0);
}

void inverse_wavelet (scalar s, scalar w)
{
  
  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 115 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(w,0,0,0);_stencil_val_a(s,0,0,0); }
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
} 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = 0;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 115 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 115 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = val(w,0,0,0);}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 116 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
boundary_level (((scalar[]){s,{-1}}), 0);
  for (int l = 0; l <= grid->maxdepth - 1; l++) {
  
  
    
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 118 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
default_stencil (      point,((scalar[]){ s,{-1}}));
  
      
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;        
#line 121 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(w,0,0,0);_stencil_val_r(s,0,0,0); }
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }    
#line 122 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 13 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 118 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 118 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
      _attribute[s.i].prolongation (point, s);
  
      
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;        
#line 121 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) += val(w,0,0,0);
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }    
#line 122 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 16 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
    
#line 123
boundary_level (((scalar[]){s,{-1}}), l + 1);
  }
}

static inline double bilinear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;    
#line 136 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
return (27.*coarse(s,0,0,0) +
     9.*(coarse(s,child.x,0,0) + coarse(s,0,child.y,0) +
  coarse(s,0,0,child.z)) +
     3.*(coarse(s,child.x,child.y,0) + coarse(s,child.x,0,child.z) +
  coarse(s,0,child.y,child.z)) +
     coarse(s,child.x,child.y,child.z))/64.;

}
#line 127
static void _stencil_bilinear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 136 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
_stencil_coarse(s,0,0,0);
_stencil_coarse(s,o_stencil,0,0); _stencil_coarse(s,0,o_stencil,0);
  _stencil_coarse(s,0,0,o_stencil);
_stencil_coarse(s,o_stencil,o_stencil,0); _stencil_coarse(s,o_stencil,0,o_stencil);
  _stencil_coarse(s,0,o_stencil,o_stencil);
     _stencil_coarse(s,o_stencil,o_stencil,o_stencil);    
#line 136
return 
        
         


;

}

static inline void refine_bilinear (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
  
#line 408
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;    
#line 148 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = bilinear (point, s);
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }
#line 149 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}

static inline double quadratic (double a, double b, double c)
{
  return (30.*a + 5.*b - 3.*c)/32.;
}

static inline double biquadratic (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 172 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
  if (!(false)) qassert ("/home/pwachara/basilisk/src/grid/multigrid-common.h", 172, "false");
  return 0.;

}

static inline double biquadratic_vertex (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 185 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
if (!(false)) qassert ("/home/pwachara/basilisk/src/grid/multigrid-common.h", 185, "false");
  return 0.;

}

static inline void refine_biquadratic (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
  
#line 408
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;    
#line 193 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(s,0,0,0) = biquadratic (point, s);
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }
#line 194 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}

static inline void refine_linear (Point point, scalar s)
{if(!is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 198 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
coord g;
  if (_attribute[s.i].gradient)
    {
      g.x = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0));      g.y = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0));      g.z = _attribute[s.i].gradient (val(s,0,0,-1), val(s,0,0,0), val(s,0,0,1));}
  else
    {
      g.x = (val(s,1,0,0) - val(s,-1,0,0))/2.;      g.y = (val(s,0,1,0) - val(s,0,-1,0))/2.;      g.z = (val(s,0,0,1) - val(s,0,0,-1))/2.;}

  double sc = val(s,0,0,0), cmc = 4.*val(cm,0,0,0), sum = val(cm,0,0,0)*(1 << 3);
  
  
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
#line 207 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
    val(s,0,0,0) = sc;
    
      val(s,0,0,0) += child.x*g.x*val(cm,-child.x,0,0)/cmc;      val(s,0,0,0) += child.y*g.y*val(cm,0,-child.y,0)/cmc;      val(s,0,0,0) += child.z*g.z*val(cm,0,0,-child.z)/cmc;
    sum -= val(cm,0,0,0);
  }
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }  
#line 213 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
if (!(fabs(sum) < 1e-10)) qassert ("/home/pwachara/basilisk/src/grid/multigrid-common.h", 213, "fabs(sum) < 1e-10");
}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
#line 197
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 198 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
coord g;
  if (_attribute[s.i].gradient)
    {
      g.x = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0));      g.y = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0));      g.z = _attribute[s.i].gradient (val(s,0,0,-1), val(s,0,0,0), val(s,0,0,1));}
  else
    {
      g.x = (val(s,1,0,0) - val(s,-1,0,0))/2.;      g.y = (val(s,0,1,0) - val(s,0,-1,0))/2.;      g.z = (val(s,0,0,1) - val(s,0,0,-1))/2.;}

  double sc = val(s,0,0,0), cmc = 4.*_const_cm, sum = _const_cm*(1 << 3);
  
  
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
#line 207 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
    val(s,0,0,0) = sc;
    
      val(s,0,0,0) += child.x*g.x*_const_cm/cmc;      val(s,0,0,0) += child.y*g.y*_const_cm/cmc;      val(s,0,0,0) += child.z*g.z*_const_cm/cmc;
    sum -= _const_cm;
  }
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }  
#line 213 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
if (!(fabs(sum) < 1e-10)) qassert ("/home/pwachara/basilisk/src/grid/multigrid-common.h", 213, "fabs(sum) < 1e-10");
}}}

static inline void refine_reset (Point point, scalar v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
  
#line 408
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
    
#line 219 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(v,0,0,0) = 0.;
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }
#line 220 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}

static inline void refine_injection (Point point, scalar v)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 224 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
double val = val(v,0,0,0);
  
  
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
    
#line 226 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(v,0,0,0) = val;
 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }
#line 227 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}

static scalar multigrid_init_scalar (scalar s, const char * name)
{
  s = cartesian_init_scalar (s, name);
  _attribute[s.i].prolongation = refine_bilinear;
  _attribute[s.i].restriction = restriction_average;
  return s;
}

static scalar multigrid_init_vertex_scalar (scalar s, const char * name)
{
  s = cartesian_init_vertex_scalar (s, name);
  _attribute[s.i].restriction = restriction_vertex;
  return s;
}

static void multigrid_setup_vector (vector v)
{
   {
    _attribute[v.x.i].prolongation = refine_bilinear;
    _attribute[v.x.i].restriction = restriction_average;
  } 
#line 246
{
    _attribute[v.y.i].prolongation = refine_bilinear;
    _attribute[v.y.i].restriction = restriction_average;
  } 
#line 246
{
    _attribute[v.z.i].prolongation = refine_bilinear;
    _attribute[v.z.i].restriction = restriction_average;
  }
}

static vector multigrid_init_vector (vector v, const char * name)
{
  v = cartesian_init_vector (v, name);
  multigrid_setup_vector (v);
  return v;
}

static vector multigrid_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);
  
    _attribute[v.y.i].restriction = no_restriction;    _attribute[v.z.i].restriction = no_restriction;    _attribute[v.x.i].restriction = no_restriction;
  _attribute[v.x.i].restriction = restriction_face;
  return v;
}

static tensor multigrid_init_tensor (tensor t, const char * name)
{
  t = cartesian_init_tensor (t, name);
  
    multigrid_setup_vector (t.x);    multigrid_setup_vector (t.y);    multigrid_setup_vector (t.z);
  return t;
}

void multigrid_debug (Point point)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 278 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
cartesian_debug (point);

  FILE * plot = fopen ("plot", "a");
  if (point.level > 0) {
    char name[80] = "coarse";
    if (pid() > 0)
      sprintf (name, "coarse-%d", pid());
    FILE * fp = fopen (name, "w");
#line 310 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
      double xc = x - child.x*Delta/2., yc = y - child.y*Delta/2.;
      double zc = z - child.z*Delta/2.;
      for (int k = 0; k <= 1; k++)
 for (int l = 0; l <= 1; l++)
   for (int m = 0; m <= 1; m++) {
     {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){
       fprintf (fp, "%g %g %g %g ",
         xc + k*child.x*Delta*2. + _attribute[v.i].d.x*Delta,
         yc + l*child.y*Delta*2. + _attribute[v.i].d.y*Delta,
         zc + m*child.z*Delta*2. + _attribute[v.i].d.z*Delta,
         coarse(v,k*child.x,l*child.y,m*child.z));}}
     fputc ('\n', fp);
   }
      fprintf (ferr, ", '%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 3 t ''",
        name);
      fprintf (plot, ", '%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 3 t ''",
        name);

    fclose (fp);
  }

  if (is_coarse()) {
    char name[80] = "fine";
    if (pid() > 0)
      sprintf (name, "fine-%d", pid());
    FILE * fp = fopen (name, "w");
#line 367 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
      double xf = x - Delta/4., yf = y - Delta/4., zf = z - Delta/4.;
      for (int k = -2; k <= 3; k++)
 for (int l = -2; l <= 3; l++)
   for (int m = -2; m <= 3; m++) {
     {scalar*_i=(scalar*)( all);if(_i)for(scalar v=*_i;(&v)->i>=0;v=*++_i){ {
       fprintf (fp, "%g %g %g ",
         xf + k*Delta/2. + _attribute[v.i].d.x*Delta/4.,
         yf + l*Delta/2. + _attribute[v.i].d.y*Delta/4.,
         zf + m*Delta/2. + _attribute[v.i].d.z*Delta/4.);
       if (allocated_child(k,l,m))
  fprintf (fp, "%g ", fine(v,k,l,m));
       else
  fputs ("n/a ", fp);
     }}}
     fputc ('\n', fp);
   }
      fprintf (ferr, ", '%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 2 t ''",
        name);
      fprintf (plot, ", '%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 2 t ''",
        name);

    fclose (fp);
  }
  fflush (ferr);
  fclose (plot);
}

static void multigrid_restriction (scalar * list)
{
  scalar * listdef = NULL, * listc = NULL, * list2 = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant (s) && _attribute[s.i].block > 0) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
     list2 = list_add (list2, _attribute[s.i].v.x);     list2 = list_add (list2, _attribute[s.i].v.y);     list2 = list_add (list2, _attribute[s.i].v.z);}
 else
   list2 = list_add (list2, s);
      }
    }}}

  if (listdef || listc) {
    for (int l = depth() - 1; l >= 0; l--) {      
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 415 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     _stencil_restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {

default_stencil (     point,((scalar[]){ s,{-1}}));
 }}}
      }  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 13 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 415 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 415 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
 {scalar*_i=(scalar*)( listdef);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     restriction_average (point, s);}}
 {scalar*_i=(scalar*)( listc);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
  
     _attribute[s.i].restriction (point, s);
 }}}
      }}    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 16 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
      
#line 424
{ Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list2, l); };
    }
    pfree (listdef,__func__,__FILE__,__LINE__);
    pfree (listc,__func__,__FILE__,__LINE__);
    pfree (list2,__func__,__FILE__,__LINE__);
  }
}

void multigrid_methods()
{
  cartesian_methods();
  init_scalar = multigrid_init_scalar;
  init_vertex_scalar = multigrid_init_vertex_scalar;
  init_vector = multigrid_init_vector;
  init_face_vector = multigrid_init_face_vector;
  init_tensor = multigrid_init_tensor;
  restriction = multigrid_restriction;
  debug = multigrid_debug;
}







void subtree_size (scalar size, bool leaves)
{  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/grid/multigrid-common.h", .line = 456, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 457 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{_stencil_val_a(size,0,0,0);  }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 457 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 457 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(size,0,0,0) = 1;}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}





  
#line 463 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b,((scalar[]) {size,{-1}}), depth()); };
  for (int l = depth() - 1; l >= 0; l--) {    
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 465 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{      
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
 
#line 468 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ _stencil_val(size,0,0,0); } 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }
      
#line 469 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
_stencil_val_a(size,0,0,0);  
    }  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 13 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 465 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 465 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{
      double sum = !leaves;      
#line 408 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    int _i = 2*point.i - 2;
    int _j = 2*point.j - 2;
    int _k = 2*point.k - 2;
    point.level++;
    point.n.x *= 2, point.n.y *= 2, point.n.z *= 2;
    for (int _l = 0; _l < 2; _l++)
      for (int _m = 0; _m < 2; _m++)
 for (int _n = 0; _n < 2; _n++) {
   point.i = _i + _l; point.j = _j + _m; point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
 
#line 468 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
sum += val(size,0,0,0); 
#line 420 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
    point.i = (_i + 2)/2;
    point.j = (_j + 2)/2;
    point.k = (_k + 2)/2;
    point.level--;
    point.n.x /= 2, point.n.y /= 2, point.n.z /= 2;
  }
      
#line 469 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
val(size,0,0,0) = sum;
    }}    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 16 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
    
#line 471
{ Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b,((scalar[]) {size,{-1}}), l); };
  }
}
#line 910 "/home/pwachara/basilisk/src/grid/multigrid.h"


void macro_foreach_vertex (char flags, Reduce reductions) {
#line 300
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 913
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 913
{
    int ig = -1; NOT_UNUSED(ig);

    int jg = -1; NOT_UNUSED(jg);


    int kg = -1; NOT_UNUSED(kg);

    ;
  }}      
#line 317
}
  }
}

#line 923
}


void macro_foreach_edge (char flags, Reduce reductions) { 
#line 912
{
#line 300
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 913
{
    int ig = -1; NOT_UNUSED(ig);

    int jg = -1; NOT_UNUSED(jg);


    int kg = -1; NOT_UNUSED(kg); 







{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 927
{
    struct { int x, y, z; } _a = {point.i, point.j, point.k};
    
      if (_a.x < point.n.x + 2)
 ;      
#line 930
if (_a.y < point.n.y + 2)
 ;      
#line 930
if (_a.z < point.n.z + 2)
 ;
  }}  
#line 922
}      
#line 317
}
  }
}

#line 923
}









}


ivec dimensions (int nx, int ny, int nz)
{
  if (nx != 0 || ny != 0 || nz != 0) {
    Dimensions.x = Dimensions_scale = ( nx > 1 ? nx : 1);

    Dimensions.y = ( ny > 1 ? ny : 1);


    Dimensions.z = ( nz > 1 ? nz : 1);

  }
  return Dimensions;
}


#line 1 "grid/multigrid-mpi.h"
#line 1 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
#line 41 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
void macro_foreach_slice_x (int start, int end, int l) {
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l; point.n.x = point.n.y = point.n.z = 1 << point.level;
    for (point.i = start; point.i < end; point.i++)
      for (point.j = 0; point.j < point.n.y + 2*2; point.j++)
 for (point.k = 0; point.k < point.n.z + 2*2; point.k++)
   ;
  }
}

void macro_foreach_slice_y (int start, int end, int l) {
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l; point.n.x = point.n.y = point.n.z = 1 << point.level;
    for (point.i = 0; point.i < point.n.x + 2*2; point.i++)
      for (point.j = start; point.j < end; point.j++)
 for (point.k = 0; point.k < point.n.z + 2*2; point.k++)
   ;
  }
}

void macro_foreach_slice_z (int start, int end, int l) {
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l; point.n.x = point.n.y = point.n.z = 1 << point.level;
    for (point.i = 0; point.i < point.n.x + 2*2; point.i++)
      for (point.j = 0; point.j < point.n.y + 2*2; point.j++)
 for (point.k = start; point.k < end; point.k++)
   ;
  }
}



typedef struct {
  Boundary b;
  MPI_Comm cartcomm;
} MpiBoundary;


static void * snd_x (int i, int dst, int tag, int level, scalar * list,
       MPI_Request * req)
{
  if (dst == MPI_PROC_NULL)
    return NULL;
  size_t size = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    size += _attribute[s.i].block;}}
  size *= pow((1 << level) + 2*2, 3 - 1)*2*sizeof(real);
  double * buf = (double *) pmalloc (size,__func__,__FILE__,__LINE__), * b = buf; 
#line 41
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = level; point.n.x = point.n.y = point.n.z = 1 << point.level;
    for (point.i = i; point.i < (
#line 95
i + 2
#line 46
); point.i++)
      for (point.j = 0; point.j < point.n.y + 2*2; point.j++)
 for (point.k = 0; point.k < point.n.z + 2*2; point.k++)
    
#line 96
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 96 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      for (scalar sb = s; sb.i < s.i + _attribute[s.i].block; sb.i++, b++)
 memcpy (b, &val(sb,0,0,0), sizeof(real));}}}  
#line 50
}
}
  
#line 99
MPI_Isend (buf, size, MPI_BYTE, dst, tag, MPI_COMM_WORLD, req);
  return buf;
}
#line 85
static void * snd_y (int i, int dst, int tag, int level, scalar * list,
       MPI_Request * req)
{
  if (dst == MPI_PROC_NULL)
    return NULL;
  size_t size = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    size += _attribute[s.i].block;}}
  size *= pow((1 << level) + 2*2, 3 - 1)*2*sizeof(real);
  double * buf = (double *) pmalloc (size,__func__,__FILE__,__LINE__), * b = buf; 
#line 53
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = level; point.n.x = point.n.y = point.n.z = 1 << point.level;
    for (point.i = 0; point.i < point.n.x + 2*2; point.i++)
      for (point.j = i; point.j < (
#line 95
i + 2
#line 59
); point.j++)
 for (point.k = 0; point.k < point.n.z + 2*2; point.k++)
    
#line 96
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 96 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      for (scalar sb = s; sb.i < s.i + _attribute[s.i].block; sb.i++, b++)
 memcpy (b, &val(sb,0,0,0), sizeof(real));}}}  
#line 62
}
}
  
#line 99
MPI_Isend (buf, size, MPI_BYTE, dst, tag, MPI_COMM_WORLD, req);
  return buf;
}
#line 85
static void * snd_z (int i, int dst, int tag, int level, scalar * list,
       MPI_Request * req)
{
  if (dst == MPI_PROC_NULL)
    return NULL;
  size_t size = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    size += _attribute[s.i].block;}}
  size *= pow((1 << level) + 2*2, 3 - 1)*2*sizeof(real);
  double * buf = (double *) pmalloc (size,__func__,__FILE__,__LINE__), * b = buf; 
#line 65
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = level; point.n.x = point.n.y = point.n.z = 1 << point.level;
    for (point.i = 0; point.i < point.n.x + 2*2; point.i++)
      for (point.j = 0; point.j < point.n.y + 2*2; point.j++)
 for (point.k = i; point.k < (
#line 95
i + 2
#line 72
); point.k++)
    
#line 96
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 96 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      for (scalar sb = s; sb.i < s.i + _attribute[s.i].block; sb.i++, b++)
 memcpy (b, &val(sb,0,0,0), sizeof(real));}}}  
#line 74
}
}
  
#line 99
MPI_Isend (buf, size, MPI_BYTE, dst, tag, MPI_COMM_WORLD, req);
  return buf;
}


static void rcv_x (int i, int src, int tag, int level, scalar * list)
{
  if (src == MPI_PROC_NULL)
    return;
  size_t size = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    size += _attribute[s.i].block;}}
  size *= pow((1 << level) + 2*2, 3 - 1)*2*sizeof(real);
  double * buf = (double *) pmalloc (size,__func__,__FILE__,__LINE__), * b = buf;
  MPI_Status s;
  MPI_Recv (buf, size, MPI_BYTE, src, tag, MPI_COMM_WORLD, &s); 
#line 41
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = level; point.n.x = point.n.y = point.n.z = 1 << point.level;
    for (point.i = i; point.i < (
#line 115
i + 2
#line 46
); point.i++)
      for (point.j = 0; point.j < point.n.y + 2*2; point.j++)
 for (point.k = 0; point.k < point.n.z + 2*2; point.k++)
    
#line 116
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 116 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      for (scalar sb = s; sb.i < s.i + _attribute[s.i].block; sb.i++, b++)
 memcpy (&val(sb,0,0,0), b, sizeof(real));}}}  
#line 50
}
}
  
#line 119
pfree (buf,__func__,__FILE__,__LINE__);
}
#line 104
static void rcv_y (int i, int src, int tag, int level, scalar * list)
{
  if (src == MPI_PROC_NULL)
    return;
  size_t size = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    size += _attribute[s.i].block;}}
  size *= pow((1 << level) + 2*2, 3 - 1)*2*sizeof(real);
  double * buf = (double *) pmalloc (size,__func__,__FILE__,__LINE__), * b = buf;
  MPI_Status s;
  MPI_Recv (buf, size, MPI_BYTE, src, tag, MPI_COMM_WORLD, &s); 
#line 53
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = level; point.n.x = point.n.y = point.n.z = 1 << point.level;
    for (point.i = 0; point.i < point.n.x + 2*2; point.i++)
      for (point.j = i; point.j < (
#line 115
i + 2
#line 59
); point.j++)
 for (point.k = 0; point.k < point.n.z + 2*2; point.k++)
    
#line 116
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 116 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      for (scalar sb = s; sb.i < s.i + _attribute[s.i].block; sb.i++, b++)
 memcpy (&val(sb,0,0,0), b, sizeof(real));}}}  
#line 62
}
}
  
#line 119
pfree (buf,__func__,__FILE__,__LINE__);
}
#line 104
static void rcv_z (int i, int src, int tag, int level, scalar * list)
{
  if (src == MPI_PROC_NULL)
    return;
  size_t size = 0;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    size += _attribute[s.i].block;}}
  size *= pow((1 << level) + 2*2, 3 - 1)*2*sizeof(real);
  double * buf = (double *) pmalloc (size,__func__,__FILE__,__LINE__), * b = buf;
  MPI_Status s;
  MPI_Recv (buf, size, MPI_BYTE, src, tag, MPI_COMM_WORLD, &s); 
#line 65
{
  {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = level; point.n.x = point.n.y = point.n.z = 1 << point.level;
    for (point.i = 0; point.i < point.n.x + 2*2; point.i++)
      for (point.j = 0; point.j < point.n.y + 2*2; point.j++)
 for (point.k = i; point.k < (
#line 115
i + 2
#line 72
); point.k++)
    
#line 116
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 116 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      for (scalar sb = s; sb.i < s.i + _attribute[s.i].block; sb.i++, b++)
 memcpy (&val(sb,0,0,0), b, sizeof(real));}}}  
#line 74
}
}
  
#line 119
pfree (buf,__func__,__FILE__,__LINE__);
}

     
static void mpi_boundary_level (const Boundary * b, scalar * list, int level)
{tracing("mpi_boundary_level","/home/pwachara/basilisk/src/grid/multigrid-mpi.h",123);
  scalar * list1 = NULL;
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s) && _attribute[s.i].block > 0)
      list1 = list_add (list1, s);}}
  if (!list1)
    {end_tracing("mpi_boundary_level","/home/pwachara/basilisk/src/grid/multigrid-mpi.h",130);return;}

  prof_start ("mpi_boundary_level");

  if (level < 0) level = depth();
  MpiBoundary * mpi = (MpiBoundary *) b;
  struct { int x, y, z; } dir = {0,1,2};
   {
    int left, right;
    MPI_Cart_shift (mpi->cartcomm, dir.x, 1, &left, &right);
    MPI_Request reqs[2];
    void * buf[2];
    int npl = (1 << level) + 2*2, nr = 0;
    if ((buf[0] = snd_x (npl - 2*2, right, 0, level, list1, &reqs[nr])))
      nr++;
    if ((buf[1] = snd_x (2, left, 1, level, list1, &reqs[nr])))
      nr++;
    rcv_x (0, left, 0, level, list1);
    rcv_x (npl - 2, right, 1, level, list1);
    MPI_Status stats[nr];
    MPI_Waitall (nr, reqs, stats);
    pfree (buf[0],__func__,__FILE__,__LINE__); pfree (buf[1],__func__,__FILE__,__LINE__);
  } 
#line 137
{
    int bottom, top;
    MPI_Cart_shift (mpi->cartcomm, dir.y, 1, &bottom, &top);
    MPI_Request reqs[2];
    void * buf[2];
    int npl = (1 << level) + 2*2, nr = 0;
    if ((buf[0] = snd_y (npl - 2*2, top, 0, level, list1, &reqs[nr])))
      nr++;
    if ((buf[1] = snd_y (2, bottom, 1, level, list1, &reqs[nr])))
      nr++;
    rcv_y (0, bottom, 0, level, list1);
    rcv_y (npl - 2, top, 1, level, list1);
    MPI_Status stats[nr];
    MPI_Waitall (nr, reqs, stats);
    pfree (buf[0],__func__,__FILE__,__LINE__); pfree (buf[1],__func__,__FILE__,__LINE__);
  } 
#line 137
{
    int back, front;
    MPI_Cart_shift (mpi->cartcomm, dir.z, 1, &back, &front);
    MPI_Request reqs[2];
    void * buf[2];
    int npl = (1 << level) + 2*2, nr = 0;
    if ((buf[0] = snd_z (npl - 2*2, front, 0, level, list1, &reqs[nr])))
      nr++;
    if ((buf[1] = snd_z (2, back, 1, level, list1, &reqs[nr])))
      nr++;
    rcv_z (0, back, 0, level, list1);
    rcv_z (npl - 2, front, 1, level, list1);
    MPI_Status stats[nr];
    MPI_Waitall (nr, reqs, stats);
    pfree (buf[0],__func__,__FILE__,__LINE__); pfree (buf[1],__func__,__FILE__,__LINE__);
  }

  pfree (list1,__func__,__FILE__,__LINE__);

  prof_stop();
end_tracing("mpi_boundary_level","/home/pwachara/basilisk/src/grid/multigrid-mpi.h",157);}

static void mpi_boundary_destroy (Boundary * b)
{
  MpiBoundary * m = (MpiBoundary *) b;
  MPI_Comm_free (&m->cartcomm);
  pfree (m,__func__,__FILE__,__LINE__);
}

static void mpi_dimensions_error (int n)
{
  fprintf (ferr,
    "%s:%d: error: the number of MPI processes must be equal to ",
    "/home/pwachara/basilisk/src/grid/multigrid-mpi.h", 170);
  if (n > 1)
    fprintf (ferr, "%dx", n);
  fprintf (ferr, "%d^i\n", 1 << 3);
  exit (1);
}

Boundary * mpi_boundary_new()
{
  MpiBoundary * m = ((MpiBoundary *) pcalloc (1, sizeof(MpiBoundary),__func__,__FILE__,__LINE__));
  int n = 1;
  
    n *= Dimensions.x;    n *= Dimensions.y;    n *= Dimensions.z;
  if (npe() % n)
    mpi_dimensions_error (n);
  int j = npe()/n, i = 0;
  while (j > 1) {
    if (j % (1 << 3))
      mpi_dimensions_error (n);
    j /= 1 << 3;
    i++;
  }
  
    Dimensions.x *= 1 << i;    Dimensions.y *= 1 << i;    Dimensions.z *= 1 << i;
  MPI_Dims_create (npe(), 3, &Dimensions.x);
  MPI_Cart_create (MPI_COMM_WORLD, 3,
     &Dimensions.x, &Period.x, 0, &m->cartcomm);
  MPI_Cart_coords (m->cartcomm, pid(), 3, mpi_coords);


  struct { int x, y, z; } dir = {0,1,2};
   {
    int l, r;
    MPI_Cart_shift (m->cartcomm, dir.x, 1, &l, &r);
    if (l != MPI_PROC_NULL)
      periodic_boundary (left);
    if (r != MPI_PROC_NULL)
      periodic_boundary (right);
  } 
#line 201
{
    int l, r;
    MPI_Cart_shift (m->cartcomm, dir.y, 1, &l, &r);
    if (l != MPI_PROC_NULL)
      periodic_boundary (bottom);
    if (r != MPI_PROC_NULL)
      periodic_boundary (top);
  } 
#line 201
{
    int l, r;
    MPI_Cart_shift (m->cartcomm, dir.z, 1, &l, &r);
    if (l != MPI_PROC_NULL)
      periodic_boundary (back);
    if (r != MPI_PROC_NULL)
      periodic_boundary (front);
  }


  Dimensions_scale = Dimensions.x;
  N /= Dimensions.x;
  int r = 0;
  while (N > 1)
    N /= 2, r++;
  grid->depth = grid->maxdepth = r;
  N = Dimensions.x*(1 << r);
  grid->n = 1 << 3*depth();
  grid->tn = npe()*grid->n;


  Boundary * b = (Boundary *) m;
  b->level = mpi_boundary_level;
  b->destroy = mpi_boundary_destroy;
  add_boundary (b);

  return b;
}

     
double z_indexing (scalar index, bool leaves)
{tracing("z_indexing","/home/pwachara/basilisk/src/grid/multigrid-mpi.h",231);
  long i;
  if (leaves)
    i = pid()*(1 << 3*depth());
  else
    i = pid()*((1 << 3*(depth() + 1)) - 1)/((1 << 3) - 1);
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 238 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 238 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
{
    if (!leaves || is_leaf(cell))
      val(index,0,0,0) = i++;
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}
  
#line 244 "/home/pwachara/basilisk/src/grid/multigrid-mpi.h"
boundary_internal ((scalar *)((scalar[]){index,{-1}}), "/home/pwachara/basilisk/src/grid/multigrid-mpi.h", 244);
  { double _ret= pid() == 0 ? i*npe() - 1 : -1;end_tracing("z_indexing","/home/pwachara/basilisk/src/grid/multigrid-mpi.h",245);return _ret;}
end_tracing("z_indexing","/home/pwachara/basilisk/src/grid/multigrid-mpi.h",246);}
#line 952 "/home/pwachara/basilisk/src/grid/multigrid.h"
#line 3 "/home/pwachara/basilisk/src/grid/multigrid3D.h"

void multigrid3D_methods() {
  multigrid_methods();
}
#line 2 "CubicTest.c"
#line 1 "embed.h"
#line 1 "/home/pwachara/basilisk/src/embed.h"
#line 12 "/home/pwachara/basilisk/src/embed.h"
#line 1 "fractions.h"
#line 1 "/home/pwachara/basilisk/src/fractions.h"
#line 12 "/home/pwachara/basilisk/src/fractions.h"
#line 1 "geometry.h"
#line 1 "/home/pwachara/basilisk/src/geometry.h"
#line 35 "/home/pwachara/basilisk/src/geometry.h"
double line_alpha (double c, coord n)
{
  double alpha, n1, n2;

  n1 = fabs (n.x); n2 = fabs (n.y);
  if (n1 > n2)
    do { double _tmp_ = n1; n1 = n2; n2 = _tmp_; } while(false);

  c = ( c < 0. ? 0. : c > 1. ? 1. : c);
  double v1 = n1/2.;
  if (c <= v1/n2)
    alpha = sqrt (2.*c*n1*n2);
  else if (c <= 1. - v1/n2)
    alpha = c*n2 + v1;
  else
    alpha = n1 + n2 - sqrt (2.*n1*n2*(1. - c));

  if (n.x < 0.)
    alpha += n.x;
  if (n.y < 0.)
    alpha += n.y;

  return alpha - (n.x + n.y)/2.;
}



double plane_alpha (double c, coord n)
{
  double alpha;
  coord n1;

  n1.x = fabs (n.x); n1.y = fabs (n.y); n1.z = fabs (n.z);

  double m1, m2, m3;
  m1 = ( (n1.x) < (n1.y) ? (n1.x) : (n1.y));
  m3 = ( (n1.x) > (n1.y) ? (n1.x) : (n1.y));
  m2 = n1.z;
  if (m2 < m1) {
    double tmp = m1;
    m1 = m2;
    m2 = tmp;
  }
  else if (m2 > m3) {
    double tmp = m3;
    m3 = m2;
    m2 = tmp;
  }
  double m12 = m1 + m2;
  double pr = ( (6.*m1*m2*m3) > 1e-50 ? (6.*m1*m2*m3) : 1e-50);
  double V1 = m1*m1*m1/pr;
  double V2 = V1 + (m2 - m1)/(2.*m3), V3;
  double mm;
  if (m3 < m12) {
    mm = m3;
    V3 = (m3*m3*(3.*m12 - m3) + m1*m1*(m1 - 3.*m3) + m2*m2*(m2 - 3.*m3))/pr;
  }
  else {
    mm = m12;
    V3 = mm/(2.*m3);
  }

  c = ( c < 0. ? 0. : c > 1. ? 1. : c);
  double ch = ( c < (1. - c) ? c : (1. - c));
  if (ch < V1)
    alpha = pow (pr*ch, 1./3.);
  else if (ch < V2)
    alpha = (m1 + sqrt(m1*m1 + 8.*m2*m3*(ch - V1)))/2.;
  else if (ch < V3) {
    double p12 = sqrt (2.*m1*m2);
    double q = 3.*(m12 - 2.*m3*ch)/(4.*p12);
    double teta = acos(( q < (-1.) ? (-1.) : q > 1. ? 1. : q))/3.;
    double cs = cos(teta);
    alpha = p12*(sqrt(3.*(1. - cs*cs)) - cs) + m12;
  }
  else if (m12 <= m3)
    alpha = m3*ch + mm/2.;
  else {
    double p = m1*(m2 + m3) + m2*m3 - 1./4., p12 = sqrt(p);
    double q = 3.*m1*m2*m3*(1./2. - ch)/(2.*p*p12);
    double teta = acos(( q < (-1.) ? (-1.) : q > 1. ? 1. : q))/3.;
    double cs = cos(teta);
    alpha = p12*(sqrt(3.*(1. - cs*cs)) - cs) + 1./2.;
  }
  if (c > 1./2.) alpha = 1. - alpha;

  if (n.x < 0.)
    alpha += n.x;
  if (n.y < 0.)
    alpha += n.y;
  if (n.z < 0.)
    alpha += n.z;

  return alpha - (n.x + n.y + n.z)/2.;;
}
#line 163 "/home/pwachara/basilisk/src/geometry.h"
double line_area (double nx, double ny, double alpha)
{
  double a, v, area;

  alpha += (nx + ny)/2.;
  if (nx < 0.) {
    alpha -= nx;
    nx = - nx;
  }
  if (ny < 0.) {
    alpha -= ny;
    ny = - ny;
  }

  if (alpha <= 0.)
    return 0.;

  if (alpha >= nx + ny)
    return 1.;

  if (nx < 1e-10)
    area = alpha/ny;
  else if (ny < 1e-10)
    area = alpha/nx;
  else {
    v = ( alpha*alpha);

    a = alpha - nx;
    if (a > 0.)
      v -= a*a;

    a = alpha - ny;
    if (a > 0.)
      v -= a*a;

    area = v/(2.*nx*ny);
  }

  return ( area < 0. ? 0. : area > 1. ? 1. : area);
}



double plane_volume (coord n, double alpha)
{
  double al = alpha + (n.x + n.y + n.z)/2. +
    ( 0. > (-n.x) ? 0. : (-n.x)) + ( 0. > (-n.y) ? 0. : (-n.y)) + ( 0. > (-n.z) ? 0. : (-n.z));
  if (al <= 0.)
    return 0.;
  double tmp = fabs(n.x) + fabs(n.y) + fabs(n.z);
  if (al >= tmp)
    return 1.;
  if (tmp < 1e-10)
    return 0.;
  double n1 = fabs(n.x)/tmp;
  double n2 = fabs(n.y)/tmp;
  double n3 = fabs(n.z)/tmp;
  al = ( 0. > (( 1. < (al/tmp) ? 1. : (al/tmp))) ? 0. : (( 1. < (al/tmp) ? 1. : (al/tmp))));
  double al0 = ( al < (1. - al) ? al : (1. - al));
  double b1 = ( n1 < n2 ? n1 : n2);
  double b3 = ( n1 > n2 ? n1 : n2);
  double b2 = n3;
  if (b2 < b1) {
    tmp = b1;
    b1 = b2;
    b2 = tmp;
  }
  else if (b2 > b3) {
    tmp = b3;
    b3 = b2;
    b2 = tmp;
  }
  double b12 = b1 + b2;
  double bm = ( b12 < b3 ? b12 : b3);
  double pr = ( (6.*b1*b2*b3) > 1e-50 ? (6.*b1*b2*b3) : 1e-50);
  if (al0 < b1)
    tmp = al0*al0*al0/pr;
  else if (al0 < b2)
    tmp = 0.5*al0*(al0 - b1)/(b2*b3) + b1*b1*b1/pr;
  else if (al0 < bm)
    tmp = (al0*al0*(3.*b12 - al0) + b1*b1*(b1 - 3.*al0) +
    b2*b2*(b2 - 3.*al0))/pr;
  else if (b12 < b3)
    tmp = (al0 - 0.5*bm)/b3;
  else
    tmp = (al0*al0*(3. - 2.*al0) + b1*b1*(b1 - 3.*al0) +
    b2*b2*(b2 - 3.*al0) + b3*b3*(b3 - 3.*al0))/pr;

  double volume = al <= 0.5 ? tmp : 1. - tmp;
  return ( volume < 0. ? 0. : volume > 1. ? 1. : volume);
}
#line 267 "/home/pwachara/basilisk/src/geometry.h"
double rectangle_fraction (coord n, double alpha, coord a, coord b)
{
  coord n1;
   {
    alpha -= n.x*(b.x + a.x)/2.;
    n1.x = n.x*(b.x - a.x);
  } 
#line 270
{
    alpha -= n.y*(b.y + a.y)/2.;
    n1.y = n.y*(b.y - a.y);
  } 
#line 270
{
    alpha -= n.z*(b.z + a.z)/2.;
    n1.z = n.z*(b.z - a.z);
  }
  return plane_volume (n1, alpha);
}
#line 307 "/home/pwachara/basilisk/src/geometry.h"
static coord cube_edge[12][2] = {
  {{0.,0.,0.},{1.,0.,0.}},{{0.,0.,1.},{1.,0.,1.}},
  {{0.,1.,1.},{1.,1.,1.}},{{0.,1.,0.},{1.,1.,0.}},
  {{0.,0.,0.},{0.,1.,0.}},{{0.,0.,1.},{0.,1.,1.}},
  {{1.,0.,1.},{1.,1.,1.}},{{1.,0.,0.},{1.,1.,0.}},
  {{0.,0.,0.},{0.,0.,1.}},{{1.,0.,0.},{1.,0.,1.}},
  {{1.,1.,0.},{1.,1.,1.}},{{0.,1.,0.},{0.,1.,1.}}
};




static int cube_connect[12][2][4] = {
  {{9, 1, 8}, {4, 3, 7}},
  {{6, 2, 5}, {8, 0, 9}},
  {{10, 3, 11}, {5, 1, 6}},
  {{7, 0, 4}, {11, 2, 10}},
  {{3, 7, 0}, {8, 5, 11}},
  {{11, 4, 8}, {1, 6, 2}},
  {{2, 5, 1}, {9, 7, 10}},
  {{10, 6, 9}, {0, 4, 3}},
  {{5, 11, 4}, {0, 9, 1}},
  {{1, 8, 0}, {7, 10, 6}},
  {{6, 9, 7}, {3, 11, 2}},
  {{2, 10, 3}, {4, 8, 5}}
};

int facets (coord n, double alpha, coord v[12], double h)
{
  coord a[12];
  int orient[12];

  for (int i = 0; i < 12; i++) {
    coord e, d;
    double den = 0., t = alpha;
     {
      d.x = h*(cube_edge[i][0].x - 0.5);
      e.x = h*(cube_edge[i][1].x - 0.5);
      den += n.x*(e.x - d.x);
      t -= n.x*d.x;
    } 
#line 342
{
      d.y = h*(cube_edge[i][0].y - 0.5);
      e.y = h*(cube_edge[i][1].y - 0.5);
      den += n.y*(e.y - d.y);
      t -= n.y*d.y;
    } 
#line 342
{
      d.z = h*(cube_edge[i][0].z - 0.5);
      e.z = h*(cube_edge[i][1].z - 0.5);
      den += n.z*(e.z - d.z);
      t -= n.z*d.z;
    }
    orient[i] = -1;
    if (fabs (den) > 1e-10) {
      t /= den;
      if (t >= 0. && t < 1.) {
 double s = - alpha;
  {
   a[i].x = d.x + t*(e.x - d.x);
   s += n.x*e.x;
 } 
#line 353
{
   a[i].y = d.y + t*(e.y - d.y);
   s += n.y*e.y;
 } 
#line 353
{
   a[i].z = d.z + t*(e.z - d.z);
   s += n.z*e.z;
 }
 orient[i] = (s > 0.);
      }
    }
  }

  for (int i = 0; i < 12; i++) {
    int nv = 0, e = i;
    while (orient[e] >= 0) {
      int m = 0, * ne = cube_connect[e][orient[e]];
      v[nv++] = a[e];
      orient[e] = -1;
      while (m < 3 && orient[e] < 0)
 e = ne[m++];
    }
    if (nv > 2)
      return nv;
  }
  return 0;
}






double line_length_center (coord m, double alpha, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  
    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }    
#line 388
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }

  p->x = p->y = p->z = 0.;

  if (alpha <= 0. || alpha >= n.x + n.y)
    return 0.;

  
    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = (m.y < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }    
#line 399
if (n.y < 1e-4) {
      p->y = 0.;
      p->x = (m.x < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }

  if (alpha >= n.x) {
    p->x += 1.;
    p->y += (alpha - n.x)/n.y;
  }
  else
    p->x += alpha/n.x;

  double ax = p->x, ay = p->y;
  if (alpha >= n.y) {
    p->y += 1.;
    ay -= 1.;
    p->x += (alpha - n.y)/n.x;
    ax -= (alpha - n.y)/n.x;
  }
  else {
    p->y += alpha/n.y;
    ay -= alpha/n.y;
  }

   {
    p->x /= 2.;
    p->x = ( (p->x) < 0. ? 0. : (p->x) > 1. ? 1. : (p->x));
    if (m.x < 0.)
      p->x = 1. - p->x;
    p->x -= 0.5;
  } 
#line 424
{
    p->y /= 2.;
    p->y = ( (p->y) < 0. ? 0. : (p->y) > 1. ? 1. : (p->y));
    if (m.y < 0.)
      p->y = 1. - p->y;
    p->y -= 0.5;
  }

  return sqrt (ax*ax + ay*ay);
}




double plane_area_center (coord m, double alpha, coord * p)
{
  
    if (fabs (m.x) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.y;
      ((double *)&n)[1] = m.z;
      double length = line_length_center (n, alpha, &q);
      p->x = 0.;
      p->y = ((double *)&q)[0];
      p->z = ((double *)&q)[1];
      return length;
    }    
#line 441
if (fabs (m.y) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.z;
      ((double *)&n)[1] = m.x;
      double length = line_length_center (n, alpha, &q);
      p->y = 0.;
      p->z = ((double *)&q)[0];
      p->x = ((double *)&q)[1];
      return length;
    }    
#line 441
if (fabs (m.z) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.x;
      ((double *)&n)[1] = m.y;
      double length = line_length_center (n, alpha, &q);
      p->z = 0.;
      p->x = ((double *)&q)[0];
      p->y = ((double *)&q)[1];
      return length;
    }

  alpha += (m.x + m.y + m.z)/2.;
  coord n = m;
  
    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }    
#line 455
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }    
#line 455
if (n.z < 0.) {
      alpha -= n.z;
      n.z = - n.z;
    }

  double amax = n.x + n.y + n.z;
  if (alpha < 0. || alpha > amax) {
    p->x = p->y = p->z = 0.;
    return 0.;
  }

  double area = ( alpha*alpha);
  p->x = p->y = p->z = area*alpha;

   {
    double b = alpha - n.x;
    if (b > 0.) {
      area -= b*b;
      p->x -= b*b*(2.*n.x + alpha);
      p->y -= b*b*b;
      p->z -= b*b*b;
    }
  } 
#line 469
{
    double b = alpha - n.y;
    if (b > 0.) {
      area -= b*b;
      p->y -= b*b*(2.*n.y + alpha);
      p->z -= b*b*b;
      p->x -= b*b*b;
    }
  } 
#line 469
{
    double b = alpha - n.z;
    if (b > 0.) {
      area -= b*b;
      p->z -= b*b*(2.*n.z + alpha);
      p->x -= b*b*b;
      p->y -= b*b*b;
    }
  }

  amax = alpha - amax;
   {
    double b = amax + n.x;
    if (b > 0.) {
      area += b*b;
      p->y += b*b*(2.*n.y + alpha - n.z);
      p->z += b*b*(2.*n.z + alpha - n.y);
      p->x += b*b*b;
    }
  } 
#line 480
{
    double b = amax + n.y;
    if (b > 0.) {
      area += b*b;
      p->z += b*b*(2.*n.z + alpha - n.x);
      p->x += b*b*(2.*n.x + alpha - n.z);
      p->y += b*b*b;
    }
  } 
#line 480
{
    double b = amax + n.z;
    if (b > 0.) {
      area += b*b;
      p->x += b*b*(2.*n.x + alpha - n.y);
      p->y += b*b*(2.*n.y + alpha - n.x);
      p->z += b*b*b;
    }
  }

  area *= 3.;
   {
    if (area) {
      p->x /= area*n.x;
      p->x = ( (p->x) < 0. ? 0. : (p->x) > 1. ? 1. : (p->x));
    }
    else
      p->x = 0.;
    if (m.x < 0.) p->x = 1. - p->x;
    p->x -= 0.5;
  } 
#line 491
{
    if (area) {
      p->y /= area*n.y;
      p->y = ( (p->y) < 0. ? 0. : (p->y) > 1. ? 1. : (p->y));
    }
    else
      p->y = 0.;
    if (m.y < 0.) p->y = 1. - p->y;
    p->y -= 0.5;
  } 
#line 491
{
    if (area) {
      p->z /= area*n.z;
      p->z = ( (p->z) < 0. ? 0. : (p->z) > 1. ? 1. : (p->z));
    }
    else
      p->z = 0.;
    if (m.z < 0.) p->z = 1. - p->z;
    p->z -= 0.5;
  }

  return area*sqrt (1./(( (n.x)*(n.x))*( (n.y)*(n.y))) +
      1./(( (n.x)*(n.x))*( (n.z)*(n.z))) +
      1./(( (n.z)*(n.z))*( (n.y)*(n.y))))/6.;
}






void line_center (coord m, double alpha, double a, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  
    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }    
#line 518
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }

  p->z = 0.;
  if (alpha <= 0.) {
    p->x = p->y = -0.5;
    return;
  }

  if (alpha >= n.x + n.y) {
    p->x = p->y = 0.;
    return;
  }

  
    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = ( (int)((m.y) > 0 ? 1 : -1))*(a/2. - 0.5);
      return;
    }    
#line 535
if (n.y < 1e-4) {
      p->y = 0.;
      p->x = ( (int)((m.x) > 0 ? 1 : -1))*(a/2. - 0.5);
      return;
    }

  p->x = p->y = ( alpha*alpha*alpha);

   {
    double b = alpha - n.x;
    if (b > 0.) {
      p->x -= ( b*b)*(alpha + 2.*n.x);
      p->y -= ( b*b*b);
    }
  } 
#line 543
{
    double b = alpha - n.y;
    if (b > 0.) {
      p->y -= ( b*b)*(alpha + 2.*n.y);
      p->x -= ( b*b*b);
    }
  }

   {
    p->x /= 6.*( (n.x)*(n.x))*n.y*a;
    p->x = ( (int)((m.x) > 0 ? 1 : -1))*(p->x - 0.5);
  } 
#line 551
{
    p->y /= 6.*( (n.y)*(n.y))*n.x*a;
    p->y = ( (int)((m.y) > 0 ? 1 : -1))*(p->y - 0.5);
  }
}
#line 564 "/home/pwachara/basilisk/src/geometry.h"
void plane_center (coord m, double alpha, double a, coord * p)
{
  
    if (fabs (m.x) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.y;
      ((double *)&n)[1] = m.z;
      line_center (n, alpha, a, &q);
      p->x = 0.;
      p->y = ((double *)&q)[0];
      p->z = ((double *)&q)[1];
      return;
    }    
#line 567
if (fabs (m.y) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.z;
      ((double *)&n)[1] = m.x;
      line_center (n, alpha, a, &q);
      p->y = 0.;
      p->z = ((double *)&q)[0];
      p->x = ((double *)&q)[1];
      return;
    }    
#line 567
if (fabs (m.z) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.x;
      ((double *)&n)[1] = m.y;
      line_center (n, alpha, a, &q);
      p->z = 0.;
      p->x = ((double *)&q)[0];
      p->y = ((double *)&q)[1];
      return;
    }

  alpha += (m.x + m.y + m.z)/2.;
  coord n = m;
  
    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }    
#line 581
if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }    
#line 581
if (n.z < 0.) {
      alpha -= n.z;
      n.z = - n.z;
    }

  if (alpha <= 0. || a == 0.) {
    p->x = p->y = p->z = -0.5;
    return;
  }

  if (alpha >= n.x + n.y + n.z || a == 1.) {
    p->x = p->y = p->z = 0.;
    return;
  }

  p->x = p->y = p->z = ( (( alpha*alpha))*(( alpha*alpha)));
   {
    double b = alpha - n.x;
    if (b > 0.) {
      p->x -= ( b*b*b)*(3.*n.x + alpha);
      p->y -= ( (( b*b))*(( b*b)));
      p->z -= ( (( b*b))*(( b*b)));
    }
  } 
#line 597
{
    double b = alpha - n.y;
    if (b > 0.) {
      p->y -= ( b*b*b)*(3.*n.y + alpha);
      p->z -= ( (( b*b))*(( b*b)));
      p->x -= ( (( b*b))*(( b*b)));
    }
  } 
#line 597
{
    double b = alpha - n.z;
    if (b > 0.) {
      p->z -= ( b*b*b)*(3.*n.z + alpha);
      p->x -= ( (( b*b))*(( b*b)));
      p->y -= ( (( b*b))*(( b*b)));
    }
  }

  double amax = alpha - (n.x + n.y + n.z);
   {
    double b = amax + n.z;
    if (b > 0.) {
      p->x += ( b*b*b)*(3.*n.x + alpha - n.y);
      p->y += ( b*b*b)*(3.*n.y + alpha - n.x);
      p->z += ( (( b*b))*(( b*b)));
    }
  } 
#line 607
{
    double b = amax + n.x;
    if (b > 0.) {
      p->y += ( b*b*b)*(3.*n.y + alpha - n.z);
      p->z += ( b*b*b)*(3.*n.z + alpha - n.y);
      p->x += ( (( b*b))*(( b*b)));
    }
  } 
#line 607
{
    double b = amax + n.y;
    if (b > 0.) {
      p->z += ( b*b*b)*(3.*n.z + alpha - n.x);
      p->x += ( b*b*b)*(3.*n.x + alpha - n.z);
      p->y += ( (( b*b))*(( b*b)));
    }
  }

  double b = 24.*n.x*n.y*n.z*a;
   {
    p->x /= b*n.x;
    p->x = ( (int)((m.x) > 0 ? 1 : -1))*(p->x - 0.5);
  } 
#line 617
{
    p->y /= b*n.y;
    p->y = ( (int)((m.y) > 0 ? 1 : -1))*(p->y - 0.5);
  } 
#line 617
{
    p->z /= b*n.z;
    p->z = ( (int)((m.z) > 0 ? 1 : -1))*(p->z - 0.5);
  }
}
#line 13 "/home/pwachara/basilisk/src/fractions.h"







#line 1 "myc.h"
#line 1 "/home/pwachara/basilisk/src/myc.h"
#line 16 "/home/pwachara/basilisk/src/myc.h"
coord mycs (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 18 "/home/pwachara/basilisk/src/myc.h"
double m1,m2,m[4][3],t0,t1,t2;
  int cn;



  m1 = val(c,-1,0,-1) + val(c,-1,0,1) + val(c,-1,-1,0) + val(c,-1,1,0) +
       val(c,-1,0,0);
  m2 = val(c,1,0,-1) + val(c,1,0,1) + val(c,1,-1,0) + val(c,1,1,0) +
       val(c,1,0,0);
  m[0][0] = m1 > m2 ? 1. : -1.;

  m1 = val(c,-1,-1,0)+ val(c,1,-1,0)+ val(c,0,-1,0);
  m2 = val(c,-1,1,0)+ val(c,1,1,0)+ val(c,0,1,0);
  m[0][1] = 0.5*(m1-m2);

  m1 = val(c,-1,0,-1)+ val(c,1,0,-1)+ val(c,0,0,-1);
  m2 = val(c,-1,0,1)+ val(c,1,0,1)+ val(c,0,0,1);
  m[0][2] = 0.5*(m1-m2);



  m1 = val(c,-1,-1,0) + val(c,-1,1,0) + val(c,-1,0,0);
  m2 = val(c,1,-1,0) + val(c,1,1,0) + val(c,1,0,0);
  m[1][0] = 0.5*(m1-m2);

  m1 = val(c,0,-1,-1) + val(c,0,-1,1) + val(c,1,-1,0) + val(c,-1,-1,0) +
       val(c,0,-1,0);
  m2 = val(c,0,1,-1) + val(c,0,1,1) + val(c,1,1,0) + val(c,-1,1,0) +
       val(c,0,1,0);
  m[1][1] = m1 > m2 ? 1. : -1.;

  m1 = val(c,0,-1,-1)+ val(c,0,0,-1)+ val(c,0,1,-1);
  m2 = val(c,0,-1,1)+ val(c,0,0,1)+ val(c,0,1,1);
  m[1][2] = 0.5*(m1-m2);




  m1 = val(c,-1,0,-1)+ val(c,-1,0,1)+ val(c,-1,0,0);
  m2 = val(c,1,0,-1)+ val(c,1,0,1)+ val(c,1,0,0);
  m[2][0] = 0.5*(m1-m2);

  m1 = val(c,0,-1,-1)+ val(c,0,-1,1)+ val(c,0,-1,0);
  m2 = val(c,0,1,-1)+ val(c,0,1,1)+ val(c,0,1,0);
  m[2][1] = 0.5*(m1-m2);

  m1 = val(c,-1,0,-1) + val(c,1,0,-1) + val(c,0,-1,-1) + val(c,0,1,-1) +
       val(c,0,0,-1);
  m2 = val(c,-1,0,1) + val(c,1,0,1) + val(c,0,-1,1) + val(c,0,1,1) +
       val(c,0,0,1);
  m[2][2] = m1 > m2 ? 1. : -1.;


  t0 = fabs(m[0][0]) + fabs(m[0][1]) + fabs(m[0][2]);
  m[0][0] /= t0;
  m[0][1] /= t0;
  m[0][2] /= t0;

  t0 = fabs(m[1][0]) + fabs(m[1][1]) + fabs(m[1][2]);
  m[1][0] /= t0;
  m[1][1] /= t0;
  m[1][2] /= t0;

  t0 = fabs(m[2][0]) + fabs(m[2][1]) + fabs(m[2][2]);
  m[2][0] /= t0;
  m[2][1] /= t0;
  m[2][2] /= t0;


  t0 = fabs(m[0][0]);
  t1 = fabs(m[1][1]);
  t2 = fabs(m[2][2]);

  cn = 0;
  if (t1 > t0) {
    t0 = t1;
    cn = 1;
  }
  if (t2 > t0)
    cn = 2;


  m1 = val(c,-1,-1,-1) + val(c,-1,1,-1) + val(c,-1,-1,1) + val(c,-1,1,1) +
       2.*(val(c,-1,-1,0) + val(c,-1,1,0) + val(c,-1,0,-1) + val(c,-1,0,1)) +
       4.*val(c,-1,0,0);
  m2 = val(c,1,-1,-1) + val(c,1,1,-1) + val(c,1,-1,1) + val(c,1,1,1) +
       2.*(val(c,1,-1,0) + val(c,1,1,0) + val(c,1,0,-1) + val(c,1,0,1)) +
       4.*val(c,1,0,0);
  m[3][0] = m1 - m2;

  m1 = val(c,-1,-1,-1) + val(c,-1,-1,1) + val(c,1,-1,-1) + val(c,1,-1,1) +
       2.*( val(c,-1,-1,0) + val(c,1,-1,0) + val(c,0,-1,-1) + val(c,0,-1,1)) +
       4.*val(c,0,-1,0);
  m2 = val(c,-1,1,-1) + val(c,-1,1,1) + val(c,1,1,-1) + val(c,1,1,1) +
       2.*(val(c,-1,1,0) + val(c,1,1,0) + val(c,0,1,-1) + val(c,0,1,1)) +
       4.*val(c,0,1,0);
  m[3][1] = m1 - m2;

  m1 = val(c,-1,-1,-1) + val(c,-1,1,-1) + val(c,1,-1,-1) + val(c,1,1,-1) +
       2.*(val(c,-1,0,-1) + val(c,1,0,-1) + val(c,0,-1,-1) + val(c,0,1,-1)) +
       4.*val(c,0,0,-1);
  m2 = val(c,-1,-1,1) + val(c,-1,1,1) + val(c,1,-1,1) + val(c,1,1,1) +
       2.*(val(c,-1,0,1) + val(c,1,0,1) + val(c,0,-1,1) + val(c,0,1,1)) +
       4.*val(c,0,0,1);
  m[3][2] = m1 - m2;


  t0 = fabs(m[3][0]) + fabs(m[3][1]) + fabs(m[3][2]);
  if (t0 < 1e-30) {
    coord mxyz = {1., 0., 0.};
    return mxyz;
  }

  m[3][0] /= t0;
  m[3][1] /= t0;
  m[3][2] /= t0;


  t0 = fabs (m[3][0]);
  t1 = fabs (m[3][1]);
  t2 = fabs (m[3][2]);
  if (t1 > t0)
    t0 = t1;
  if (t2 > t0)
    t0 = t2;

  if (fabs(m[cn][cn]) > t0)
    cn = 3;


  coord mxyz = {m[cn][0], m[cn][1], m[cn][2]};
  return mxyz;
}
#line 13 "/home/pwachara/basilisk/src/fractions.h"







#line 1 "myc.h"
#line 1 "/home/pwachara/basilisk/src/myc.h"
#line 16 "/home/pwachara/basilisk/src/myc.h"
static void _stencil_mycs (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 23 "/home/pwachara/basilisk/src/myc.h"
_stencil_val(c,-1,0,-1); _stencil_val(c,-1,0,1); _stencil_val(c,-1,-1,0); _stencil_val(c,-1,1,0);
       _stencil_val(c,-1,0,0);       
_stencil_val(c,1,0,-1); _stencil_val(c,1,0,1); _stencil_val(c,1,-1,0); _stencil_val(c,1,1,0);
       _stencil_val(c,1,0,0);  
      
          
_stencil_val(c,-1,-1,0); _stencil_val(c,1,-1,0); _stencil_val(c,0,-1,0);    
_stencil_val(c,-1,1,0); _stencil_val(c,1,1,0); _stencil_val(c,0,1,0);
   
     
_stencil_val(c,-1,0,-1); _stencil_val(c,1,0,-1); _stencil_val(c,0,0,-1);    
_stencil_val(c,-1,0,1); _stencil_val(c,1,0,1); _stencil_val(c,0,0,1);
   
     


_stencil_val(c,-1,-1,0); _stencil_val(c,-1,1,0); _stencil_val(c,-1,0,0);      
_stencil_val(c,1,-1,0); _stencil_val(c,1,1,0); _stencil_val(c,1,0,0);
     
     
_stencil_val(c,0,-1,-1); _stencil_val(c,0,-1,1); _stencil_val(c,1,-1,0); _stencil_val(c,-1,-1,0);
       _stencil_val(c,0,-1,0);        
_stencil_val(c,0,1,-1); _stencil_val(c,0,1,1); _stencil_val(c,1,1,0); _stencil_val(c,-1,1,0);
       _stencil_val(c,0,1,0);
       
           
_stencil_val(c,0,-1,-1); _stencil_val(c,0,0,-1); _stencil_val(c,0,1,-1);    
_stencil_val(c,0,-1,1); _stencil_val(c,0,0,1); _stencil_val(c,0,1,1);
   
     



_stencil_val(c,-1,0,-1); _stencil_val(c,-1,0,1); _stencil_val(c,-1,0,0);    
_stencil_val(c,1,0,-1); _stencil_val(c,1,0,1); _stencil_val(c,1,0,0);
   
     
_stencil_val(c,0,-1,-1); _stencil_val(c,0,-1,1); _stencil_val(c,0,-1,0);    
_stencil_val(c,0,1,-1); _stencil_val(c,0,1,1); _stencil_val(c,0,1,0);
   
     
_stencil_val(c,-1,0,-1); _stencil_val(c,1,0,-1); _stencil_val(c,0,-1,-1); _stencil_val(c,0,1,-1);
       _stencil_val(c,0,0,-1);        
_stencil_val(c,-1,0,1); _stencil_val(c,1,0,1); _stencil_val(c,0,-1,1); _stencil_val(c,0,1,1);
       _stencil_val(c,0,0,1);    
       
          


       
    
    
    

        
    
    
    

        
    
    
    


    
   
   

    
      
     
   
      
     
      

_stencil_val(c,-1,-1,-1); _stencil_val(c,-1,1,-1); _stencil_val(c,-1,-1,1); _stencil_val(c,-1,1,1);
_stencil_val(c,-1,-1,0); _stencil_val(c,-1,1,0); _stencil_val(c,-1,0,-1); _stencil_val(c,-1,0,1);
_stencil_val(c,-1,0,0);        
_stencil_val(c,1,-1,-1); _stencil_val(c,1,1,-1); _stencil_val(c,1,-1,1); _stencil_val(c,1,1,1);
_stencil_val(c,1,-1,0); _stencil_val(c,1,1,0); _stencil_val(c,1,0,-1); _stencil_val(c,1,0,1);
_stencil_val(c,1,0,0);       


_stencil_val(c,-1,-1,-1); _stencil_val(c,-1,-1,1); _stencil_val(c,1,-1,-1); _stencil_val(c,1,-1,1); 
_stencil_val(c,-1,-1,0); _stencil_val(c,1,-1,0); _stencil_val(c,0,-1,-1); _stencil_val(c,0,-1,1);
_stencil_val(c,0,-1,0);        
_stencil_val(c,-1,1,-1); _stencil_val(c,-1,1,1); _stencil_val(c,1,1,-1); _stencil_val(c,1,1,1);
_stencil_val(c,-1,1,0); _stencil_val(c,1,1,0); _stencil_val(c,0,1,-1); _stencil_val(c,0,1,1);
_stencil_val(c,0,1,0);       


_stencil_val(c,-1,-1,-1); _stencil_val(c,-1,1,-1); _stencil_val(c,1,-1,-1); _stencil_val(c,1,1,-1);
_stencil_val(c,-1,0,-1); _stencil_val(c,1,0,-1); _stencil_val(c,0,-1,-1); _stencil_val(c,0,1,-1);
_stencil_val(c,0,0,-1);        
_stencil_val(c,-1,-1,1); _stencil_val(c,-1,1,1); _stencil_val(c,1,-1,1); _stencil_val(c,1,1,1);
_stencil_val(c,-1,0,1); _stencil_val(c,1,0,1); _stencil_val(c,0,-1,1); _stencil_val(c,0,1,1);
_stencil_val(c,0,0,1);  
#line 149
return ;
}
#line 21 "/home/pwachara/basilisk/src/fractions.h"
#line 120 "/home/pwachara/basilisk/src/fractions.h"
     
void fractions (scalar Phi, scalar c,
  vector s, double val)
{tracing("fractions","/home/pwachara/basilisk/src/fractions.h",121);

  vector   as=(s).x.i>0?(s):new_face_vector("as");
#line 134 "/home/pwachara/basilisk/src/fractions.h"
  vector  p=new_vector("p");
  
  
  
#line 146 "/home/pwachara/basilisk/src/fractions.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/grid/multigrid.h", .line = 927, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true; 
#line 927 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
    struct { int x, y, z; } _a = {point.i, point.j, point.k};
    
      if (_a.x < point.n.x + 2) 
#line 146 "/home/pwachara/basilisk/src/fractions.h"
{





_stencil_val(Phi,0,0,0);_stencil_val(Phi,1,0,0);{ {






_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,0,0); _stencil_val(Phi,1,0,0);      _stencil_val_a(p.x,0,0,0);
_stencil_val(Phi,0,0,0);
 { _stencil_val(p.x,0,0,0);_stencil_val_a(p.x,0,0,0);   }    
}
      








{_stencil_val(Phi,0,0,0); _stencil_val(Phi,1,0,0);_stencil_val_a(p.x,0,0,0);       }}





           
#line 171 "/home/pwachara/basilisk/src/fractions.h"
    
  
}
      
#line 930 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (_a.y < point.n.y + 2) 
#line 146 "/home/pwachara/basilisk/src/fractions.h"
{





_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,1,0);{ {






_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,0,0); _stencil_val(Phi,0,1,0);      _stencil_val_a(p.y,0,0,0);
_stencil_val(Phi,0,0,0);
 { _stencil_val(p.y,0,0,0);_stencil_val_a(p.y,0,0,0);   }    
}
      








{_stencil_val(Phi,0,0,0); _stencil_val(Phi,0,1,0);_stencil_val_a(p.y,0,0,0);       }}





           
#line 171 "/home/pwachara/basilisk/src/fractions.h"
    
  
}
      
#line 930 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (_a.z < point.n.z + 2) 
#line 146 "/home/pwachara/basilisk/src/fractions.h"
{





_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,0,1);{ {






_stencil_val(Phi,0,0,0);_stencil_val(Phi,0,0,0); _stencil_val(Phi,0,0,1);      _stencil_val_a(p.z,0,0,0);
_stencil_val(Phi,0,0,0);
 { _stencil_val(p.z,0,0,0);_stencil_val_a(p.z,0,0,0);   }    
}
      








{_stencil_val(Phi,0,0,0); _stencil_val(Phi,0,0,1);_stencil_val_a(p.z,0,0,0);       }}





           
#line 171 "/home/pwachara/basilisk/src/fractions.h"
    
  
}
  
#line 932 "/home/pwachara/basilisk/src/grid/multigrid.h"
}  
#line 338 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 912 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
#line 300
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 913
{
    int ig = -1; NOT_UNUSED(ig);

    int jg = -1; NOT_UNUSED(jg);


    int kg = -1; NOT_UNUSED(kg); 







{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 927
{
    struct { int x, y, z; } _a = {point.i, point.j, point.k};
    
      if (_a.x < point.n.x + 2) 
#line 146 "/home/pwachara/basilisk/src/fractions.h"
{





    if ((val(Phi,0,0,0) - val)*(val(Phi,1,0,0) - val) < 0.) {






      val(p.x,0,0,0) = (val(Phi,0,0,0) - val)/(val(Phi,0,0,0) - val(Phi,1,0,0));
      if (val(Phi,0,0,0) < val)
 val(p.x,0,0,0) = 1. - val(p.x,0,0,0);
    }
#line 171 "/home/pwachara/basilisk/src/fractions.h"
    else
      val(p.x,0,0,0) = (val(Phi,0,0,0) > val || val(Phi,1,0,0) > val);
  }
      
#line 930 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (_a.y < point.n.y + 2) 
#line 146 "/home/pwachara/basilisk/src/fractions.h"
{





    if ((val(Phi,0,0,0) - val)*(val(Phi,0,1,0) - val) < 0.) {






      val(p.y,0,0,0) = (val(Phi,0,0,0) - val)/(val(Phi,0,0,0) - val(Phi,0,1,0));
      if (val(Phi,0,0,0) < val)
 val(p.y,0,0,0) = 1. - val(p.y,0,0,0);
    }
#line 171 "/home/pwachara/basilisk/src/fractions.h"
    else
      val(p.y,0,0,0) = (val(Phi,0,0,0) > val || val(Phi,0,1,0) > val);
  }
      
#line 930 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (_a.z < point.n.z + 2) 
#line 146 "/home/pwachara/basilisk/src/fractions.h"
{





    if ((val(Phi,0,0,0) - val)*(val(Phi,0,0,1) - val) < 0.) {






      val(p.z,0,0,0) = (val(Phi,0,0,0) - val)/(val(Phi,0,0,0) - val(Phi,0,0,1));
      if (val(Phi,0,0,0) < val)
 val(p.z,0,0,0) = 1. - val(p.z,0,0,0);
    }
#line 171 "/home/pwachara/basilisk/src/fractions.h"
    else
      val(p.z,0,0,0) = (val(Phi,0,0,0) > val || val(Phi,0,0,1) > val);
  }
  
#line 932 "/home/pwachara/basilisk/src/grid/multigrid.h"
}}  
#line 922
}      
#line 317
}
  }
}

#line 923
}
#line 190 "/home/pwachara/basilisk/src/fractions.h"
  
    _attribute[p.x.i].dirty = false;    _attribute[p.y.i].dirty = false;    _attribute[p.z.i].dirty = false;

  scalar s_x = as.x, s_y = as.y, s_z = as.z;
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/fractions.h", .line = 194, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 194 "/home/pwachara/basilisk/src/fractions.h"
{ 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);  
#line 199 "/home/pwachara/basilisk/src/fractions.h"
{    
#line 231 "/home/pwachara/basilisk/src/fractions.h"
    
    
     { 
_stencil_val(p.y,0,0,0); _stencil_val(p.y,1,0,0);    

} 
#line 233
{ 
_stencil_val(p.x,0,0,0); _stencil_val(p.x,0,1,0);    

}





{
      { _stencil_val(p.x,0,0,0);_stencil_val_a(s_z,0,0,0); } 
{      





      
   






      
      for (int i = 0; i <= 1; i++)
 {
   {_stencil_val(p.x,0,i,0); _stencil_val(p.x,0,i,0); {              
     _stencil_val(p.x,0,i,0);_stencil_val(Phi,0,i,0); 
          
     
   }      }   
#line 261
{_stencil_val(p.y,i,0,0); _stencil_val(p.y,i,0,0); {              
     _stencil_val(p.y,i,0,0);_stencil_val(Phi,i,0,0); 
          
     
   }      }}








{
 {_stencil_val(p.x,0,0,0);_stencil_val(p.y,0,0,0);_stencil_val(p.x,0,0,0);_stencil_val(p.y,0,0,0);_stencil_val_a(s_z,0,0,0);         }
{
 {_stencil_val_a(s_z,0,0,0);     } 
{

_stencil_val(p.x,0,0,0); _stencil_val(p.x,0,1,0); _stencil_val(p.y,0,0,0); _stencil_val(p.y,1,0,0); _stencil_val_a(s_z,0,0,0);       



      }}}
#line 274 "/home/pwachara/basilisk/src/fractions.h"
         
          
      
    







}}  
} 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);  
#line 199 "/home/pwachara/basilisk/src/fractions.h"
{    
#line 231 "/home/pwachara/basilisk/src/fractions.h"
    
    
     { 
_stencil_val(p.z,0,0,0); _stencil_val(p.z,0,1,0);    

} 
#line 233
{ 
_stencil_val(p.y,0,0,0); _stencil_val(p.y,0,0,1);    

}





{
      { _stencil_val(p.y,0,0,0);_stencil_val_a(s_x,0,0,0); } 
{      





      
   






      
      for (int i = 0; i <= 1; i++)
 {
   {_stencil_val(p.y,0,0,i); _stencil_val(p.y,0,0,i); {              
     _stencil_val(p.y,0,0,i);_stencil_val(Phi,0,0,i); 
          
     
   }      }   
#line 261
{_stencil_val(p.z,0,i,0); _stencil_val(p.z,0,i,0); {              
     _stencil_val(p.z,0,i,0);_stencil_val(Phi,0,i,0); 
          
     
   }      }}








{
 {_stencil_val(p.y,0,0,0);_stencil_val(p.z,0,0,0);_stencil_val(p.y,0,0,0);_stencil_val(p.z,0,0,0);_stencil_val_a(s_x,0,0,0);         }
{
 {_stencil_val_a(s_x,0,0,0);     } 
{

_stencil_val(p.y,0,0,0); _stencil_val(p.y,0,0,1); _stencil_val(p.z,0,0,0); _stencil_val(p.z,0,1,0); _stencil_val_a(s_x,0,0,0);       



      }}}
#line 274 "/home/pwachara/basilisk/src/fractions.h"
         
          
      
    







}}  
} 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);  
#line 199 "/home/pwachara/basilisk/src/fractions.h"
{    
#line 231 "/home/pwachara/basilisk/src/fractions.h"
    
    
     { 
_stencil_val(p.x,0,0,0); _stencil_val(p.x,0,0,1);    

} 
#line 233
{ 
_stencil_val(p.z,0,0,0); _stencil_val(p.z,1,0,0);    

}





{
      { _stencil_val(p.z,0,0,0);_stencil_val_a(s_y,0,0,0); } 
{      





      
   






      
      for (int i = 0; i <= 1; i++)
 {
   {_stencil_val(p.z,i,0,0); _stencil_val(p.z,i,0,0); {              
     _stencil_val(p.z,i,0,0);_stencil_val(Phi,i,0,0); 
          
     
   }      }   
#line 261
{_stencil_val(p.x,0,0,i); _stencil_val(p.x,0,0,i); {              
     _stencil_val(p.x,0,0,i);_stencil_val(Phi,0,0,i); 
          
     
   }      }}








{
 {_stencil_val(p.z,0,0,0);_stencil_val(p.x,0,0,0);_stencil_val(p.z,0,0,0);_stencil_val(p.x,0,0,0);_stencil_val_a(s_y,0,0,0);         }
{
 {_stencil_val_a(s_y,0,0,0);     } 
{

_stencil_val(p.z,0,0,0); _stencil_val(p.z,1,0,0); _stencil_val(p.x,0,0,0); _stencil_val(p.x,0,0,1); _stencil_val_a(s_y,0,0,0);       



      }}}
#line 274 "/home/pwachara/basilisk/src/fractions.h"
         
          
      
    







}}  
}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 194 "/home/pwachara/basilisk/src/fractions.h"
{
  
#line 400 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);  
#line 199 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 199 "/home/pwachara/basilisk/src/fractions.h"
{
#line 231 "/home/pwachara/basilisk/src/fractions.h"
    coord n;
    double nn = 0.;
     {
      n.x = val(p.y,0,0,0) - val(p.y,1,0,0);
      nn += fabs(n.x);
    } 
#line 233
{
      n.y = val(p.x,0,0,0) - val(p.x,0,1,0);
      nn += fabs(n.y);
    }





    if (nn == 0.)
      val(s_z,0,0,0) = val(p.x,0,0,0);
    else {





      
 n.x /= nn; n.y /= nn;






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (val(p.x,0,i,0) > 0. && val(p.x,0,i,0) < 1.) {
     double a = ( (int)((val(Phi,0,i,0) - val) > 0 ? 1 : -1))*(val(p.x,0,i,0) - 0.5);
     alpha += n.x*a + n.y*(i - 0.5);
     ni++;
   }   
#line 261
if (val(p.y,i,0,0) > 0. && val(p.y,i,0,0) < 1.) {
     double a = ( (int)((val(Phi,i,0,0) - val) > 0 ? 1 : -1))*(val(p.y,i,0,0) - 0.5);
     alpha += n.y*a + n.x*(i - 0.5);
     ni++;
   }}
#line 274 "/home/pwachara/basilisk/src/fractions.h"
      if (ni == 0)
 val(s_z,0,0,0) = ( (val(p.x,0,0,0)) > (val(p.y,0,0,0)) ? (val(p.x,0,0,0)) : (val(p.y,0,0,0)));
      else if (ni != 4)
 val(s_z,0,0,0) = line_area (n.x, n.y, alpha/ni);
      else {

 val(s_z,0,0,0) = (val(p.x,0,0,0) + val(p.x,0,1,0) + val(p.y,0,0,0) + val(p.y,1,0,0) > 2.);



      }
    }
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}  
#line 386
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);  
#line 199 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 199 "/home/pwachara/basilisk/src/fractions.h"
{
#line 231 "/home/pwachara/basilisk/src/fractions.h"
    coord n;
    double nn = 0.;
     {
      n.y = val(p.z,0,0,0) - val(p.z,0,1,0);
      nn += fabs(n.y);
    } 
#line 233
{
      n.z = val(p.y,0,0,0) - val(p.y,0,0,1);
      nn += fabs(n.z);
    }





    if (nn == 0.)
      val(s_x,0,0,0) = val(p.y,0,0,0);
    else {





      
 n.y /= nn; n.z /= nn;






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (val(p.y,0,0,i) > 0. && val(p.y,0,0,i) < 1.) {
     double a = ( (int)((val(Phi,0,0,i) - val) > 0 ? 1 : -1))*(val(p.y,0,0,i) - 0.5);
     alpha += n.y*a + n.z*(i - 0.5);
     ni++;
   }   
#line 261
if (val(p.z,0,i,0) > 0. && val(p.z,0,i,0) < 1.) {
     double a = ( (int)((val(Phi,0,i,0) - val) > 0 ? 1 : -1))*(val(p.z,0,i,0) - 0.5);
     alpha += n.z*a + n.y*(i - 0.5);
     ni++;
   }}
#line 274 "/home/pwachara/basilisk/src/fractions.h"
      if (ni == 0)
 val(s_x,0,0,0) = ( (val(p.y,0,0,0)) > (val(p.z,0,0,0)) ? (val(p.y,0,0,0)) : (val(p.z,0,0,0)));
      else if (ni != 4)
 val(s_x,0,0,0) = line_area (n.y, n.z, alpha/ni);
      else {

 val(s_x,0,0,0) = (val(p.y,0,0,0) + val(p.y,0,0,1) + val(p.z,0,0,0) + val(p.z,0,1,0) > 2.);



      }
    }
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);  
#line 199 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 199 "/home/pwachara/basilisk/src/fractions.h"
{
#line 231 "/home/pwachara/basilisk/src/fractions.h"
    coord n;
    double nn = 0.;
     {
      n.z = val(p.x,0,0,0) - val(p.x,0,0,1);
      nn += fabs(n.z);
    } 
#line 233
{
      n.x = val(p.z,0,0,0) - val(p.z,1,0,0);
      nn += fabs(n.x);
    }





    if (nn == 0.)
      val(s_y,0,0,0) = val(p.z,0,0,0);
    else {





      
 n.z /= nn; n.x /= nn;






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (val(p.z,i,0,0) > 0. && val(p.z,i,0,0) < 1.) {
     double a = ( (int)((val(Phi,i,0,0) - val) > 0 ? 1 : -1))*(val(p.z,i,0,0) - 0.5);
     alpha += n.z*a + n.x*(i - 0.5);
     ni++;
   }   
#line 261
if (val(p.x,0,0,i) > 0. && val(p.x,0,0,i) < 1.) {
     double a = ( (int)((val(Phi,0,0,i) - val) > 0 ? 1 : -1))*(val(p.x,0,0,i) - 0.5);
     alpha += n.x*a + n.z*(i - 0.5);
     ni++;
   }}
#line 274 "/home/pwachara/basilisk/src/fractions.h"
      if (ni == 0)
 val(s_y,0,0,0) = ( (val(p.z,0,0,0)) > (val(p.x,0,0,0)) ? (val(p.z,0,0,0)) : (val(p.x,0,0,0)));
      else if (ni != 4)
 val(s_y,0,0,0) = line_area (n.z, n.x, alpha/ni);
      else {

 val(s_y,0,0,0) = (val(p.z,0,0,0) + val(p.z,1,0,0) + val(p.x,0,0,0) + val(p.x,0,0,1) > 2.);



      }
    }
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 286 "/home/pwachara/basilisk/src/fractions.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/fractions.h", .line = 294, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 294 "/home/pwachara/basilisk/src/fractions.h"
{    




    
    
     { 
_stencil_val(as.x,0,0,0); _stencil_val(as.x,1,0,0);    

} 
#line 301
{ 
_stencil_val(as.y,0,0,0); _stencil_val(as.y,0,1,0);    

} 
#line 301
{ 
_stencil_val(as.z,0,0,0); _stencil_val(as.z,0,0,1);    

}
{
      { _stencil_val(as.x,0,0,0);_stencil_val_a(c,0,0,0); } 
{      
      
   






      
      for (int i = 0; i <= 1; i++)
 for (int j = 0; j <= 1; j++)
   {
     {_stencil_val(p.x,0,i,j); _stencil_val(p.x,0,i,j); {              
       _stencil_val(p.x,0,i,j);_stencil_val(Phi,0,i,j); 
                
       
     }      }     
#line 320
{_stencil_val(p.y,j,0,i); _stencil_val(p.y,j,0,i); {              
       _stencil_val(p.y,j,0,i);_stencil_val(Phi,j,0,i); 
                
       
     }      }     
#line 320
{_stencil_val(p.z,i,j,0); _stencil_val(p.z,i,j,0); {              
       _stencil_val(p.z,i,j,0);_stencil_val(Phi,i,j,0); 
                
       
     }      }}




{
 { _stencil_val(as.x,0,0,0);_stencil_val_a(c,0,0,0); }
{
 {_stencil_val_a(c,0,0,0);  }
 
{_stencil_val_a(c,0,0,0);    }}}    
}}  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 294 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 294 "/home/pwachara/basilisk/src/fractions.h"
{




    coord n;
    double nn = 0.;
     {
      n.x = val(as.x,0,0,0) - val(as.x,1,0,0);
      nn += fabs(n.x);
    } 
#line 301
{
      n.y = val(as.y,0,0,0) - val(as.y,0,1,0);
      nn += fabs(n.y);
    } 
#line 301
{
      n.z = val(as.z,0,0,0) - val(as.z,0,0,1);
      nn += fabs(n.z);
    }
    if (nn == 0.)
      val(c,0,0,0) = val(as.x,0,0,0);
    else {
      
 n.x /= nn; n.y /= nn; n.z /= nn;






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 for (int j = 0; j <= 1; j++)
   {
     if (val(p.x,0,i,j) > 0. && val(p.x,0,i,j) < 1.) {
       double a = ( (int)((val(Phi,0,i,j) - val) > 0 ? 1 : -1))*(val(p.x,0,i,j) - 0.5);
       alpha += n.x*a + n.y*(i - 0.5) + n.z*(j - 0.5);
       ni++;
     }     
#line 320
if (val(p.y,j,0,i) > 0. && val(p.y,j,0,i) < 1.) {
       double a = ( (int)((val(Phi,j,0,i) - val) > 0 ? 1 : -1))*(val(p.y,j,0,i) - 0.5);
       alpha += n.y*a + n.z*(i - 0.5) + n.x*(j - 0.5);
       ni++;
     }     
#line 320
if (val(p.z,i,j,0) > 0. && val(p.z,i,j,0) < 1.) {
       double a = ( (int)((val(Phi,i,j,0) - val) > 0 ? 1 : -1))*(val(p.z,i,j,0) - 0.5);
       alpha += n.z*a + n.x*(i - 0.5) + n.y*(j - 0.5);
       ni++;
     }}




      if (ni == 0)
 val(c,0,0,0) = val(as.x,0,0,0);
      else if (ni < 3 || ni > 6)
 val(c,0,0,0) = 0.;
      else
 val(c,0,0,0) = plane_volume (n, alpha/ni);
    }
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 336 "/home/pwachara/basilisk/src/fractions.h"
delete((scalar*)((vector[]){p,{{-1},{-1},{-1}}}));
#line 351 "/home/pwachara/basilisk/src/fractions.h"
end_tracing("fractions","/home/pwachara/basilisk/src/fractions.h",351);}





void macro_fraction (scalar f, double func)
{
  {
    scalar  phi=new_vertex_scalar("phi");    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/fractions.h", .line = 361, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
      
#line 362 "/home/pwachara/basilisk/src/fractions.h"
{_stencil_val_a(phi,0,0,0);  }  
#line 338 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 912 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
#line 300
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 913
{
    int ig = -1; NOT_UNUSED(ig);

    int jg = -1; NOT_UNUSED(jg);


    int kg = -1; NOT_UNUSED(kg);      
#line 362 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 362 "/home/pwachara/basilisk/src/fractions.h"
val(phi,0,0,0) = func;}
  
#line 922 "/home/pwachara/basilisk/src/grid/multigrid.h"
}      
#line 317
}
  }
}

#line 923
}    
#line 363 "/home/pwachara/basilisk/src/fractions.h"
fractions (phi, f
#line 121
,
(  vector) {0}, 0.
#line 363
);delete((scalar*)((scalar[]){phi,{-1}}));
  }
}

void macro_solid (scalar cs, vector fs, double func)
{
  {
    scalar  phi=new_vertex_scalar("phi");    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/fractions.h", .line = 371, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
      
#line 372 "/home/pwachara/basilisk/src/fractions.h"
{_stencil_val_a(phi,0,0,0);  }  
#line 338 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 912 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
#line 300
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 913
{
    int ig = -1; NOT_UNUSED(ig);

    int jg = -1; NOT_UNUSED(jg);


    int kg = -1; NOT_UNUSED(kg);      
#line 372 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 372 "/home/pwachara/basilisk/src/fractions.h"
val(phi,0,0,0) = func;}
  
#line 922 "/home/pwachara/basilisk/src/grid/multigrid.h"
}      
#line 317
}
  }
}

#line 923
}    
#line 373 "/home/pwachara/basilisk/src/fractions.h"
fractions (phi, cs, fs
#line 122
, 0.
#line 373
);delete((scalar*)((scalar[]){phi,{-1}}));
  }
}
#line 401 "/home/pwachara/basilisk/src/fractions.h"
coord youngs_normal (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 403 "/home/pwachara/basilisk/src/fractions.h"
coord n;
  double nn = 0.;
  if (!(3 == 2)) qassert ("/home/pwachara/basilisk/src/fractions.h", 405, "dimension == 2");
   {
    n.x = (val(c,-1,1,0) + 2.*val(c,-1,0,0) + val(c,-1,-1,0) -
    val(c,+1,1,0) - 2.*val(c,+1,0,0) - val(c,+1,-1,0));
    nn += fabs(n.x);
  } 
#line 406
{
    n.y = (val(c,0,-1,1) + 2.*val(c,0,-1,0) + val(c,0,-1,-1) -
    val(c,0,+1,1) - 2.*val(c,0,+1,0) - val(c,0,+1,-1));
    nn += fabs(n.y);
  } 
#line 406
{
    n.z = (val(c,1,0,-1) + 2.*val(c,0,0,-1) + val(c,-1,0,-1) -
    val(c,1,0,+1) - 2.*val(c,0,0,+1) - val(c,-1,0,+1));
    nn += fabs(n.z);
  }

  if (nn > 0.)
    {
      n.x /= nn;      n.y /= nn;      n.z /= nn;}
  else
    n.x = 1.;
  return n;
}





coord facet_normal (Point point, scalar c, vector s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 426 "/home/pwachara/basilisk/src/fractions.h"
if (s.x.i >= 0) {
    coord n;
    double nn = 0.;
     {
      n.x = val(s.x,0,0,0) - val(s.x,1,0,0);
      nn += fabs(n.x);
    } 
#line 429
{
      n.y = val(s.y,0,0,0) - val(s.y,0,1,0);
      nn += fabs(n.y);
    } 
#line 429
{
      n.z = val(s.z,0,0,0) - val(s.z,0,0,1);
      nn += fabs(n.z);
    }
    if (nn > 0.)
      {
 n.x /= nn; n.y /= nn; n.z /= nn;}
    else
      {
 n.x = 1./3; n.y = 1./3; n.z = 1./3;}
    return n;
  }
  return mycs (point, c);
}
#line 424
static void _stencil_facet_normal (Point point, scalar c, vector s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 426 "/home/pwachara/basilisk/src/fractions.h"
if (s.x.i >= 0) {    
    
    
     { 
_stencil_val(s.x,0,0,0); _stencil_val(s.x,1,0,0);    

} 
#line 429
{ 
_stencil_val(s.y,0,0,0); _stencil_val(s.y,0,1,0);    

} 
#line 429
{ 
_stencil_val(s.z,0,0,0); _stencil_val(s.z,0,0,1);    

}
      
   
       
    
       
  
    return ;
  } 
_stencil_mycs (point, c);  return;
}
#line 451 "/home/pwachara/basilisk/src/fractions.h"
     
void reconstruction (const scalar c, vector n, scalar alpha)
{tracing("reconstruction","/home/pwachara/basilisk/src/fractions.h",452);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/fractions.h", .line = 454, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 454 "/home/pwachara/basilisk/src/fractions.h"
{





_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);{ {
      _stencil_val_a(alpha,0,0,0);  
      
 {_stencil_val_a(n.x,0,0,0);  } {_stencil_val_a(n.y,0,0,0);  } {_stencil_val_a(n.z,0,0,0);  }
    } 
{  






       _stencil_mycs (point, c);
      
 {_stencil_val_a(n.x,0,0,0);  } {_stencil_val_a(n.y,0,0,0);  } {_stencil_val_a(n.z,0,0,0);  }
_stencil_val(c,0,0,0);      _stencil_val_a(alpha,0,0,0);    
    }}  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 454 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 454 "/home/pwachara/basilisk/src/fractions.h"
{





    if (val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) {
      val(alpha,0,0,0) = 0.;
      
 val(n.x,0,0,0) = 0.; val(n.y,0,0,0) = 0.; val(n.z,0,0,0) = 0.;
    }
    else {






      coord m = mycs (point, c);
      
 val(n.x,0,0,0) = m.x; val(n.y,0,0,0) = m.y; val(n.z,0,0,0) = m.z;
      val(alpha,0,0,0) = plane_alpha (val(c,0,0,0), m);
    }
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 495 "/home/pwachara/basilisk/src/fractions.h"
end_tracing("reconstruction","/home/pwachara/basilisk/src/fractions.h",495);}
#line 515 "/home/pwachara/basilisk/src/fractions.h"
     
void output_facets (scalar c, FILE * fp, vector s)
{tracing("output_facets","/home/pwachara/basilisk/src/fractions.h",516);
{  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/fractions.h", .line = 518, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 519 "/home/pwachara/basilisk/src/fractions.h"
{_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {  
       _stencil_facet_normal (point, c, s);     
      _stencil_val(c,0,0,0);        
#line 531 "/home/pwachara/basilisk/src/fractions.h"
      
                 
              
     
 
        
 

    }        }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 519 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 519 "/home/pwachara/basilisk/src/fractions.h"
if (val(c,0,0,0) > 1e-6 && val(c,0,0,0) < 1. - 1e-6) {
      coord n = facet_normal (point, c, s);
      double alpha = plane_alpha (val(c,0,0,0), n);
#line 531 "/home/pwachara/basilisk/src/fractions.h"
      coord v[12];
      int m = facets (n, alpha, v, 1.);
      for (int i = 0; i < m; i++)
 fprintf (fp, "%g %g %g\n",
   x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
      if (m > 0)
 fputc ('\n', fp);

    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 539 "/home/pwachara/basilisk/src/fractions.h"
}

  fflush (fp);
end_tracing("output_facets","/home/pwachara/basilisk/src/fractions.h",542);}







     
double interface_area (scalar c)
{tracing("interface_area","/home/pwachara/basilisk/src/fractions.h",551);
  double area = 0.;  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/fractions.h", .line = 554, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 555 "/home/pwachara/basilisk/src/fractions.h"
{_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {   
       _stencil_mycs (point, c);     
      _stencil_val(c,0,0,0); 
             
    }        }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:area)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 555 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 555 "/home/pwachara/basilisk/src/fractions.h"
if (val(c,0,0,0) > 1e-6 && val(c,0,0,0) < 1. - 1e-6) {
      coord n = mycs (point, c), p;
      double alpha = plane_alpha (val(c,0,0,0), n);
      area += pow(Delta, 3 - 1)*plane_area_center (n, alpha, &p);
    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 559 "/home/pwachara/basilisk/src/fractions.h"
{mpi_all_reduce_array(&area,MPI_DOUBLE,MPI_SUM,1);}
  {end_tracing("interface_area","/home/pwachara/basilisk/src/fractions.h",560);return area;}
end_tracing("interface_area","/home/pwachara/basilisk/src/fractions.h",561);}
#line 13 "/home/pwachara/basilisk/src/embed.h"






scalar  cs={0};
vector  fs={{1},{2},{3}};

double (* metric_embed_factor) (Point, coord) = NULL;
#line 95 "/home/pwachara/basilisk/src/embed.h"

static inline coord embed_face_barycentre_z (Point point, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 99 "/home/pwachara/basilisk/src/embed.h"
coord n1 = {0};
  double nn = 0.;
  scalar f = fs.z;
   {
    n1.x = (val(f,-1,-1,i) + 2.*val(f,-1,0,i) + val(f,-1,1,i) -
     val(f,+1,-1,i) - 2.*val(f,+1,0,i) - val(f,+1,1,i));
    nn += fabs(n1.x);
  } 
#line 102
{
    n1.y = (val(f,-1,-1,i) + 2.*val(f,0,-1,i) + val(f,1,-1,i) -
     val(f,-1,+1,i) - 2.*val(f,0,+1,i) - val(f,1,+1,i));
    nn += fabs(n1.y);
  }
  if (!nn)
    return (coord){0.,0.,0.};
  
    n1.x /= nn;    n1.y /= nn;

  coord n, p1, p;
  ((double *)&n)[0] = n1.x, ((double *)&n)[1] = n1.y;
  double alpha = line_alpha (val(f,0,0,i), n);
  line_center (n, alpha, val(f,0,0,i), &p1);
  p.x = ((double *)&p1)[0], p.y = ((double *)&p1)[1], p.z = 0.;
  return p;
}
#line 96
static inline coord embed_face_barycentre_x (Point point, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 99 "/home/pwachara/basilisk/src/embed.h"
coord n1 = {0};
  double nn = 0.;
  scalar f = fs.x;
   {
    n1.y = (val(f,i,-1,-1) + 2.*val(f,i,-1,0) + val(f,i,-1,1) -
     val(f,i,+1,-1) - 2.*val(f,i,+1,0) - val(f,i,+1,1));
    nn += fabs(n1.y);
  } 
#line 102
{
    n1.z = (val(f,i,-1,-1) + 2.*val(f,i,0,-1) + val(f,i,1,-1) -
     val(f,i,-1,+1) - 2.*val(f,i,0,+1) - val(f,i,1,+1));
    nn += fabs(n1.z);
  }
  if (!nn)
    return (coord){0.,0.,0.};
  
    n1.y /= nn;    n1.z /= nn;

  coord n, p1, p;
  ((double *)&n)[0] = n1.y, ((double *)&n)[1] = n1.z;
  double alpha = line_alpha (val(f,i,0,0), n);
  line_center (n, alpha, val(f,i,0,0), &p1);
  p.y = ((double *)&p1)[0], p.z = ((double *)&p1)[1], p.x = 0.;
  return p;
}
#line 96
static inline coord embed_face_barycentre_y (Point point, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 99 "/home/pwachara/basilisk/src/embed.h"
coord n1 = {0};
  double nn = 0.;
  scalar f = fs.y;
   {
    n1.z = (val(f,-1,i,-1) + 2.*val(f,0,i,-1) + val(f,1,i,-1) -
     val(f,-1,i,+1) - 2.*val(f,0,i,+1) - val(f,1,i,+1));
    nn += fabs(n1.z);
  } 
#line 102
{
    n1.x = (val(f,-1,i,-1) + 2.*val(f,-1,i,0) + val(f,-1,i,1) -
     val(f,+1,i,-1) - 2.*val(f,+1,i,0) - val(f,+1,i,1));
    nn += fabs(n1.x);
  }
  if (!nn)
    return (coord){0.,0.,0.};
  
    n1.z /= nn;    n1.x /= nn;

  coord n, p1, p;
  ((double *)&n)[0] = n1.z, ((double *)&n)[1] = n1.x;
  double alpha = line_alpha (val(f,0,i,0), n);
  line_center (n, alpha, val(f,0,i,0), &p1);
  p.z = ((double *)&p1)[0], p.x = ((double *)&p1)[1], p.y = 0.;
  return p;
}
#line 95 "/home/pwachara/basilisk/src/embed.h"

static void _stencil_embed_face_barycentre_z (Point point, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 101 "/home/pwachara/basilisk/src/embed.h"
scalar f = fs.z;
   {
_stencil_val(f,-1,-1,i);_stencil_val(f,-1,0,i); _stencil_val(f,-1,1,i);
     _stencil_val(f,+1,-1,i);_stencil_val(f,+1,0,i); _stencil_val(f,+1,1,i);  

} 
#line 102
{
_stencil_val(f,-1,-1,i);_stencil_val(f,0,-1,i); _stencil_val(f,1,-1,i);
     _stencil_val(f,-1,+1,i);_stencil_val(f,0,+1,i); _stencil_val(f,1,+1,i);  

}         
    
   
  
      

    
       
  _stencil_val(f,0,0,i); 
_stencil_val(f,0,0,i);  

return ;
}
#line 96
static void _stencil_embed_face_barycentre_x (Point point, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 101 "/home/pwachara/basilisk/src/embed.h"
scalar f = fs.x;
   {
_stencil_val(f,i,-1,-1);_stencil_val(f,i,-1,0); _stencil_val(f,i,-1,1);
     _stencil_val(f,i,+1,-1);_stencil_val(f,i,+1,0); _stencil_val(f,i,+1,1);  

} 
#line 102
{
_stencil_val(f,i,-1,-1);_stencil_val(f,i,0,-1); _stencil_val(f,i,1,-1);
     _stencil_val(f,i,-1,+1);_stencil_val(f,i,0,+1); _stencil_val(f,i,1,+1);  

}         
    
   
  
      

    
       
  _stencil_val(f,i,0,0); 
_stencil_val(f,i,0,0);  

return ;
}
#line 96
static void _stencil_embed_face_barycentre_y (Point point, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 101 "/home/pwachara/basilisk/src/embed.h"
scalar f = fs.y;
   {
_stencil_val(f,-1,i,-1);_stencil_val(f,0,i,-1); _stencil_val(f,1,i,-1);
     _stencil_val(f,-1,i,+1);_stencil_val(f,0,i,+1); _stencil_val(f,1,i,+1);  

} 
#line 102
{
_stencil_val(f,-1,i,-1);_stencil_val(f,-1,i,0); _stencil_val(f,-1,i,1);
     _stencil_val(f,+1,i,-1);_stencil_val(f,+1,i,0); _stencil_val(f,+1,i,1);  

}         
    
   
  
      

    
       
  _stencil_val(f,0,i,0); 
_stencil_val(f,0,i,0);  

return ;
}
#line 138 "/home/pwachara/basilisk/src/embed.h"

static inline double embed_face_gradient_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 141 "/home/pwachara/basilisk/src/embed.h"
if (!(val(cs,i,0,0) && val(cs,i-1,0,0))) qassert ("/home/pwachara/basilisk/src/embed.h", 141, "cs[i] && cs[i-1]");
  coord p = embed_face_barycentre_x (point, i);

  int j = ( (int)((p.y) > 0 ? 1 : -1)), k = ( (int)((p.z) > 0 ? 1 : -1));
  if ((val(fs.x,i,j,k) > 0.5 && (val(fs.x,i,j,0) > 0.5 || val(fs.x,i,0,k) > 0.5) && val(fs.y,i,j + (j < 0),0) && val(fs.y,i-1,j + (j < 0),0) && val(fs.y,i,j + (j < 0),k) && val(fs.y,i-1,j + (j < 0),k) && val(fs.z,i,0,k + (k < 0)) && val(fs.z,i-1,0,k + (k < 0)) && val(fs.z,i,j,k + (k < 0)) && val(fs.z,i-1,j,k + (k < 0)) && val(cs,i-1,j,0) && val(cs,i-1,0,k) && val(cs,i-1,j,k) && val(cs,i,j,0) && val(cs,i,0,k) && val(cs,i,j,k))) {
    p.y = fabs(p.y), p.z = fabs(p.z);
    return (((val(a,i,0,0) - val(a,i-1,0,0))*(1. - p.y) +
      (val(a,i,j,0) - val(a,i-1,j,0))*p.y)*(1. - p.z) +
     ((val(a,i,0,k) - val(a,i-1,0,k))*(1. - p.y) +
      (val(a,i,j,k) - val(a,i-1,j,k))*p.y)*p.z)/Delta;
  }
  return (val(a,i,0,0) - val(a,i-1,0,0))/Delta;
}
#line 139
static inline double embed_face_gradient_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 141 "/home/pwachara/basilisk/src/embed.h"
if (!(val(cs,0,i,0) && val(cs,0,i-1,0))) qassert ("/home/pwachara/basilisk/src/embed.h", 141, "cs[i] && cs[i-1]");
  coord p = embed_face_barycentre_y (point, i);

  int j = ( (int)((p.z) > 0 ? 1 : -1)), k = ( (int)((p.x) > 0 ? 1 : -1));
  if ((val(fs.y,k,i,j) > 0.5 && (val(fs.y,0,i,j) > 0.5 || val(fs.y,k,i,0) > 0.5) && val(fs.z,0,i,j + (j < 0)) && val(fs.z,0,i-1,j + (j < 0)) && val(fs.z,k,i,j + (j < 0)) && val(fs.z,k,i-1,j + (j < 0)) && val(fs.x,k + (k < 0),i,0) && val(fs.x,k + (k < 0),i-1,0) && val(fs.x,k + (k < 0),i,j) && val(fs.x,k + (k < 0),i-1,j) && val(cs,0,i-1,j) && val(cs,k,i-1,0) && val(cs,k,i-1,j) && val(cs,0,i,j) && val(cs,k,i,0) && val(cs,k,i,j))) {
    p.z = fabs(p.z), p.x = fabs(p.x);
    return (((val(a,0,i,0) - val(a,0,i-1,0))*(1. - p.z) +
      (val(a,0,i,j) - val(a,0,i-1,j))*p.z)*(1. - p.x) +
     ((val(a,k,i,0) - val(a,k,i-1,0))*(1. - p.z) +
      (val(a,k,i,j) - val(a,k,i-1,j))*p.z)*p.x)/Delta;
  }
  return (val(a,0,i,0) - val(a,0,i-1,0))/Delta;
}
#line 139
static inline double embed_face_gradient_z (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 141 "/home/pwachara/basilisk/src/embed.h"
if (!(val(cs,0,0,i) && val(cs,0,0,i-1))) qassert ("/home/pwachara/basilisk/src/embed.h", 141, "cs[i] && cs[i-1]");
  coord p = embed_face_barycentre_z (point, i);

  int j = ( (int)((p.x) > 0 ? 1 : -1)), k = ( (int)((p.y) > 0 ? 1 : -1));
  if ((val(fs.z,j,k,i) > 0.5 && (val(fs.z,j,0,i) > 0.5 || val(fs.z,0,k,i) > 0.5) && val(fs.x,j + (j < 0),0,i) && val(fs.x,j + (j < 0),0,i-1) && val(fs.x,j + (j < 0),k,i) && val(fs.x,j + (j < 0),k,i-1) && val(fs.y,0,k + (k < 0),i) && val(fs.y,0,k + (k < 0),i-1) && val(fs.y,j,k + (k < 0),i) && val(fs.y,j,k + (k < 0),i-1) && val(cs,j,0,i-1) && val(cs,0,k,i-1) && val(cs,j,k,i-1) && val(cs,j,0,i) && val(cs,0,k,i) && val(cs,j,k,i))) {
    p.x = fabs(p.x), p.y = fabs(p.y);
    return (((val(a,0,0,i) - val(a,0,0,i-1))*(1. - p.x) +
      (val(a,j,0,i) - val(a,j,0,i-1))*p.x)*(1. - p.y) +
     ((val(a,0,k,i) - val(a,0,k,i-1))*(1. - p.x) +
      (val(a,j,k,i) - val(a,j,k,i-1))*p.x)*p.y)/Delta;
  }
  return (val(a,0,0,i) - val(a,0,0,i-1))/Delta;
}
#line 138 "/home/pwachara/basilisk/src/embed.h"

static void _stencil_embed_face_gradient_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 141 "/home/pwachara/basilisk/src/embed.h"
_stencil_val(cs,i,0,0); _stencil_val(cs,i-1,0,0);   
_stencil_embed_face_barycentre_x (point, i);                    

  
_stencil_val(fs.x,i,o_stencil,o_stencil);_stencil_val(fs.x,i,o_stencil,0); _stencil_val(fs.x,i,0,o_stencil); _stencil_val(fs.y,i,o_stencil    ,0); _stencil_val(fs.y,i-1,o_stencil    ,0); _stencil_val(fs.y,i,o_stencil,    o_stencil); _stencil_val(fs.y,i-1,o_stencil,    o_stencil); _stencil_val(fs.z,i,0,o_stencil    ); _stencil_val(fs.z,i-1,0,o_stencil    ); _stencil_val(fs.z,i,o_stencil,o_stencil    ); _stencil_val(fs.z,i-1,o_stencil,o_stencil    ); _stencil_val(cs,i-1,o_stencil,0); _stencil_val(cs,i-1,0,o_stencil); _stencil_val(cs,i-1,o_stencil,o_stencil); _stencil_val(cs,i,o_stencil,0); _stencil_val(cs,i,0,o_stencil); _stencil_val(cs,i,o_stencil,o_stencil); {
         
_stencil_val(a,i,0,0); _stencil_val(a,i-1,0,0);
_stencil_val(a,i,o_stencil,0); _stencil_val(a,i-1,o_stencil,0);
_stencil_val(a,i,0,o_stencil); _stencil_val(a,i-1,0,o_stencil);
_stencil_val(a,i,o_stencil,o_stencil); _stencil_val(a,i-1,o_stencil,o_stencil);  
}
_stencil_val(a,i,0,0); _stencil_val(a,i-1,0,0);  return  ;
}
#line 139
static void _stencil_embed_face_gradient_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 141 "/home/pwachara/basilisk/src/embed.h"
_stencil_val(cs,0,i,0); _stencil_val(cs,0,i-1,0);   
_stencil_embed_face_barycentre_y (point, i);                    

  
_stencil_val(fs.y,o_stencil,i,o_stencil);_stencil_val(fs.y,0,i,o_stencil); _stencil_val(fs.y,o_stencil,i,0); _stencil_val(fs.z,0,i    ,o_stencil); _stencil_val(fs.z,0,i-1    ,o_stencil); _stencil_val(fs.z,    o_stencil,i,o_stencil); _stencil_val(fs.z,    o_stencil,i-1,o_stencil); _stencil_val(fs.x,o_stencil,i,0    ); _stencil_val(fs.x,o_stencil,i-1,0    ); _stencil_val(fs.x,o_stencil,i,o_stencil    ); _stencil_val(fs.x,o_stencil,i-1,o_stencil    ); _stencil_val(cs,0,i-1,o_stencil); _stencil_val(cs,o_stencil,i-1,0); _stencil_val(cs,o_stencil,i-1,o_stencil); _stencil_val(cs,0,i,o_stencil); _stencil_val(cs,o_stencil,i,0); _stencil_val(cs,o_stencil,i,o_stencil); {
         
_stencil_val(a,0,i,0); _stencil_val(a,0,i-1,0);
_stencil_val(a,0,i,o_stencil); _stencil_val(a,0,i-1,o_stencil);
_stencil_val(a,o_stencil,i,0); _stencil_val(a,o_stencil,i-1,0);
_stencil_val(a,o_stencil,i,o_stencil); _stencil_val(a,o_stencil,i-1,o_stencil);  
}
_stencil_val(a,0,i,0); _stencil_val(a,0,i-1,0);  return  ;
}
#line 139
static void _stencil_embed_face_gradient_z (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 141 "/home/pwachara/basilisk/src/embed.h"
_stencil_val(cs,0,0,i); _stencil_val(cs,0,0,i-1);   
_stencil_embed_face_barycentre_z (point, i);                    

  
_stencil_val(fs.z,o_stencil,o_stencil,i);_stencil_val(fs.z,o_stencil,0,i); _stencil_val(fs.z,0,o_stencil,i); _stencil_val(fs.x,o_stencil,0    ,i); _stencil_val(fs.x,o_stencil,0    ,i-1); _stencil_val(fs.x,o_stencil,    o_stencil,i); _stencil_val(fs.x,o_stencil,    o_stencil,i-1); _stencil_val(fs.y,0,o_stencil,i    ); _stencil_val(fs.y,0,o_stencil,i-1    ); _stencil_val(fs.y,o_stencil,o_stencil,i    ); _stencil_val(fs.y,o_stencil,o_stencil,i-1    ); _stencil_val(cs,o_stencil,0,i-1); _stencil_val(cs,0,o_stencil,i-1); _stencil_val(cs,o_stencil,o_stencil,i-1); _stencil_val(cs,o_stencil,0,i); _stencil_val(cs,0,o_stencil,i); _stencil_val(cs,o_stencil,o_stencil,i); {
         
_stencil_val(a,0,0,i); _stencil_val(a,0,0,i-1);
_stencil_val(a,o_stencil,0,i); _stencil_val(a,o_stencil,0,i-1);
_stencil_val(a,0,o_stencil,i); _stencil_val(a,0,o_stencil,i-1);
_stencil_val(a,o_stencil,o_stencil,i); _stencil_val(a,o_stencil,o_stencil,i-1);  
}
_stencil_val(a,0,0,i); _stencil_val(a,0,0,i-1);  return  ;
}


static inline double embed_face_value_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 158 "/home/pwachara/basilisk/src/embed.h"
coord p = embed_face_barycentre_x (point, i);

  int j = ( (int)((p.y) > 0 ? 1 : -1)), k = ( (int)((p.z) > 0 ? 1 : -1));
  if ((val(fs.x,i,j,k) > 0.5 && (val(fs.x,i,j,0) > 0.5 || val(fs.x,i,0,k) > 0.5) && val(fs.y,i,j + (j < 0),0) && val(fs.y,i-1,j + (j < 0),0) && val(fs.y,i,j + (j < 0),k) && val(fs.y,i-1,j + (j < 0),k) && val(fs.z,i,0,k + (k < 0)) && val(fs.z,i-1,0,k + (k < 0)) && val(fs.z,i,j,k + (k < 0)) && val(fs.z,i-1,j,k + (k < 0)) && val(cs,i-1,j,0) && val(cs,i-1,0,k) && val(cs,i-1,j,k) && val(cs,i,j,0) && val(cs,i,0,k) && val(cs,i,j,k))) {
    p.y = fabs(p.y), p.z = fabs(p.z);
    return ((((val(a,i,0,0)*(1.5 + val(cs,i,0,0)) + val(a,i-1,0,0)*(1.5 + val(cs,i-1,0,0)))/ (val(cs,i,0,0) + val(cs,i-1,0,0) + 3.))*(1. - p.y) + ((val(a,i,j,0)*(1.5 + val(cs,i,j,0)) + val(a,i-1,j,0)*(1.5 + val(cs,i-1,j,0)))/ (val(cs,i,j,0) + val(cs,i-1,j,0) + 3.))*p.y)*(1. - p.z) +
     (((val(a,i,0,k)*(1.5 + val(cs,i,0,k)) + val(a,i-1,0,k)*(1.5 + val(cs,i-1,0,k)))/ (val(cs,i,0,k) + val(cs,i-1,0,k) + 3.))*(1. - p.y) + ((val(a,i,j,k)*(1.5 + val(cs,i,j,k)) + val(a,i-1,j,k)*(1.5 + val(cs,i-1,j,k)))/ (val(cs,i,j,k) + val(cs,i-1,j,k) + 3.))*p.y)*p.z);
  }
  return ((val(a,i,0,0)*(1.5 + val(cs,i,0,0)) + val(a,i-1,0,0)*(1.5 + val(cs,i-1,0,0)))/ (val(cs,i,0,0) + val(cs,i-1,0,0) + 3.));
}
#line 156
static inline double embed_face_value_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 158 "/home/pwachara/basilisk/src/embed.h"
coord p = embed_face_barycentre_y (point, i);

  int j = ( (int)((p.z) > 0 ? 1 : -1)), k = ( (int)((p.x) > 0 ? 1 : -1));
  if ((val(fs.y,k,i,j) > 0.5 && (val(fs.y,0,i,j) > 0.5 || val(fs.y,k,i,0) > 0.5) && val(fs.z,0,i,j + (j < 0)) && val(fs.z,0,i-1,j + (j < 0)) && val(fs.z,k,i,j + (j < 0)) && val(fs.z,k,i-1,j + (j < 0)) && val(fs.x,k + (k < 0),i,0) && val(fs.x,k + (k < 0),i-1,0) && val(fs.x,k + (k < 0),i,j) && val(fs.x,k + (k < 0),i-1,j) && val(cs,0,i-1,j) && val(cs,k,i-1,0) && val(cs,k,i-1,j) && val(cs,0,i,j) && val(cs,k,i,0) && val(cs,k,i,j))) {
    p.z = fabs(p.z), p.x = fabs(p.x);
    return ((((val(a,0,i,0)*(1.5 + val(cs,0,i,0)) + val(a,0,i-1,0)*(1.5 + val(cs,0,i-1,0)))/ (val(cs,0,i,0) + val(cs,0,i-1,0) + 3.))*(1. - p.z) + ((val(a,0,i,j)*(1.5 + val(cs,0,i,j)) + val(a,0,i-1,j)*(1.5 + val(cs,0,i-1,j)))/ (val(cs,0,i,j) + val(cs,0,i-1,j) + 3.))*p.z)*(1. - p.x) +
     (((val(a,k,i,0)*(1.5 + val(cs,k,i,0)) + val(a,k,i-1,0)*(1.5 + val(cs,k,i-1,0)))/ (val(cs,k,i,0) + val(cs,k,i-1,0) + 3.))*(1. - p.z) + ((val(a,k,i,j)*(1.5 + val(cs,k,i,j)) + val(a,k,i-1,j)*(1.5 + val(cs,k,i-1,j)))/ (val(cs,k,i,j) + val(cs,k,i-1,j) + 3.))*p.z)*p.x);
  }
  return ((val(a,0,i,0)*(1.5 + val(cs,0,i,0)) + val(a,0,i-1,0)*(1.5 + val(cs,0,i-1,0)))/ (val(cs,0,i,0) + val(cs,0,i-1,0) + 3.));
}
#line 156
static inline double embed_face_value_z (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 158 "/home/pwachara/basilisk/src/embed.h"
coord p = embed_face_barycentre_z (point, i);

  int j = ( (int)((p.x) > 0 ? 1 : -1)), k = ( (int)((p.y) > 0 ? 1 : -1));
  if ((val(fs.z,j,k,i) > 0.5 && (val(fs.z,j,0,i) > 0.5 || val(fs.z,0,k,i) > 0.5) && val(fs.x,j + (j < 0),0,i) && val(fs.x,j + (j < 0),0,i-1) && val(fs.x,j + (j < 0),k,i) && val(fs.x,j + (j < 0),k,i-1) && val(fs.y,0,k + (k < 0),i) && val(fs.y,0,k + (k < 0),i-1) && val(fs.y,j,k + (k < 0),i) && val(fs.y,j,k + (k < 0),i-1) && val(cs,j,0,i-1) && val(cs,0,k,i-1) && val(cs,j,k,i-1) && val(cs,j,0,i) && val(cs,0,k,i) && val(cs,j,k,i))) {
    p.x = fabs(p.x), p.y = fabs(p.y);
    return ((((val(a,0,0,i)*(1.5 + val(cs,0,0,i)) + val(a,0,0,i-1)*(1.5 + val(cs,0,0,i-1)))/ (val(cs,0,0,i) + val(cs,0,0,i-1) + 3.))*(1. - p.x) + ((val(a,j,0,i)*(1.5 + val(cs,j,0,i)) + val(a,j,0,i-1)*(1.5 + val(cs,j,0,i-1)))/ (val(cs,j,0,i) + val(cs,j,0,i-1) + 3.))*p.x)*(1. - p.y) +
     (((val(a,0,k,i)*(1.5 + val(cs,0,k,i)) + val(a,0,k,i-1)*(1.5 + val(cs,0,k,i-1)))/ (val(cs,0,k,i) + val(cs,0,k,i-1) + 3.))*(1. - p.x) + ((val(a,j,k,i)*(1.5 + val(cs,j,k,i)) + val(a,j,k,i-1)*(1.5 + val(cs,j,k,i-1)))/ (val(cs,j,k,i) + val(cs,j,k,i-1) + 3.))*p.x)*p.y);
  }
  return ((val(a,0,0,i)*(1.5 + val(cs,0,0,i)) + val(a,0,0,i-1)*(1.5 + val(cs,0,0,i-1)))/ (val(cs,0,0,i) + val(cs,0,0,i-1) + 3.));
}
#line 156
static void _stencil_embed_face_value_x (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 158 "/home/pwachara/basilisk/src/embed.h"
_stencil_embed_face_barycentre_x (point, i);                    

  
_stencil_val(fs.x,i,o_stencil,o_stencil);_stencil_val(fs.x,i,o_stencil,0); _stencil_val(fs.x,i,0,o_stencil); _stencil_val(fs.y,i,o_stencil    ,0); _stencil_val(fs.y,i-1,o_stencil    ,0); _stencil_val(fs.y,i,o_stencil,    o_stencil); _stencil_val(fs.y,i-1,o_stencil,    o_stencil); _stencil_val(fs.z,i,0,o_stencil    ); _stencil_val(fs.z,i-1,0,o_stencil    ); _stencil_val(fs.z,i,o_stencil,o_stencil    ); _stencil_val(fs.z,i-1,o_stencil,o_stencil    ); _stencil_val(cs,i-1,o_stencil,0); _stencil_val(cs,i-1,0,o_stencil); _stencil_val(cs,i-1,o_stencil,o_stencil); _stencil_val(cs,i,o_stencil,0); _stencil_val(cs,i,0,o_stencil); _stencil_val(cs,i,o_stencil,o_stencil); {
         
_stencil_val(a,i,0,0); _stencil_val(cs,i,0,0); _stencil_val(a,i-1,0,0); _stencil_val(cs,i-1,0,0);_stencil_val(cs,i,0,0); _stencil_val(cs,i-1,0,0);_stencil_val(a,i,o_stencil,0); _stencil_val(cs,i,o_stencil,0); _stencil_val(a,i-1,o_stencil,0); _stencil_val(cs,i-1,o_stencil,0);_stencil_val(cs,i,o_stencil,0); _stencil_val(cs,i-1,o_stencil,0);
_stencil_val(a,i,0,o_stencil); _stencil_val(cs,i,0,o_stencil); _stencil_val(a,i-1,0,o_stencil); _stencil_val(cs,i-1,0,o_stencil);_stencil_val(cs,i,0,o_stencil); _stencil_val(cs,i-1,0,o_stencil);_stencil_val(a,i,o_stencil,o_stencil); _stencil_val(cs,i,o_stencil,o_stencil); _stencil_val(a,i-1,o_stencil,o_stencil); _stencil_val(cs,i-1,o_stencil,o_stencil);_stencil_val(cs,i,o_stencil,o_stencil); _stencil_val(cs,i-1,o_stencil,o_stencil);  
}
_stencil_val(a,i,0,0); _stencil_val(cs,i,0,0); _stencil_val(a,i-1,0,0); _stencil_val(cs,i-1,0,0);_stencil_val(cs,i,0,0); _stencil_val(cs,i-1,0,0);  return        ;
}
#line 156
static void _stencil_embed_face_value_y (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 158 "/home/pwachara/basilisk/src/embed.h"
_stencil_embed_face_barycentre_y (point, i);                    

  
_stencil_val(fs.y,o_stencil,i,o_stencil);_stencil_val(fs.y,0,i,o_stencil); _stencil_val(fs.y,o_stencil,i,0); _stencil_val(fs.z,0,i    ,o_stencil); _stencil_val(fs.z,0,i-1    ,o_stencil); _stencil_val(fs.z,    o_stencil,i,o_stencil); _stencil_val(fs.z,    o_stencil,i-1,o_stencil); _stencil_val(fs.x,o_stencil,i,0    ); _stencil_val(fs.x,o_stencil,i-1,0    ); _stencil_val(fs.x,o_stencil,i,o_stencil    ); _stencil_val(fs.x,o_stencil,i-1,o_stencil    ); _stencil_val(cs,0,i-1,o_stencil); _stencil_val(cs,o_stencil,i-1,0); _stencil_val(cs,o_stencil,i-1,o_stencil); _stencil_val(cs,0,i,o_stencil); _stencil_val(cs,o_stencil,i,0); _stencil_val(cs,o_stencil,i,o_stencil); {
         
_stencil_val(a,0,i,0); _stencil_val(cs,0,i,0); _stencil_val(a,0,i-1,0); _stencil_val(cs,0,i-1,0);_stencil_val(cs,0,i,0); _stencil_val(cs,0,i-1,0);_stencil_val(a,0,i,o_stencil); _stencil_val(cs,0,i,o_stencil); _stencil_val(a,0,i-1,o_stencil); _stencil_val(cs,0,i-1,o_stencil);_stencil_val(cs,0,i,o_stencil); _stencil_val(cs,0,i-1,o_stencil);
_stencil_val(a,o_stencil,i,0); _stencil_val(cs,o_stencil,i,0); _stencil_val(a,o_stencil,i-1,0); _stencil_val(cs,o_stencil,i-1,0);_stencil_val(cs,o_stencil,i,0); _stencil_val(cs,o_stencil,i-1,0);_stencil_val(a,o_stencil,i,o_stencil); _stencil_val(cs,o_stencil,i,o_stencil); _stencil_val(a,o_stencil,i-1,o_stencil); _stencil_val(cs,o_stencil,i-1,o_stencil);_stencil_val(cs,o_stencil,i,o_stencil); _stencil_val(cs,o_stencil,i-1,o_stencil);  
}
_stencil_val(a,0,i,0); _stencil_val(cs,0,i,0); _stencil_val(a,0,i-1,0); _stencil_val(cs,0,i-1,0);_stencil_val(cs,0,i,0); _stencil_val(cs,0,i-1,0);  return        ;
}
#line 156
static void _stencil_embed_face_value_z (Point point, scalar a, int i)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 158 "/home/pwachara/basilisk/src/embed.h"
_stencil_embed_face_barycentre_z (point, i);                    

  
_stencil_val(fs.z,o_stencil,o_stencil,i);_stencil_val(fs.z,o_stencil,0,i); _stencil_val(fs.z,0,o_stencil,i); _stencil_val(fs.x,o_stencil,0    ,i); _stencil_val(fs.x,o_stencil,0    ,i-1); _stencil_val(fs.x,o_stencil,    o_stencil,i); _stencil_val(fs.x,o_stencil,    o_stencil,i-1); _stencil_val(fs.y,0,o_stencil,i    ); _stencil_val(fs.y,0,o_stencil,i-1    ); _stencil_val(fs.y,o_stencil,o_stencil,i    ); _stencil_val(fs.y,o_stencil,o_stencil,i-1    ); _stencil_val(cs,o_stencil,0,i-1); _stencil_val(cs,0,o_stencil,i-1); _stencil_val(cs,o_stencil,o_stencil,i-1); _stencil_val(cs,o_stencil,0,i); _stencil_val(cs,0,o_stencil,i); _stencil_val(cs,o_stencil,o_stencil,i); {
         
_stencil_val(a,0,0,i); _stencil_val(cs,0,0,i); _stencil_val(a,0,0,i-1); _stencil_val(cs,0,0,i-1);_stencil_val(cs,0,0,i); _stencil_val(cs,0,0,i-1);_stencil_val(a,o_stencil,0,i); _stencil_val(cs,o_stencil,0,i); _stencil_val(a,o_stencil,0,i-1); _stencil_val(cs,o_stencil,0,i-1);_stencil_val(cs,o_stencil,0,i); _stencil_val(cs,o_stencil,0,i-1);
_stencil_val(a,0,o_stencil,i); _stencil_val(cs,0,o_stencil,i); _stencil_val(a,0,o_stencil,i-1); _stencil_val(cs,0,o_stencil,i-1);_stencil_val(cs,0,o_stencil,i); _stencil_val(cs,0,o_stencil,i-1);_stencil_val(a,o_stencil,o_stencil,i); _stencil_val(cs,o_stencil,o_stencil,i); _stencil_val(a,o_stencil,o_stencil,i-1); _stencil_val(cs,o_stencil,o_stencil,i-1);_stencil_val(cs,o_stencil,o_stencil,i); _stencil_val(cs,o_stencil,o_stencil,i-1);  
}
_stencil_val(a,0,0,i); _stencil_val(cs,0,0,i); _stencil_val(a,0,0,i-1); _stencil_val(cs,0,0,i-1);_stencil_val(cs,0,0,i); _stencil_val(cs,0,0,i-1);  return        ;
}
#line 177 "/home/pwachara/basilisk/src/embed.h"

#line 222 "/home/pwachara/basilisk/src/embed.h"
static inline
double embed_geometry (Point point, coord * p, coord * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 225 "/home/pwachara/basilisk/src/embed.h"
*n = facet_normal (point, cs, fs);
  double alpha = plane_alpha (val(cs,0,0,0), *n);
  double area = plane_area_center (*n, alpha, p);
  normalize (n);
  return area;
}
#line 222 "/home/pwachara/basilisk/src/embed.h"
static void 
_stencil_embed_geometry (Point point,_stencil_undefined * p,_stencil_undefined * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
#line 225 "/home/pwachara/basilisk/src/embed.h"
_stencil_facet_normal (point, cs, fs);  
_stencil_val(cs,0,0,0);      
   
  
  return ;
}





static inline
double embed_area_center (Point point, double * x1, double * y1, double * z1)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 239 "/home/pwachara/basilisk/src/embed.h"
double area = 0.;
  if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {
    coord n, p;
    area = embed_geometry (point, &p, &n);
    *x1 += p.x*Delta, *y1 += p.y*Delta, *z1 += p.z*Delta;
  }
  return area;
}
#line 255 "/home/pwachara/basilisk/src/embed.h"
double embed_interpolate (Point point, scalar s, coord p)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 257 "/home/pwachara/basilisk/src/embed.h"
if (!(3 == 2)) qassert ("/home/pwachara/basilisk/src/embed.h", 257, "dimension == 2");
  int i = ( (int)((p.x) > 0 ? 1 : -1)), j = ( (int)((p.y) > 0 ? 1 : -1));
  if (val(cs,i,0,0) && val(cs,0,j,0) && val(cs,i,j,0))

    return ((val(s,0,0,0)*(1. - fabs(p.x)) + val(s,i,0,0)*fabs(p.x))*(1. - fabs(p.y)) +
     (val(s,0,j,0)*(1. - fabs(p.x)) + val(s,i,j,0)*fabs(p.x))*fabs(p.y));
  else {


    double val = val(s,0,0,0);
     {
      int i = ( (int)((p.x) > 0 ? 1 : -1));
      if (val(cs,i,0,0))
 val += fabs(p.x)*(val(s,i,0,0) - val(s,0,0,0));
      else if (val(cs,-i,0,0))
 val += fabs(p.x)*(val(s,0,0,0) - val(s,-i,0,0));
    } 
#line 267
{
      int i = ( (int)((p.y) > 0 ? 1 : -1));
      if (val(cs,0,i,0))
 val += fabs(p.y)*(val(s,0,i,0) - val(s,0,0,0));
      else if (val(cs,0,-i,0))
 val += fabs(p.y)*(val(s,0,0,0) - val(s,0,-i,0));
    } 
#line 267
{
      int i = ( (int)((p.z) > 0 ? 1 : -1));
      if (val(cs,0,0,i))
 val += fabs(p.z)*(val(s,0,0,i) - val(s,0,0,0));
      else if (val(cs,0,0,-i))
 val += fabs(p.z)*(val(s,0,0,0) - val(s,0,0,-i));
    }
    return val;
  }
}
#line 255 "/home/pwachara/basilisk/src/embed.h"
static void _stencil_embed_interpolate (Point point, scalar s,_stencil_undefined * p)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;                       
      
  
#line 259 "/home/pwachara/basilisk/src/embed.h"
_stencil_val(cs,o_stencil,0,0); _stencil_val(cs,0,o_stencil,0); _stencil_val(cs,o_stencil,o_stencil,0);{

    {_stencil_val(s,0,0,0);_stencil_val(s, o_stencil,0,0);
_stencil_val(s,0,o_stencil,0); _stencil_val(s,o_stencil,o_stencil,0);      } 
{  


     _stencil_val(s,0,0,0);
     {          
      
_stencil_val(cs,o_stencil,0,0);{
 {_stencil_val(s,o_stencil,0,0); _stencil_val(s,0,0,0);   } 
{_stencil_val(cs,o_stencil,0,0);
 {_stencil_val(s,0,0,0);_stencil_val(s, o_stencil,0,0);   } }}    
} 
#line 267
{          
      
_stencil_val(cs,0,o_stencil,0);{
 {_stencil_val(s,0,o_stencil,0); _stencil_val(s,0,0,0);   } 
{_stencil_val(cs,0,o_stencil,0);
 {_stencil_val(s,0,0,0);_stencil_val(s,0, o_stencil,0);   } }}    
} 
#line 267
{          
      
_stencil_val(cs,0,0,o_stencil);{
 {_stencil_val(s,0,0,o_stencil); _stencil_val(s,0,0,0);   } 
{_stencil_val(cs,0,0,o_stencil);
 {_stencil_val(s,0,0,0);_stencil_val(s,0,0, o_stencil);   } }}    
} 
    
  }}
}
#line 285 "/home/pwachara/basilisk/src/embed.h"
struct Cleanup {
  scalar c;
  vector s;
  double smin;
  bool opposite;
};

     
int fractions_cleanup (scalar c, vector s,
         double smin, bool opposite)
{tracing("fractions_cleanup","/home/pwachara/basilisk/src/embed.h",293);







  int changed = 1, schanged = 0, i;
  for (i = 0; i < 100 && changed; i++) {
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/embed.h", .line = 309, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 309 "/home/pwachara/basilisk/src/embed.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);      
#line 310 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(s.x,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,-1,0,0); _stencil_val(s.x,0,0,0);
 {_stencil_val_a(s.x,0,0,0);  }        } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);      
#line 310 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(s.y,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,-1,0); _stencil_val(s.y,0,0,0);
 {_stencil_val_a(s.y,0,0,0);  }        } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);      
#line 310 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(s.z,0,0,0);_stencil_val(c,0,0,0);_stencil_val(c,0,0,-1); _stencil_val(s.z,0,0,0);
 {_stencil_val_a(s.z,0,0,0);  }        }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 309 "/home/pwachara/basilisk/src/embed.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);      
#line 310 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 310 "/home/pwachara/basilisk/src/embed.h"
if (val(s.x,0,0,0) && ((!val(c,0,0,0) || !val(c,-1,0,0)) || val(s.x,0,0,0) < smin))
 val(s.x,0,0,0) = 0.;}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);      
#line 310 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 310 "/home/pwachara/basilisk/src/embed.h"
if (val(s.y,0,0,0) && ((!val(c,0,0,0) || !val(c,0,-1,0)) || val(s.y,0,0,0) < smin))
 val(s.y,0,0,0) = 0.;}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);      
#line 310 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 310 "/home/pwachara/basilisk/src/embed.h"
if (val(s.z,0,0,0) && ((!val(c,0,0,0) || !val(c,0,0,-1)) || val(s.z,0,0,0) < smin))
 val(s.z,0,0,0) = 0.;}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 311 "/home/pwachara/basilisk/src/embed.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}    
#line 313 "/home/pwachara/basilisk/src/embed.h"
changed = 0;    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/embed.h", .line = 314, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);      
#line 315 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {   
 
  {
   for (int i = 0; i <= 1; i++)
     {_stencil_val(s.x,i,0,0);
          } 









_stencil_val(s.x,0,0,0); _stencil_val(s.x,1,0,0);
     {_stencil_val_a(c,0,0,0);   }
#line 330 "/home/pwachara/basilisk/src/embed.h"
          
 
} 
#line 317
{
   for (int i = 0; i <= 1; i++)
     {_stencil_val(s.y,0,i,0);
          } 









_stencil_val(s.y,0,0,0); _stencil_val(s.y,0,1,0);
     {_stencil_val_a(c,0,0,0);   }
#line 330 "/home/pwachara/basilisk/src/embed.h"
          
 
} 
#line 317
{
   for (int i = 0; i <= 1; i++)
     {_stencil_val(s.z,0,0,i);
          } 









_stencil_val(s.z,0,0,0); _stencil_val(s.z,0,0,1);
     {_stencil_val_a(c,0,0,0);   }
#line 330 "/home/pwachara/basilisk/src/embed.h"
          
 
}
   







{_stencil_val_a(c,0,0,0);   }      
}      }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:changed)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
      
#line 315 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 315 "/home/pwachara/basilisk/src/embed.h"
if (val(c,0,0,0) > 0. && val(c,0,0,0) < 1.) {
 int n = 0;
  {
   for (int i = 0; i <= 1; i++)
     if (val(s.x,i,0,0) > 0.)
       n++;
#line 330 "/home/pwachara/basilisk/src/embed.h"
   if (opposite && val(s.x,0,0,0) == 0. && val(s.x,1,0,0) == 0.)
     val(c,0,0,0) = 0., changed++;
 } 
#line 317
{
   for (int i = 0; i <= 1; i++)
     if (val(s.y,0,i,0) > 0.)
       n++;
#line 330 "/home/pwachara/basilisk/src/embed.h"
   if (opposite && val(s.y,0,0,0) == 0. && val(s.y,0,1,0) == 0.)
     val(c,0,0,0) = 0., changed++;
 } 
#line 317
{
   for (int i = 0; i <= 1; i++)
     if (val(s.z,0,0,i) > 0.)
       n++;
#line 330 "/home/pwachara/basilisk/src/embed.h"
   if (opposite && val(s.z,0,0,0) == 0. && val(s.z,0,0,1) == 0.)
     val(c,0,0,0) = 0., changed++;
 }







 if (n < 3)
   val(c,0,0,0) = 0., changed++;
      }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 342 "/home/pwachara/basilisk/src/embed.h"
{mpi_all_reduce_array(&changed,MPI_INT,MPI_SUM,1);}

    schanged += changed;
  }
  if (changed)
    fprintf (ferr, "src/embed.h:%d: warning: fractions_cleanup() did not converge after "
      "%d iterations\n", 348, i);
  {end_tracing("fractions_cleanup","/home/pwachara/basilisk/src/embed.h",349);return schanged;}
end_tracing("fractions_cleanup","/home/pwachara/basilisk/src/embed.h",350);}
#line 374 "/home/pwachara/basilisk/src/embed.h"

static inline double dirichlet_gradient_x (Point point, scalar s, scalar cs,
        coord n, coord p, double bc,
        double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
    
#line 380 "/home/pwachara/basilisk/src/embed.h"
n.x = - n.x;    n.y = - n.y;    n.z = - n.z;
  double d[2], v[2] = {1e30f,1e30f};
  bool defined = true;
  
    if (defined && !val(fs.x,(n.x > 0.),0,0))
      defined = false;    
#line 384
if (defined && !val(fs.y,0,(n.y > 0.),0))
      defined = false;    
#line 384
if (defined && !val(fs.z,0,0,(n.z > 0.)))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*( (int)((n.x) > 0 ? 1 : -1));
      d[l] = (i - p.x)/n.x;
      double y1 = p.y + d[l]*n.y;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;





      double z = p.z + d[l]*n.z;
      int k = z > 0.5 ? 1 : z < -0.5 ? -1 : 0;
      z -= k;
      bool defined = val(fs.x,i + (i < 0),j,k);
      for (int m = -1; m <= 1 && defined; m++)
 if (!val(fs.y,i,j,k+m) || !val(fs.y,i,j+1,k+m) ||
     !val(fs.z,i,j+m,k) || !val(fs.z,i,j+m,k+1) ||
     !val(cs,i,j+m,k-1) || !val(cs,i,j+m,k) || !val(cs,i,j+m,k+1))
   defined = false;
      if (defined)

 v[l] =
   (((((((val(s,i,j-1,k-1)))*((y1) - 1.) + ((val(s,i,j+1,k-1)))*((y1) + 1.))*(y1)/2. - ((val(s,i,j,k-1)))*((y1) - 1.)*((y1) + 1.)))*((z) - 1.) + (((((val(s,i,j-1,k+1)))*((y1) - 1.) + ((val(s,i,j+1,k+1)))*((y1) + 1.))*(y1)/2. - ((val(s,i,j,k+1)))*((y1) - 1.)*((y1) + 1.)))*((z) + 1.))*(z)/2. - (((((val(s,i,j-1,k)))*((y1) - 1.) + ((val(s,i,j+1,k)))*((y1) + 1.))*(y1)/2. - ((val(s,i,j,k)))*((y1) - 1.)*((y1) + 1.)))*((z) - 1.)*((z) + 1.))





                                                  ;

      else
 break;
    }
  if (v[0] == 1e30f) {





    d[0] = ( 1e-3 > (fabs(p.x/n.x)) ? 1e-3 : (fabs(p.x/n.x)));
    *coef = - 1./(d[0]*Delta);
    return bc/(d[0]*Delta);
  }





  *coef = 0.;
  if (v[1] != 1e30f)
    return (d[1]*(bc - v[0])/d[0] - d[0]*(bc - v[1])/d[1])/((d[1] - d[0])*Delta);
  return (bc - v[0])/(d[0]*Delta);
}
#line 375
static inline double dirichlet_gradient_y (Point point, scalar s, scalar cs,
        coord n, coord p, double bc,
        double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
    
#line 380 "/home/pwachara/basilisk/src/embed.h"
n.y = - n.y;    n.z = - n.z;    n.x = - n.x;
  double d[2], v[2] = {1e30f,1e30f};
  bool defined = true;
  
    if (defined && !val(fs.y,0,(n.y > 0.),0))
      defined = false;    
#line 384
if (defined && !val(fs.z,0,0,(n.z > 0.)))
      defined = false;    
#line 384
if (defined && !val(fs.x,(n.x > 0.),0,0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*( (int)((n.y) > 0 ? 1 : -1));
      d[l] = (i - p.y)/n.y;
      double y1 = p.z + d[l]*n.z;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;





      double z = p.x + d[l]*n.x;
      int k = z > 0.5 ? 1 : z < -0.5 ? -1 : 0;
      z -= k;
      bool defined = val(fs.y,k,i + (i < 0),j);
      for (int m = -1; m <= 1 && defined; m++)
 if (!val(fs.z,k+m,i,j) || !val(fs.z,k+m,i,j+1) ||
     !val(fs.x,k,i,j+m) || !val(fs.x,k+1,i,j+m) ||
     !val(cs,k-1,i,j+m) || !val(cs,k,i,j+m) || !val(cs,k+1,i,j+m))
   defined = false;
      if (defined)

 v[l] =
   (((((((val(s,k-1,i,j-1)))*((y1) - 1.) + ((val(s,k-1,i,j+1)))*((y1) + 1.))*(y1)/2. - ((val(s,k-1,i,j)))*((y1) - 1.)*((y1) + 1.)))*((z) - 1.) + (((((val(s,k+1,i,j-1)))*((y1) - 1.) + ((val(s,k+1,i,j+1)))*((y1) + 1.))*(y1)/2. - ((val(s,k+1,i,j)))*((y1) - 1.)*((y1) + 1.)))*((z) + 1.))*(z)/2. - (((((val(s,k,i,j-1)))*((y1) - 1.) + ((val(s,k,i,j+1)))*((y1) + 1.))*(y1)/2. - ((val(s,k,i,j)))*((y1) - 1.)*((y1) + 1.)))*((z) - 1.)*((z) + 1.))





                                                  ;

      else
 break;
    }
  if (v[0] == 1e30f) {





    d[0] = ( 1e-3 > (fabs(p.y/n.y)) ? 1e-3 : (fabs(p.y/n.y)));
    *coef = - 1./(d[0]*Delta);
    return bc/(d[0]*Delta);
  }





  *coef = 0.;
  if (v[1] != 1e30f)
    return (d[1]*(bc - v[0])/d[0] - d[0]*(bc - v[1])/d[1])/((d[1] - d[0])*Delta);
  return (bc - v[0])/(d[0]*Delta);
}
#line 375
static inline double dirichlet_gradient_z (Point point, scalar s, scalar cs,
        coord n, coord p, double bc,
        double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
    
#line 380 "/home/pwachara/basilisk/src/embed.h"
n.z = - n.z;    n.x = - n.x;    n.y = - n.y;
  double d[2], v[2] = {1e30f,1e30f};
  bool defined = true;
  
    if (defined && !val(fs.z,0,0,(n.z > 0.)))
      defined = false;    
#line 384
if (defined && !val(fs.x,(n.x > 0.),0,0))
      defined = false;    
#line 384
if (defined && !val(fs.y,0,(n.y > 0.),0))
      defined = false;
  if (defined)
    for (int l = 0; l <= 1; l++) {
      int i = (l + 1)*( (int)((n.z) > 0 ? 1 : -1));
      d[l] = (i - p.z)/n.z;
      double y1 = p.x + d[l]*n.x;
      int j = y1 > 0.5 ? 1 : y1 < -0.5 ? -1 : 0;
      y1 -= j;





      double z = p.y + d[l]*n.y;
      int k = z > 0.5 ? 1 : z < -0.5 ? -1 : 0;
      z -= k;
      bool defined = val(fs.z,j,k,i + (i < 0));
      for (int m = -1; m <= 1 && defined; m++)
 if (!val(fs.x,j,k+m,i) || !val(fs.x,j+1,k+m,i) ||
     !val(fs.y,j+m,k,i) || !val(fs.y,j+m,k+1,i) ||
     !val(cs,j+m,k-1,i) || !val(cs,j+m,k,i) || !val(cs,j+m,k+1,i))
   defined = false;
      if (defined)

 v[l] =
   (((((((val(s,j-1,k-1,i)))*((y1) - 1.) + ((val(s,j+1,k-1,i)))*((y1) + 1.))*(y1)/2. - ((val(s,j,k-1,i)))*((y1) - 1.)*((y1) + 1.)))*((z) - 1.) + (((((val(s,j-1,k+1,i)))*((y1) - 1.) + ((val(s,j+1,k+1,i)))*((y1) + 1.))*(y1)/2. - ((val(s,j,k+1,i)))*((y1) - 1.)*((y1) + 1.)))*((z) + 1.))*(z)/2. - (((((val(s,j-1,k,i)))*((y1) - 1.) + ((val(s,j+1,k,i)))*((y1) + 1.))*(y1)/2. - ((val(s,j,k,i)))*((y1) - 1.)*((y1) + 1.)))*((z) - 1.)*((z) + 1.))





                                                  ;

      else
 break;
    }
  if (v[0] == 1e30f) {





    d[0] = ( 1e-3 > (fabs(p.z/n.z)) ? 1e-3 : (fabs(p.z/n.z)));
    *coef = - 1./(d[0]*Delta);
    return bc/(d[0]*Delta);
  }





  *coef = 0.;
  if (v[1] != 1e30f)
    return (d[1]*(bc - v[0])/d[0] - d[0]*(bc - v[1])/d[1])/((d[1] - d[0])*Delta);
  return (bc - v[0])/(d[0]*Delta);
}
#line 374 "/home/pwachara/basilisk/src/embed.h"

static void _stencil_dirichlet_gradient_x (Point point, scalar s, scalar cs,
_stencil_undefined * n,_stencil_undefined * p,_stencil_undefined * bc,
_stencil_undefined * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;       
  
       
  
  
  
    
#line 384 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(fs.x,o_stencil,0,0  ); 
          }    
#line 384
{_stencil_val(fs.y,0,o_stencil,0  ); 
          }    
#line 384
{_stencil_val(fs.z,0,0,o_stencil  ); 
          }
    
for (int l = 0; l <= 1; l++) {                                                      
       
         
      
      
        





      
      
        
       _stencil_val(fs.x,    o_stencil,o_stencil,o_stencil);   
             
 {_stencil_val(fs.y,o_stencil,o_stencil,o_stencil);_stencil_val(fs.y,o_stencil,o_stencil,o_stencil);
_stencil_val(fs.z,o_stencil,o_stencil,o_stencil);_stencil_val(fs.z,o_stencil,o_stencil,o_stencil);
_stencil_val(cs,o_stencil,o_stencil,o_stencil);_stencil_val(cs,o_stencil,o_stencil,o_stencil);_stencil_val(cs,o_stencil,o_stencil,o_stencil);         
}
{

 {
_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);                                                  





}
 

}    
}         
     
   
     





   
     
  







return   ;
}
#line 375
static void _stencil_dirichlet_gradient_y (Point point, scalar s, scalar cs,
_stencil_undefined * n,_stencil_undefined * p,_stencil_undefined * bc,
_stencil_undefined * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;       
  
       
  
  
  
    
#line 384 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(fs.y,0,o_stencil,0  ); 
          }    
#line 384
{_stencil_val(fs.z,0,0,o_stencil  ); 
          }    
#line 384
{_stencil_val(fs.x,o_stencil,0,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                                                      
       
         
      
      
        





      
      
        
       _stencil_val(fs.y,o_stencil,    o_stencil,o_stencil);   
             
 {_stencil_val(fs.z,o_stencil,o_stencil,o_stencil);_stencil_val(fs.z,o_stencil,o_stencil,o_stencil);
_stencil_val(fs.x,o_stencil,o_stencil,o_stencil);_stencil_val(fs.x,o_stencil,o_stencil,o_stencil);
_stencil_val(cs,o_stencil,o_stencil,o_stencil);_stencil_val(cs,o_stencil,o_stencil,o_stencil);_stencil_val(cs,o_stencil,o_stencil,o_stencil);         
}
{

 {
_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);                                                  





}
 

}    
}         
     
   
     





   
     
  







return   ;
}
#line 375
static void _stencil_dirichlet_gradient_z (Point point, scalar s, scalar cs,
_stencil_undefined * n,_stencil_undefined * p,_stencil_undefined * bc,
_stencil_undefined * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;       
  
       
  
  
  
    
#line 384 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(fs.z,0,0,o_stencil  ); 
          }    
#line 384
{_stencil_val(fs.x,o_stencil,0,0  ); 
          }    
#line 384
{_stencil_val(fs.y,0,o_stencil,0  ); 
          }
    
for (int l = 0; l <= 1; l++) {                                                      
       
         
      
      
        





      
      
        
       _stencil_val(fs.z,o_stencil,o_stencil,    o_stencil);   
             
 {_stencil_val(fs.x,o_stencil,o_stencil,o_stencil);_stencil_val(fs.x,o_stencil,o_stencil,o_stencil);
_stencil_val(fs.y,o_stencil,o_stencil,o_stencil);_stencil_val(fs.y,o_stencil,o_stencil,o_stencil);
_stencil_val(cs,o_stencil,o_stencil,o_stencil);_stencil_val(cs,o_stencil,o_stencil,o_stencil);_stencil_val(cs,o_stencil,o_stencil,o_stencil);         
}
{

 {
_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);_stencil_val(s,o_stencil,o_stencil,o_stencil);                                                  





}
 

}    
}         
     
   
     





   
     
  







return   ;
}

double dirichlet_gradient (Point point, scalar s, scalar cs,
      coord n, coord p, double bc, double * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;





  
#line 450 "/home/pwachara/basilisk/src/embed.h"
if (fabs(n.x) >= fabs(n.y)) {
    if (fabs(n.x) >= fabs(n.z))
      return dirichlet_gradient_x (point, s, cs, n, p, bc, coef);
  }
  else if (fabs(n.y) >= fabs(n.z))
    return dirichlet_gradient_y (point, s, cs, n, p, bc, coef);
  return dirichlet_gradient_z (point, s, cs, n, p, bc, coef);

  return 1e30f;
}
#line 442
static void _stencil_dirichlet_gradient (Point point, scalar s, scalar cs,
_stencil_undefined * n,_stencil_undefined * p,_stencil_undefined * bc,_stencil_undefined * coef)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 450 "/home/pwachara/basilisk/src/embed.h"
{ {
      
{ _stencil_dirichlet_gradient_x (point, s, cs,NULL ,NULL ,NULL ,NULL );}  
}
    
{ _stencil_dirichlet_gradient_y (point, s, cs,NULL ,NULL ,NULL ,NULL );}} 
_stencil_dirichlet_gradient_z (point, s, cs,NULL ,NULL ,NULL ,NULL );  return;

  return ;
}

bid embed;
#line 470 "/home/pwachara/basilisk/src/embed.h"
static inline
coord embed_gradient (Point point, vector u, coord p, coord n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 473 "/home/pwachara/basilisk/src/embed.h"
coord dudn;
   {
    bool dirichlet = false;
    double vb = _attribute[u.x.i].boundary[embed] (point, point, u.x, &dirichlet);
    if (dirichlet) {
      double val;
      dudn.x = dirichlet_gradient (point, u.x, cs, n, p, vb, &val);
    }
    else
      dudn.x = vb;
    if (dudn.x == 1e30f)
      dudn.x = 0.;
  } 
#line 474
{
    bool dirichlet = false;
    double vb = _attribute[u.y.i].boundary[embed] (point, point, u.y, &dirichlet);
    if (dirichlet) {
      double val;
      dudn.y = dirichlet_gradient (point, u.y, cs, n, p, vb, &val);
    }
    else
      dudn.y = vb;
    if (dudn.y == 1e30f)
      dudn.y = 0.;
  } 
#line 474
{
    bool dirichlet = false;
    double vb = _attribute[u.z.i].boundary[embed] (point, point, u.z, &dirichlet);
    if (dirichlet) {
      double val;
      dudn.z = dirichlet_gradient (point, u.z, cs, n, p, vb, &val);
    }
    else
      dudn.z = vb;
    if (dudn.z == 1e30f)
      dudn.z = 0.;
  }
  return dudn;
}
#line 470 "/home/pwachara/basilisk/src/embed.h"
static void 
_stencil_embed_gradient (Point point, vector u,_stencil_undefined * p,_stencil_undefined * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
  
   
#line 474 "/home/pwachara/basilisk/src/embed.h"
{     
    
    default_stencil ( point,((scalar[]){ u.x,{-1}}) ); 
{ 
       
_stencil_dirichlet_gradient (point, u.x, cs,NULL ,NULL ,NULL ,NULL );    
}  




} 
#line 474
{     
    
    default_stencil ( point,((scalar[]){ u.y,{-1}}) ); 
{ 
       
_stencil_dirichlet_gradient (point, u.y, cs,NULL ,NULL ,NULL ,NULL );    
}  




} 
#line 474
{     
    
    default_stencil ( point,((scalar[]){ u.z,{-1}}) ); 
{ 
       
_stencil_dirichlet_gradient (point, u.z, cs,NULL ,NULL ,NULL ,NULL );    
}  




}
  return ;
}
#line 508 "/home/pwachara/basilisk/src/embed.h"
     
void embed_force (scalar p, vector u, vector mu, coord * Fp, coord * Fmu)
{tracing("embed_force","/home/pwachara/basilisk/src/embed.h",509);
  coord Fps = {0}, Fmus = {0};
  if(!is_constant(fm.x)){  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/embed.h", .line = 512, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 513 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); {    






      
       _stencil_embed_geometry (point,NULL ,NULL );   
            
      _stencil_embed_interpolate (point, p,NULL );
       
  
#line 534 "/home/pwachara/basilisk/src/embed.h"
      if (constant(mu.x) != 0.) {      
 
  { 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0); 
     _stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0); 
} 
#line 536
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0); 
     _stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0); 
} 
#line 536
{ 
_stencil_val(mu.z,0,0,0); _stencil_val(mu.z,0,0,1); 
     _stencil_val(fm.z,0,0,0); _stencil_val(fm.z,0,0,1); 
}  
      
#line 599 "/home/pwachara/basilisk/src/embed.h"
     
  _stencil_embed_gradient (point, u,NULL ,NULL );
  
         
      }
    }      }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:Fps) reduction(+:Fmus)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 513 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 513 "/home/pwachara/basilisk/src/embed.h"
if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {






      coord n, b;
      double area = embed_geometry (point, &b, &n);
      area *= pow (Delta, 3 - 1);
      double Fn = area*embed_interpolate (point, p, b);
      
 Fps.x += Fn*n.x; Fps.y += Fn*n.y; Fps.z += Fn*n.z;
#line 534 "/home/pwachara/basilisk/src/embed.h"
      if (constant(mu.x) != 0.) {
 double mua = 0., fa = 0.;
  {
   mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
   fa += val(fm.x,0,0,0) + val(fm.x,1,0,0);
 } 
#line 536
{
   mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
   fa += val(fm.y,0,0,0) + val(fm.y,0,1,0);
 } 
#line 536
{
   mua += val(mu.z,0,0,0) + val(mu.z,0,0,1);
   fa += val(fm.z,0,0,0) + val(fm.z,0,0,1);
 }
 mua /= fa;
#line 599 "/home/pwachara/basilisk/src/embed.h"
 if (!(3 == 2)) qassert ("/home/pwachara/basilisk/src/embed.h", 599, "dimension == 2");
 coord dudn = embed_gradient (point, u, b, n);
 
   Fmus.x -= area*mua*(dudn.x*(( (n.x)*(n.x)) + 1.) + dudn.y*n.x*n.y);   Fmus.y -= area*mua*(dudn.y*(( (n.y)*(n.y)) + 1.) + dudn.z*n.y*n.z);   Fmus.z -= area*mua*(dudn.z*(( (n.z)*(n.z)) + 1.) + dudn.x*n.z*n.x);
      }
    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 604 "/home/pwachara/basilisk/src/embed.h"
{mpi_all_reduce_array((double *)&Fmus,MPI_DOUBLE,MPI_SUM,sizeof(Fmus)/sizeof(double));mpi_all_reduce_array((double *)&Fps,MPI_DOUBLE,MPI_SUM,sizeof(Fps)/sizeof(double));}}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/embed.h", .line = 512, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 513 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0); {    






      
       _stencil_embed_geometry (point,NULL ,NULL );   
            
      _stencil_embed_interpolate (point, p,NULL );
       
  
#line 534 "/home/pwachara/basilisk/src/embed.h"
      if (constant(mu.x) != 0.) {      
 
  { 
_stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);
;; 
} 
#line 536
{ 
_stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);
;; 
} 
#line 536
{ 
_stencil_val(mu.z,0,0,0); _stencil_val(mu.z,0,0,1);
;; 
}  
      
#line 599 "/home/pwachara/basilisk/src/embed.h"
     
  _stencil_embed_gradient (point, u,NULL ,NULL );
  
         
      }
    }      }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:Fps) reduction(+:Fmus)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 513 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 513 "/home/pwachara/basilisk/src/embed.h"
if (val(cs,0,0,0) > 0. && val(cs,0,0,0) < 1.) {






      coord n, b;
      double area = embed_geometry (point, &b, &n);
      area *= pow (Delta, 3 - 1);
      double Fn = area*embed_interpolate (point, p, b);
      
 Fps.x += Fn*n.x; Fps.y += Fn*n.y; Fps.z += Fn*n.z;
#line 534 "/home/pwachara/basilisk/src/embed.h"
      if (constant(mu.x) != 0.) {
 double mua = 0., fa = 0.;
  {
   mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
   fa += _const_fm.x + _const_fm.x;
 } 
#line 536
{
   mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
   fa += _const_fm.y + _const_fm.y;
 } 
#line 536
{
   mua += val(mu.z,0,0,0) + val(mu.z,0,0,1);
   fa += _const_fm.z + _const_fm.z;
 }
 mua /= fa;
#line 599 "/home/pwachara/basilisk/src/embed.h"
 if (!(3 == 2)) qassert ("/home/pwachara/basilisk/src/embed.h", 599, "dimension == 2");
 coord dudn = embed_gradient (point, u, b, n);
 
   Fmus.x -= area*mua*(dudn.x*(( (n.x)*(n.x)) + 1.) + dudn.y*n.x*n.y);   Fmus.y -= area*mua*(dudn.y*(( (n.y)*(n.y)) + 1.) + dudn.z*n.y*n.z);   Fmus.z -= area*mua*(dudn.z*(( (n.z)*(n.z)) + 1.) + dudn.x*n.z*n.x);
      }
    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 604 "/home/pwachara/basilisk/src/embed.h"
{mpi_all_reduce_array((double *)&Fmus,MPI_DOUBLE,MPI_SUM,sizeof(Fmus)/sizeof(double));mpi_all_reduce_array((double *)&Fps,MPI_DOUBLE,MPI_SUM,sizeof(Fps)/sizeof(double));}}

  *Fp = Fps; *Fmu = Fmus;
end_tracing("embed_force","/home/pwachara/basilisk/src/embed.h",607);}
#line 655 "/home/pwachara/basilisk/src/embed.h"
double embed_flux (Point point, scalar s, vector mu, double * val)
{if(!is_constant(fm.x)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;





  
#line 662 "/home/pwachara/basilisk/src/embed.h"
*val = 0.;
  if (val(cs,0,0,0) >= 1. || val(cs,0,0,0) <= 0.)
    return 0.;





  bool dirichlet = false;
  double grad = _attribute[s.i].boundary[embed] (point, point, s, &dirichlet);
  if (!grad && !dirichlet)
    return 0.;





  coord n = facet_normal (point, cs, fs), p;
  double alpha = plane_alpha (val(cs,0,0,0), n);
  double area = plane_area_center (n, alpha, &p);
  if (metric_embed_factor)
    area *= metric_embed_factor (point, p);





  double coef = 0.;
  if (dirichlet) {
    normalize (&n);
    grad = dirichlet_gradient (point, s, cs, n, p, grad, &coef);
  }




  double mua = 0., fa = 0.;
   {
    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
    fa += val(fm.x,0,0,0) + val(fm.x,1,0,0);
  } 
#line 699
{
    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
    fa += val(fm.y,0,0,0) + val(fm.y,0,1,0);
  } 
#line 699
{
    mua += val(mu.z,0,0,0) + val(mu.z,0,0,1);
    fa += val(fm.z,0,0,0) + val(fm.z,0,0,1);
  }
  *val = - mua/(fa + 1e-30)*grad*area/Delta;
  return - mua/(fa + 1e-30)*coef*area/Delta;
}}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
#line 656
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;





  
#line 662 "/home/pwachara/basilisk/src/embed.h"
*val = 0.;
  if (val(cs,0,0,0) >= 1. || val(cs,0,0,0) <= 0.)
    return 0.;





  bool dirichlet = false;
  double grad = _attribute[s.i].boundary[embed] (point, point, s, &dirichlet);
  if (!grad && !dirichlet)
    return 0.;





  coord n = facet_normal (point, cs, fs), p;
  double alpha = plane_alpha (val(cs,0,0,0), n);
  double area = plane_area_center (n, alpha, &p);
  if (metric_embed_factor)
    area *= metric_embed_factor (point, p);





  double coef = 0.;
  if (dirichlet) {
    normalize (&n);
    grad = dirichlet_gradient (point, s, cs, n, p, grad, &coef);
  }




  double mua = 0., fa = 0.;
   {
    mua += val(mu.x,0,0,0) + val(mu.x,1,0,0);
    fa += _const_fm.x + _const_fm.x;
  } 
#line 699
{
    mua += val(mu.y,0,0,0) + val(mu.y,0,1,0);
    fa += _const_fm.y + _const_fm.y;
  } 
#line 699
{
    mua += val(mu.z,0,0,0) + val(mu.z,0,0,1);
    fa += _const_fm.z + _const_fm.z;
  }
  *val = - mua/(fa + 1e-30)*grad*area/Delta;
  return - mua/(fa + 1e-30)*coef*area/Delta;
}}}

#line 714 "/home/pwachara/basilisk/src/embed.h"

double macro2_dirichlet (double expr, Point point,
    scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 718 "/home/pwachara/basilisk/src/embed.h"
return data ? embed_area_center (point, &x, &y, &z),
    *((bool *)data) = true, expr : 2.*expr - val(s,0,0,0);
}


double macro2_dirichlet_homogeneous (double expr, Point point,
         scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 726 "/home/pwachara/basilisk/src/embed.h"
return data ? *((bool *)data) = true, 0 : - val(s,0,0,0);
}


double macro2_neumann (double expr, Point point,
  scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 733 "/home/pwachara/basilisk/src/embed.h"
return data ? embed_area_center (point, &x, &y, &z),
    *((bool *)data) = false, expr : Delta*expr + val(s,0,0,0);
}


double macro2_neumann_homogeneous (double expr, Point point,
       scalar s, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 741 "/home/pwachara/basilisk/src/embed.h"
return data ? *((bool *)data) = false, 0 : val(s,0,0,0);
}
#line 753 "/home/pwachara/basilisk/src/embed.h"
static inline double bilinear_embed (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 755 "/home/pwachara/basilisk/src/embed.h"
if (!coarse(cs,0,0,0) || !coarse(cs,child.x,0,0))
    return coarse(s,0,0,0);

  if (!coarse(cs,0,child.y,0) || !coarse(cs,child.x,child.y,0))
    return coarse(s,0,0,0);


  if (!coarse(cs,0,0,child.z) || !coarse(cs,child.x,0,child.z) ||
      !coarse(cs,0,child.y,child.z) ||
      !coarse(cs,child.x,child.y,child.z))
    return coarse(s,0,0,0);

  return bilinear (point, s);
}
#line 753 "/home/pwachara/basilisk/src/embed.h"
static void _stencil_bilinear_embed (Point point, scalar s)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 755 "/home/pwachara/basilisk/src/embed.h"
_stencil_coarse(cs,0,0,0);_stencil_coarse(cs,o_stencil,0,0);
    { _stencil_coarse(s,0,0,0);}

_stencil_coarse(cs,0,o_stencil,0);_stencil_coarse(cs,o_stencil,o_stencil,0);
    { _stencil_coarse(s,0,0,0);}


_stencil_coarse(cs,0,0,o_stencil);_stencil_coarse(cs,o_stencil,0,o_stencil);
_stencil_coarse(cs,0,o_stencil,o_stencil);
_stencil_coarse(cs,o_stencil,o_stencil,o_stencil);
    { _stencil_coarse(s,0,0,0);} 

_stencil_bilinear (point, s);  return;
}
#line 800 "/home/pwachara/basilisk/src/embed.h"
     
void update_tracer (scalar f, vector uf, vector flux, double dt)
{tracing("update_tracer","/home/pwachara/basilisk/src/embed.h",801);
#line 812 "/home/pwachara/basilisk/src/embed.h"
  scalar  e=new_scalar("e");
  if(!is_constant(cm)){  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/embed.h", .line = 813, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 813 "/home/pwachara/basilisk/src/embed.h"
{




_stencil_val(cs,0,0,0);{
      {_stencil_val_a(e,0,0,0);  } 






{_stencil_val(cs,0,0,0);{ {
      
 {_stencil_val(flux.x,0,0,0); _stencil_val(flux.x,1,0,0);_stencil_val_r(f,0,0,0);   } {_stencil_val(flux.y,0,0,0); _stencil_val(flux.y,0,1,0);_stencil_val_r(f,0,0,0);   } {_stencil_val(flux.z,0,0,0); _stencil_val(flux.z,0,0,1);_stencil_val_r(f,0,0,0);   }
      _stencil_val_a(e,0,0,0);  
    } 
#line 841
{   
      
      for (int i = 0; i <= 1; i++)
 {
   {_stencil_val(uf.x,i,0,0);
     {_stencil_val(uf.x,i,0,0);  }   }   
#line 845
{_stencil_val(uf.y,0,i,0);
     {_stencil_val(uf.y,0,i,0);  }   }   
#line 845
{_stencil_val(uf.z,0,0,i);
     {_stencil_val(uf.z,0,0,i);  }   }}     
      _stencil_val(cm,0,0,0);   




      
      
 { _stencil_val(flux.x,0,0,0); _stencil_val(flux.x,1,0,0);  } { _stencil_val(flux.y,0,0,0); _stencil_val(flux.y,0,1,0);  } { _stencil_val(flux.z,0,0,0); _stencil_val(flux.z,0,0,1);  }
_stencil_val(cm,0,0,0);






{ {
 _stencil_val_r(f,0,0,0);  
 _stencil_val_a(e,0,0,0);  
      } 







{
 _stencil_val_r(f,0,0,0); 
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
   
#line 877 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val(cm,0,0,0);_stencil_val(cm,0,0,0);   } 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
#line 878 "/home/pwachara/basilisk/src/embed.h"
_stencil_val(cm,0,0,0); _stencil_val_a(e,0,0,0);    
      }}    
}}   
#line 841 "/home/pwachara/basilisk/src/embed.h"
    
#line 880
}}  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 813 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 813 "/home/pwachara/basilisk/src/embed.h"
{




    if (val(cs,0,0,0) <= 0.)
      val(e,0,0,0) = 0.;






    else if (val(cs,0,0,0) >= 1.) {
      
 val(f,0,0,0) += dt*(val(flux.x,0,0,0) - val(flux.x,1,0,0))/Delta; val(f,0,0,0) += dt*(val(flux.y,0,0,0) - val(flux.y,0,1,0))/Delta; val(f,0,0,0) += dt*(val(flux.z,0,0,0) - val(flux.z,0,0,1))/Delta;
      val(e,0,0,0) = 0.;
    }
#line 841 "/home/pwachara/basilisk/src/embed.h"
    else {
      double umax = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (fabs(val(uf.x,i,0,0)) > umax)
     umax = fabs(val(uf.x,i,0,0));   
#line 845
if (fabs(val(uf.y,0,i,0)) > umax)
     umax = fabs(val(uf.y,0,i,0));   
#line 845
if (fabs(val(uf.z,0,0,i)) > umax)
     umax = fabs(val(uf.z,0,0,i));}
      double dtmax = Delta*val(cm,0,0,0)/(umax + 1e-30);




      double F = 0.;
      
 F += val(flux.x,0,0,0) - val(flux.x,1,0,0); F += val(flux.y,0,0,0) - val(flux.y,0,1,0); F += val(flux.z,0,0,0) - val(flux.z,0,0,1);
      F /= Delta*val(cm,0,0,0);






      if (dt <= dtmax) {
 val(f,0,0,0) += dt*F;
 val(e,0,0,0) = 0.;
      }







      else {
 val(f,0,0,0) += dtmax*F;
 double scs = 0.; 
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
   
#line 877 "/home/pwachara/basilisk/src/embed.h"
scs += ( (val(cm,0,0,0))*(val(cm,0,0,0))); 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
 
#line 878 "/home/pwachara/basilisk/src/embed.h"
val(e,0,0,0) = (dt - dtmax)*F*val(cm,0,0,0)/scs;
      }
    }
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 881 "/home/pwachara/basilisk/src/embed.h"
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/embed.h", .line = 813, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 813 "/home/pwachara/basilisk/src/embed.h"
{




_stencil_val(cs,0,0,0);{
      {_stencil_val_a(e,0,0,0);  } 






{_stencil_val(cs,0,0,0);{ {
      
 {_stencil_val(flux.x,0,0,0); _stencil_val(flux.x,1,0,0);_stencil_val_r(f,0,0,0);   } {_stencil_val(flux.y,0,0,0); _stencil_val(flux.y,0,1,0);_stencil_val_r(f,0,0,0);   } {_stencil_val(flux.z,0,0,0); _stencil_val(flux.z,0,0,1);_stencil_val_r(f,0,0,0);   }
      _stencil_val_a(e,0,0,0);  
    } 
#line 841
{   
      
      for (int i = 0; i <= 1; i++)
 {
   {_stencil_val(uf.x,i,0,0);
     {_stencil_val(uf.x,i,0,0);  }   }   
#line 845
{_stencil_val(uf.y,0,i,0);
     {_stencil_val(uf.y,0,i,0);  }   }   
#line 845
{_stencil_val(uf.z,0,0,i);
     {_stencil_val(uf.z,0,0,i);  }   }}
;   




      
      
 { _stencil_val(flux.x,0,0,0); _stencil_val(flux.x,1,0,0);  } { _stencil_val(flux.y,0,0,0); _stencil_val(flux.y,0,1,0);  } { _stencil_val(flux.z,0,0,0); _stencil_val(flux.z,0,0,1);  }
;






{ {
 _stencil_val_r(f,0,0,0);  
 _stencil_val_a(e,0,0,0);  
      } 







{
 _stencil_val_r(f,0,0,0); 
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
   
#line 877 "/home/pwachara/basilisk/src/embed.h"
{;;   } 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
#line 878 "/home/pwachara/basilisk/src/embed.h"
; _stencil_val_a(e,0,0,0);    
      }}    
}}   
#line 841 "/home/pwachara/basilisk/src/embed.h"
    
#line 880
}}  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 813 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 813 "/home/pwachara/basilisk/src/embed.h"
{




    if (val(cs,0,0,0) <= 0.)
      val(e,0,0,0) = 0.;






    else if (val(cs,0,0,0) >= 1.) {
      
 val(f,0,0,0) += dt*(val(flux.x,0,0,0) - val(flux.x,1,0,0))/Delta; val(f,0,0,0) += dt*(val(flux.y,0,0,0) - val(flux.y,0,1,0))/Delta; val(f,0,0,0) += dt*(val(flux.z,0,0,0) - val(flux.z,0,0,1))/Delta;
      val(e,0,0,0) = 0.;
    }
#line 841 "/home/pwachara/basilisk/src/embed.h"
    else {
      double umax = 0.;
      for (int i = 0; i <= 1; i++)
 {
   if (fabs(val(uf.x,i,0,0)) > umax)
     umax = fabs(val(uf.x,i,0,0));   
#line 845
if (fabs(val(uf.y,0,i,0)) > umax)
     umax = fabs(val(uf.y,0,i,0));   
#line 845
if (fabs(val(uf.z,0,0,i)) > umax)
     umax = fabs(val(uf.z,0,0,i));}
      double dtmax = Delta*_const_cm/(umax + 1e-30);




      double F = 0.;
      
 F += val(flux.x,0,0,0) - val(flux.x,1,0,0); F += val(flux.y,0,0,0) - val(flux.y,0,1,0); F += val(flux.z,0,0,0) - val(flux.z,0,0,1);
      F /= Delta*_const_cm;






      if (dt <= dtmax) {
 val(f,0,0,0) += dt*F;
 val(e,0,0,0) = 0.;
      }







      else {
 val(f,0,0,0) += dtmax*F;
 double scs = 0.; 
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
   
#line 877 "/home/pwachara/basilisk/src/embed.h"
scs += ( (_const_cm)*(_const_cm)); 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
 
#line 878 "/home/pwachara/basilisk/src/embed.h"
val(e,0,0,0) = (dt - dtmax)*F*_const_cm/scs;
      }
    }
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 881 "/home/pwachara/basilisk/src/embed.h"
}  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/embed.h", .line = 887, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 887 "/home/pwachara/basilisk/src/embed.h"
{    
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
      
#line 890 "/home/pwachara/basilisk/src/embed.h"
{ _stencil_val(e,0,0,0); } 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  } 
#line 891 "/home/pwachara/basilisk/src/embed.h"
_stencil_val(cs,0,0,0);    _stencil_val_r(f,0,0,0); 
  }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 887 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 887 "/home/pwachara/basilisk/src/embed.h"
{
    double se = 0.;    
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
      
#line 890 "/home/pwachara/basilisk/src/embed.h"
se += val(e,0,0,0); 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
    
#line 891 "/home/pwachara/basilisk/src/embed.h"
val(f,0,0,0) += val(cs,0,0,0)*se;
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 892 "/home/pwachara/basilisk/src/embed.h"
delete((scalar*)((scalar[]){e,{-1}}));
end_tracing("update_tracer","/home/pwachara/basilisk/src/embed.h",893);}
#line 906
static int metric_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}
#line 906 "/home/pwachara/basilisk/src/embed.h"
      static int metric(const int i,const double t,Event *_ev){tracing("metric","/home/pwachara/basilisk/src/embed.h",906);
{
  if (is_constant (fm.x)) {
    
      if (!(constant (fm.x) == 1.)) qassert ("/home/pwachara/basilisk/src/embed.h", 910, "constant (fm.x) == 1.");      if (!(constant (fm.y) == 1.)) qassert ("/home/pwachara/basilisk/src/embed.h", 910, "constant (fm.x) == 1.");      if (!(constant (fm.z) == 1.)) qassert ("/home/pwachara/basilisk/src/embed.h", 910, "constant (fm.x) == 1.");
    fm = fs;
  }  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/embed.h", .line = 913, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 913 "/home/pwachara/basilisk/src/embed.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 914 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val_a(fs.x,0,0,0);  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 914 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val_a(fs.y,0,0,0);  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 914 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val_a(fs.z,0,0,0);  }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 913 "/home/pwachara/basilisk/src/embed.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 914 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 914 "/home/pwachara/basilisk/src/embed.h"
val(fs.x,0,0,0) = 1.;}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 914 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 914 "/home/pwachara/basilisk/src/embed.h"
val(fs.y,0,0,0) = 1.;}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 914 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 914 "/home/pwachara/basilisk/src/embed.h"
val(fs.z,0,0,0) = 1.;}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 914 "/home/pwachara/basilisk/src/embed.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
  
#line 915 "/home/pwachara/basilisk/src/embed.h"
if (is_constant (cm)) {
    if (!(constant (cm) == 1.)) qassert ("/home/pwachara/basilisk/src/embed.h", 916, "constant (cm) == 1.");
    cm = cs;
  }  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/embed.h", .line = 919, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 920 "/home/pwachara/basilisk/src/embed.h"
{_stencil_val_a(cs,0,0,0);  }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 920 "/home/pwachara/basilisk/src/embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 920 "/home/pwachara/basilisk/src/embed.h"
val(cs,0,0,0) = 1.;}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 943 "/home/pwachara/basilisk/src/embed.h"
  restriction (((scalar[]){cs, fs.x, fs.y, fs.z,{-1}}));
}{end_tracing("metric","/home/pwachara/basilisk/src/embed.h",944);return 0;}end_tracing("metric","/home/pwachara/basilisk/src/embed.h",944);}




static int defaults_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int defaults(const int i,const double t,Event *_ev){tracing("defaults","/home/pwachara/basilisk/src/embed.h",949); {
  display ("draw_vof (c = 'cs', s = 'fs', filled = -1, "
    "fc = {0.5,0.5,0.5}, order = 2);"
#line 494 "/home/pwachara/basilisk/src/common.h"
, false
#line 951 "/home/pwachara/basilisk/src/embed.h"
);
}{end_tracing("defaults","/home/pwachara/basilisk/src/embed.h",952);return 0;}end_tracing("defaults","/home/pwachara/basilisk/src/embed.h",952);}
#line 3 "CubicTest.c"
#line 1 "navier-stokes/centered.h"
#line 1 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
#line 27 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
#line 1 "./run.h"
#line 1 "/home/pwachara/basilisk/src/run.h"
#line 9 "/home/pwachara/basilisk/src/run.h"
double dt = 1.;

#line 1 "./utils.h"
#line 1 "/home/pwachara/basilisk/src/utils.h"







double DT = 1e30f, CFL = 0.5;




struct {

  long nc;

  long tnc;

  double t, tp;

  double speed;

  double ispeed;

  timer gt;
} perf = {0};





void update_perf() {
  perf.nc += grid->n;
  perf.tnc += grid->tn;
  perf.t = timer_elapsed (perf.gt);
  perf.speed = perf.tnc/perf.t;
  perf.ispeed = grid->tn/(perf.t - perf.tp);
  perf.tp = perf.t;
}






typedef struct {
  double cpu;
  double real;
  double speed;
  double min;
  double avg;
  double max;
  size_t tnc;
  long mem;
} timing;






timing timer_timing (timer t, int i, size_t tnc, double * mpi)
{
  timing s;

  s.avg = mpi_time - t.tm;

  clock_t end = clock();
  s.cpu = ((double) (end - t.c))/CLOCKS_PER_SEC;
  s.real = timer_elapsed (t);
  if (tnc == 0) {
    double n = 0; 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:n)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 73 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 73 "/home/pwachara/basilisk/src/utils.h"
n++;}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 73 "/home/pwachara/basilisk/src/utils.h"
{mpi_all_reduce_array(&n,MPI_DOUBLE,MPI_SUM,1);}
    s.tnc = n;
    tnc = n*i;
  }
  else
    s.tnc = tnc;





  s.mem = 0;


  if (mpi)
    MPI_Allgather (&s.avg, 1, MPI_DOUBLE, mpi, 1, MPI_DOUBLE, MPI_COMM_WORLD);
  s.max = s.min = s.avg;
  mpi_all_reduce (s.max, MPI_DOUBLE, MPI_MAX);
  mpi_all_reduce (s.min, MPI_DOUBLE, MPI_MIN);
  mpi_all_reduce (s.avg, MPI_DOUBLE, MPI_SUM);
  mpi_all_reduce (s.real, MPI_DOUBLE, MPI_SUM);
  mpi_all_reduce (s.mem, MPI_LONG, MPI_SUM);
  s.real /= npe();
  s.avg /= npe();
  s.mem /= npe();



  s.speed = s.real > 0. ? tnc/s.real : -1.;
  return s;
}




void timer_print (timer t, int i, size_t tnc)
{



  timing s = timer_timing (t, i, tnc, NULL);
  fprintf (fout,
    "\n# " "Multigrid"
    ", %d steps, %g CPU, %.4g real, %.3g points.step/s, %d var\n",
    i, s.cpu, s.real, s.speed, (int) (datasize/sizeof(real)));

  fprintf (fout,
    "# %d procs, MPI: min %.2g (%.2g%%) "
    "avg %.2g (%.2g%%) max %.2g (%.2g%%)\n",
    npe(),
    s.min, 100.*s.min/s.real,
    s.avg, 100.*s.avg/s.real,
    s.max, 100.*s.max/s.real);

  fflush (fout);
}







typedef struct {
  double avg, rms, max, volume;
} norm;

norm normf (scalar f)
{
  double avg = 0., rms = 0., max = 0., volume = 0.;
  if(!is_constant(cm)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 143, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 145 "/home/pwachara/basilisk/src/utils.h"
{_stencil_val(f,0,0,0);_stencil_val(cm,0,0,0); {   
      _stencil_val(f,0,0,0);   
         
_stencil_val(cm,0,0,0); 
        _stencil_val(cm,0,0,0); 
        _stencil_val(cm,0,0,0);    
}        }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:max) reduction(+:avg)   reduction(+:rms) reduction(+:volume)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 145 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 145 "/home/pwachara/basilisk/src/utils.h"
if (val(f,0,0,0) != 1e30f && (( Delta*Delta*Delta)*val(cm,0,0,0)) > 0.) {
      double v = fabs(val(f,0,0,0));
      if (v > max) max = v;
      volume += (( Delta*Delta*Delta)*val(cm,0,0,0));
      avg += (( Delta*Delta*Delta)*val(cm,0,0,0))*v;
      rms += (( Delta*Delta*Delta)*val(cm,0,0,0))*( v*v);
    }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 151 "/home/pwachara/basilisk/src/utils.h"
{mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&rms,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&avg,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 143, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 145 "/home/pwachara/basilisk/src/utils.h"
{_stencil_val(f,0,0,0);; {   
      _stencil_val(f,0,0,0);

;
;
;    
}        }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:max) reduction(+:avg)   reduction(+:rms) reduction(+:volume)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 145 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 145 "/home/pwachara/basilisk/src/utils.h"
if (val(f,0,0,0) != 1e30f && (( Delta*Delta*Delta)*_const_cm) > 0.) {
      double v = fabs(val(f,0,0,0));
      if (v > max) max = v;
      volume += (( Delta*Delta*Delta)*_const_cm);
      avg += (( Delta*Delta*Delta)*_const_cm)*v;
      rms += (( Delta*Delta*Delta)*_const_cm)*( v*v);
    }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 151 "/home/pwachara/basilisk/src/utils.h"
{mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&rms,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&avg,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);}}
  norm n;
  n.avg = volume ? avg/volume : 0.;
  n.rms = volume ? sqrt(rms/volume) : 0.;
  n.max = max;
  n.volume = volume;
  return n;
}





typedef struct {
  double min, max, sum, stddev, volume;
} stats;

stats statsf (scalar f)
{
  double min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
  if(!is_constant(cm)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 171, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 173 "/home/pwachara/basilisk/src/utils.h"
{_stencil_val(cm,0,0,0); _stencil_val(f,0,0,0); {
_stencil_val(cm,0,0,0); 
        _stencil_val(cm,0,0,0);_stencil_val(f,0,0,0); 
        _stencil_val(cm,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0); 
         _stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }
_stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }    
}       }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:sum) reduction(+:sum2) reduction(+:volume)   reduction(max:max) reduction(min:min)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 173 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 173 "/home/pwachara/basilisk/src/utils.h"
if ((( Delta*Delta*Delta)*val(cm,0,0,0)) > 0. && val(f,0,0,0) != 1e30f) {
      volume += (( Delta*Delta*Delta)*val(cm,0,0,0));
      sum += (( Delta*Delta*Delta)*val(cm,0,0,0))*val(f,0,0,0);
      sum2 += (( Delta*Delta*Delta)*val(cm,0,0,0))*( (val(f,0,0,0))*(val(f,0,0,0)));
      if (val(f,0,0,0) > max) max = val(f,0,0,0);
      if (val(f,0,0,0) < min) min = val(f,0,0,0);
    }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 179 "/home/pwachara/basilisk/src/utils.h"
{mpi_all_reduce_array(&min,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&sum2,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&sum,MPI_DOUBLE,MPI_SUM,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 171, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 173 "/home/pwachara/basilisk/src/utils.h"
{; _stencil_val(f,0,0,0); {
;
;_stencil_val(f,0,0,0);
;_stencil_val(f,0,0,0);_stencil_val(f,0,0,0); 
         _stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }
_stencil_val(f,0,0,0); { _stencil_val(f,0,0,0); }    
}       }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:sum) reduction(+:sum2) reduction(+:volume)   reduction(max:max) reduction(min:min)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 173 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 173 "/home/pwachara/basilisk/src/utils.h"
if ((( Delta*Delta*Delta)*_const_cm) > 0. && val(f,0,0,0) != 1e30f) {
      volume += (( Delta*Delta*Delta)*_const_cm);
      sum += (( Delta*Delta*Delta)*_const_cm)*val(f,0,0,0);
      sum2 += (( Delta*Delta*Delta)*_const_cm)*( (val(f,0,0,0))*(val(f,0,0,0)));
      if (val(f,0,0,0) > max) max = val(f,0,0,0);
      if (val(f,0,0,0) < min) min = val(f,0,0,0);
    }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 179 "/home/pwachara/basilisk/src/utils.h"
{mpi_all_reduce_array(&min,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&volume,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&sum2,MPI_DOUBLE,MPI_SUM,1);mpi_all_reduce_array(&sum,MPI_DOUBLE,MPI_SUM,1);}}
  stats s;
  s.min = min, s.max = max, s.sum = sum, s.volume = volume;
  if (volume > 0.)
    sum2 -= sum*sum/volume;
  s.stddev = sum2 > 0. ? sqrt(sum2/volume) : 0.;
  return s;
}
#line 195 "/home/pwachara/basilisk/src/utils.h"
static double generic_limiter (double r, double beta)
{
  double v1 = ( r < beta ? r : beta), v2 = ( (beta*r) < 1. ? (beta*r) : 1.);
  v1 = ( 0. > v1 ? 0. : v1);
  return ( v1 > v2 ? v1 : v2);
}

double minmod (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.)*(s1 - s0);
}

double superbee (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 2.)*(s1 - s0);
}

double sweby (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.5)*(s1 - s0);
}
#line 221 "/home/pwachara/basilisk/src/utils.h"
double theta = 1.3;

double minmod2 (double s0, double s1, double s2)
{
  if (s0 < s1 && s1 < s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 < d1) d1 = d2;
    return ( d1 < d3 ? d1 : d3);
  }
  if (s0 > s1 && s1 > s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 > d1) d1 = d2;
    return ( d1 > d3 ? d1 : d3);
  }
  return 0.;
}
#line 245 "/home/pwachara/basilisk/src/utils.h"
void gradients (scalar * f, vector * g)
{
  if (!(list_len(f) == vectors_len(g))) qassert ("/home/pwachara/basilisk/src/utils.h", 247, "list_len(f) == vectors_len(g)");
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 248, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 248 "/home/pwachara/basilisk/src/utils.h"
{
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {

_stencil_val(fs.x,0,0,0);_stencil_val(fs.x,1,0,0);{
     {_stencil_val_a(v.x,0,0,0);  }

     
{_stencil_val(s,-1,0,0); _stencil_val(s,0,0,0); _stencil_val(s,1,0,0);_stencil_val_a(v.x,0,0,0);   }} 
} 
#line 252
{

_stencil_val(fs.y,0,0,0);_stencil_val(fs.y,0,1,0);{
     {_stencil_val_a(v.y,0,0,0);  }

     
{_stencil_val(s,0,-1,0); _stencil_val(s,0,0,0); _stencil_val(s,0,1,0);_stencil_val_a(v.y,0,0,0);   }} 
} 
#line 252
{

_stencil_val(fs.z,0,0,0);_stencil_val(fs.z,0,0,1);{
     {_stencil_val_a(v.z,0,0,0);  }

     
{_stencil_val(s,0,0,-1); _stencil_val(s,0,0,0); _stencil_val(s,0,0,1);_stencil_val_a(v.z,0,0,0);   }} 
}}
      else
 { {

_stencil_val(fs.x,0,0,0);_stencil_val(fs.x,1,0,0);{
     {_stencil_val_a(v.x,0,0,0);  }

     
{_stencil_val(s,1,0,0); _stencil_val(s,-1,0,0);_stencil_val_a(v.x,0,0,0);   }} 
} 
#line 261
{

_stencil_val(fs.y,0,0,0);_stencil_val(fs.y,0,1,0);{
     {_stencil_val_a(v.y,0,0,0);  }

     
{_stencil_val(s,0,1,0); _stencil_val(s,0,-1,0);_stencil_val_a(v.y,0,0,0);   }} 
} 
#line 261
{

_stencil_val(fs.z,0,0,0);_stencil_val(fs.z,0,0,1);{
     {_stencil_val_a(v.z,0,0,0);  }

     
{_stencil_val(s,0,0,1); _stencil_val(s,0,0,-1);_stencil_val_a(v.z,0,0,0);   }} 
}}
    }}}
  }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 248 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 248 "/home/pwachara/basilisk/src/utils.h"
{
    scalar s; vector v;
    {vector*_i0=g;scalar*_i1= f;if(_i0)for(v=*_i0,s=*_i1;_i0->x.i>= 0;v=*++_i0,s=*++_i1){ {
      if (_attribute[s.i].gradient)
 { {

   if (!val(fs.x,0,0,0) || !val(fs.x,1,0,0))
     val(v.x,0,0,0) = 0.;
   else

     val(v.x,0,0,0) = _attribute[s.i].gradient (val(s,-1,0,0), val(s,0,0,0), val(s,1,0,0))/Delta;
 } 
#line 252
{

   if (!val(fs.y,0,0,0) || !val(fs.y,0,1,0))
     val(v.y,0,0,0) = 0.;
   else

     val(v.y,0,0,0) = _attribute[s.i].gradient (val(s,0,-1,0), val(s,0,0,0), val(s,0,1,0))/Delta;
 } 
#line 252
{

   if (!val(fs.z,0,0,0) || !val(fs.z,0,0,1))
     val(v.z,0,0,0) = 0.;
   else

     val(v.z,0,0,0) = _attribute[s.i].gradient (val(s,0,0,-1), val(s,0,0,0), val(s,0,0,1))/Delta;
 }}
      else
 { {

   if (!val(fs.x,0,0,0) || !val(fs.x,1,0,0))
     val(v.x,0,0,0) = 0.;
   else

     val(v.x,0,0,0) = (val(s,1,0,0) - val(s,-1,0,0))/(2.*Delta);
 } 
#line 261
{

   if (!val(fs.y,0,0,0) || !val(fs.y,0,1,0))
     val(v.y,0,0,0) = 0.;
   else

     val(v.y,0,0,0) = (val(s,0,1,0) - val(s,0,-1,0))/(2.*Delta);
 } 
#line 261
{

   if (!val(fs.z,0,0,0) || !val(fs.z,0,0,1))
     val(v.z,0,0,0) = 0.;
   else

     val(v.z,0,0,0) = (val(s,0,0,1) - val(s,0,0,-1))/(2.*Delta);
 }}
    }}}
  }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 271 "/home/pwachara/basilisk/src/utils.h"
}
#line 288 "/home/pwachara/basilisk/src/utils.h"
void vorticity (const vector u, scalar omega)
{
  if(!is_constant(fm.x) && !is_constant(cm)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 290, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 291 "/home/pwachara/basilisk/src/utils.h"
{_stencil_val(fm.x,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,0,0,0);
        _stencil_val(fm.x,1,0,0);_stencil_val(u.y,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,-1,0,0);
_stencil_val(fm.y,0,1,0); _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,0,0);
        _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,-1,0); _stencil_val(fm.y,0,1,0);_stencil_val(u.x,0,1,0);_stencil_val(cm,0,0,0);
#line 291
_stencil_val_a(omega,0,0,0);      
             

}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 291 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 291 "/home/pwachara/basilisk/src/utils.h"
val(omega,0,0,0) = ((val(fm.x,1,0,0) - val(fm.x,0,0,0))*val(u.y,0,0,0) +
        val(fm.x,1,0,0)*val(u.y,1,0,0) - val(fm.x,0,0,0)*val(u.y,-1,0,0) -
        (val(fm.y,0,1,0) - val(fm.y,0,0,0))*val(u.x,0,0,0) +
        val(fm.y,0,0,0)*val(u.x,0,-1,0) - val(fm.y,0,1,0)*val(u.x,0,1,0))/(2.*(val(cm,0,0,0) + 1e-30)*Delta);}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 294 "/home/pwachara/basilisk/src/utils.h"
}else if(is_constant(fm.x) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 290, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 291 "/home/pwachara/basilisk/src/utils.h"
{;;_stencil_val(u.y,0,0,0);
;_stencil_val(u.y,1,0,0);;_stencil_val(u.y,-1,0,0);
;;_stencil_val(u.x,0,0,0);
;_stencil_val(u.x,0,-1,0);;_stencil_val(u.x,0,1,0);_stencil_val(cm,0,0,0);
#line 291
_stencil_val_a(omega,0,0,0);      
             

}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 291 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 291 "/home/pwachara/basilisk/src/utils.h"
val(omega,0,0,0) = ((_const_fm.x - _const_fm.x)*val(u.y,0,0,0) +
        _const_fm.x*val(u.y,1,0,0) - _const_fm.x*val(u.y,-1,0,0) -
        (_const_fm.y - _const_fm.y)*val(u.x,0,0,0) +
        _const_fm.y*val(u.x,0,-1,0) - _const_fm.y*val(u.x,0,1,0))/(2.*(val(cm,0,0,0) + 1e-30)*Delta);}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 294 "/home/pwachara/basilisk/src/utils.h"
}else if(!is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 290, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 291 "/home/pwachara/basilisk/src/utils.h"
{_stencil_val(fm.x,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,0,0,0);
        _stencil_val(fm.x,1,0,0);_stencil_val(u.y,1,0,0); _stencil_val(fm.x,0,0,0);_stencil_val(u.y,-1,0,0);
_stencil_val(fm.y,0,1,0); _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,0,0);
        _stencil_val(fm.y,0,0,0);_stencil_val(u.x,0,-1,0); _stencil_val(fm.y,0,1,0);_stencil_val(u.x,0,1,0);;
#line 291
_stencil_val_a(omega,0,0,0);      
             

}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 291 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 291 "/home/pwachara/basilisk/src/utils.h"
val(omega,0,0,0) = ((val(fm.x,1,0,0) - val(fm.x,0,0,0))*val(u.y,0,0,0) +
        val(fm.x,1,0,0)*val(u.y,1,0,0) - val(fm.x,0,0,0)*val(u.y,-1,0,0) -
        (val(fm.y,0,1,0) - val(fm.y,0,0,0))*val(u.x,0,0,0) +
        val(fm.y,0,0,0)*val(u.x,0,-1,0) - val(fm.y,0,1,0)*val(u.x,0,1,0))/(2.*(_const_cm + 1e-30)*Delta);}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 294 "/home/pwachara/basilisk/src/utils.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 290, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 291 "/home/pwachara/basilisk/src/utils.h"
{;;_stencil_val(u.y,0,0,0);
;_stencil_val(u.y,1,0,0);;_stencil_val(u.y,-1,0,0);
;;_stencil_val(u.x,0,0,0);
;_stencil_val(u.x,0,-1,0);;_stencil_val(u.x,0,1,0);;
#line 291
_stencil_val_a(omega,0,0,0);      
             

}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 291 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 291 "/home/pwachara/basilisk/src/utils.h"
val(omega,0,0,0) = ((_const_fm.x - _const_fm.x)*val(u.y,0,0,0) +
        _const_fm.x*val(u.y,1,0,0) - _const_fm.x*val(u.y,-1,0,0) -
        (_const_fm.y - _const_fm.y)*val(u.x,0,0,0) +
        _const_fm.y*val(u.x,0,-1,0) - _const_fm.y*val(u.x,0,1,0))/(2.*(_const_cm + 1e-30)*Delta);}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 294 "/home/pwachara/basilisk/src/utils.h"
}
}





double change (scalar s, scalar sn)
{
  double max = 0.;
  if(!is_constant(cm)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 304, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 304 "/home/pwachara/basilisk/src/utils.h"
{
_stencil_val(cm,0,0,0); {     
       _stencil_val(sn,0,0,0);_stencil_val(s,0,0,0);   
       
  
    } 
_stencil_val(s,0,0,0);    _stencil_val_a(sn,0,0,0); 
  }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:max)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 304 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 304 "/home/pwachara/basilisk/src/utils.h"
{
    if ((( Delta*Delta*Delta)*val(cm,0,0,0)) > 0.) {
      double ds = fabs (val(s,0,0,0) - val(sn,0,0,0));
      if (ds > max)
 max = ds;
    }
    val(sn,0,0,0) = val(s,0,0,0);
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 311 "/home/pwachara/basilisk/src/utils.h"
{mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);}}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/utils.h", .line = 304, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 304 "/home/pwachara/basilisk/src/utils.h"
{
; {     
       _stencil_val(sn,0,0,0);_stencil_val(s,0,0,0);   
       
  
    } 
_stencil_val(s,0,0,0);    _stencil_val_a(sn,0,0,0); 
  }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:max)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 304 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 304 "/home/pwachara/basilisk/src/utils.h"
{
    if ((( Delta*Delta*Delta)*_const_cm) > 0.) {
      double ds = fabs (val(s,0,0,0) - val(sn,0,0,0));
      if (ds > max)
 max = ds;
    }
    val(sn,0,0,0) = val(s,0,0,0);
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 311 "/home/pwachara/basilisk/src/utils.h"
{mpi_all_reduce_array(&max,MPI_DOUBLE,MPI_MAX,1);}}
  return max;
}





scalar lookup_field (const char * name)
{
  if (name)
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (!strcmp (_attribute[s.i].name, name))
 return s;}}
  return (scalar){-1};
}

vector lookup_vector (const char * name)
{
  if (name) {
    char component[strlen(name) + 3];
    strcpy (component, name);
    strcat (component, ".x");
    {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (!strcmp (_attribute[s.i].name, component))
 return _attribute[s.i].v;}}
  }
  return (vector){{-1}};
}







void macro_foreach_segment (coord S[2], coord p[2], Reduce reductions)
{
  double norm = sqrt(( (S[1].x - S[0].x)*(S[1].x - S[0].x)) + ( (S[1].y - S[0].y)*(S[1].y - S[0].y)));
  if (norm > 0.) {
    coord t = {(S[1].x - S[0].x)/norm + 1e-6, (S[1].y - S[0].y)/norm - 1.5e-6};
    double alpha = S[0].x*t.y - S[0].y*t.x; 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
      
#line 354 "/home/pwachara/basilisk/src/utils.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 354 "/home/pwachara/basilisk/src/utils.h"
if (fabs(t.y*x - t.x*y - alpha) < 0.708*Delta_x) {
 coord _o = {x,y}, p[2];
 int _n = 0;
 
   if (t.x)
     for (int _i = -1; _i <= 1 && _n < 2; _i += 2) {
       p[_n].x = _o.x + _i*Delta_x/2.;
       double a = (p[_n].x - S[0].x)/t.x;
       p[_n].y = S[0].y + a*t.y;
       if (fabs(p[_n].y - _o.y) <= Delta_x/2.) {
  a = ( a < 0. ? 0. : a > norm ? norm : a);
  p[_n].x = S[0].x + a*t.x, p[_n].y = S[0].y + a*t.y;
  if (fabs(p[_n].x - _o.x) <= Delta_x/2. &&
      fabs(p[_n].y - _o.y) <= Delta_x/2.)
    _n++;
       }
     }   
#line 358
if (t.y)
     for (int _i = -1; _i <= 1 && _n < 2; _i += 2) {
       p[_n].y = _o.y + _i*Delta_y/2.;
       double a = (p[_n].y - S[0].y)/t.y;
       p[_n].z = S[0].z + a*t.z;
       if (fabs(p[_n].z - _o.z) <= Delta_y/2.) {
  a = ( a < 0. ? 0. : a > norm ? norm : a);
  p[_n].y = S[0].y + a*t.y, p[_n].z = S[0].z + a*t.z;
  if (fabs(p[_n].y - _o.y) <= Delta_y/2. &&
      fabs(p[_n].z - _o.z) <= Delta_y/2.)
    _n++;
       }
     }   
#line 358
if (t.z)
     for (int _i = -1; _i <= 1 && _n < 2; _i += 2) {
       p[_n].z = _o.z + _i*Delta_z/2.;
       double a = (p[_n].z - S[0].z)/t.z;
       p[_n].x = S[0].x + a*t.x;
       if (fabs(p[_n].x - _o.x) <= Delta_z/2.) {
  a = ( a < 0. ? 0. : a > norm ? norm : a);
  p[_n].z = S[0].z + a*t.z, p[_n].x = S[0].x + a*t.x;
  if (fabs(p[_n].z - _o.z) <= Delta_z/2. &&
      fabs(p[_n].x - _o.x) <= Delta_z/2.)
    _n++;
       }
     }
 if (_n == 2)
   ;
      }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
  
#line 374 "/home/pwachara/basilisk/src/utils.h"
}
}




void fields_stats (scalar * list)
{
  fprintf (ferr, "# t = %g, fields = {", t);
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    fprintf (ferr, " %s", _attribute[s.i].name);}}
  fputs (" }\n", ferr);
  fprintf (ferr, "# %12s: %12s %12s %12s %12s\n",
    "name", "min", "avg", "stddev", "max");
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    stats ss = statsf (s);
    fprintf (ferr, "# %12s: %12g %12g %12g %12g\n",
      _attribute[s.i].name, ss.min, ss.sum/ss.volume, ss.stddev, ss.max);
  }}}
}

#line 1 "./output.h"
#line 1 "/home/pwachara/basilisk/src/output.h"
#line 37 "/home/pwachara/basilisk/src/output.h"
     
void output_field (scalar * list,
     FILE * fp,
     int n,
     bool linear,
     coord box[2])
{tracing("output_field","/home/pwachara/basilisk/src/output.h",38);
  n++;
  int len = list_len (list);
  double Delta = 0.999999*(box[1].x - box[0].x)/(n - 1);
  int ny = (box[1].y - box[0].y)/Delta + 1;
  double ** field = (double **) matrix_new (n, ny, len*sizeof(double)), * v = field[0];
  for (int i = 0; i < n*ny*len; i++, v++)
    *v = 1e30f;
  coord box1[2] = {{box[0].x - Delta/2., box[0].y - Delta/2.},
     {box[0].x + (n - 0.5)*Delta, box[0].y + (ny - 0.5)*Delta}};
  coord cn = {n, ny}, p;

  v = field[0];
  
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/output.h", .line = 56, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);  
#line 60 "/home/pwachara/basilisk/src/output.h"
{                     
    
    
    
    
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      { _stencil_interpolate_linear (point, s, NULL, NULL, NULL); _stencil_val(s,0,0,0);      }}}
  }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 25 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{
  {
    if (cn.x < 1) cn.x = 1;
    if (cn.y < 1) cn.y = 1;
    if (cn.z < 1) cn.z = 1;

    for (int _i = 0; _i < (int) cn.x; _i++) {
      p.x = box1[0].x + (box1[1].x - box1[0].x)/cn.x*(_i + 0.5);
      for (int _j = 0; _j < (int) cn.y; _j++) {
 p.y = box1[0].y + (box1[1].y - box1[0].y)/cn.y*(_j + 0.5);
 for (int _k = 0; _k < (int) cn.z; _k++) {
   p.z = box1[0].z + (box1[1].z - box1[0].z)/cn.z*(_k + 0.5);
   Point point = locate (p.x, p.y, p.z);
   if (point.level >= 0) {
     int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);



  
#line 60 "/home/pwachara/basilisk/src/output.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 60 "/home/pwachara/basilisk/src/output.h"
{
    double ** alias = field;
    int i = (p.x - box1[0].x)/(box1[1].x - box1[0].x)*cn.x;
    int j = (p.y - box1[0].y)/(box1[1].y - box1[0].y)*cn.y;
    int k = 0;
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      alias[i][len*j + k++] = linear ? interpolate_linear (point, s, p.x, p.y, p.z) : val(s,0,0,0);}}
  }}   
#line 41 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
}
 }
      }
    }
  }
}
#line 67 "/home/pwachara/basilisk/src/output.h"
{mpi_all_reduce_array(v,MPI_DOUBLE,MPI_MIN,n*ny*len);}

  if (pid() == 0) {
    fprintf (fp, "# 1:x 2:y");
    int i = 3;
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      fprintf (fp, " %d:%s", i++, _attribute[s.i].name);}}
    fputc('\n', fp);
    for (int i = 0; i < n; i++) {
      double x = Delta*i + box[0].x;
      for (int j = 0; j < ny; j++) {
 double y = Delta*j + box[0].y;

 fprintf (fp, "%g %g", x, y);
 int k = 0;
 {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   fprintf (fp, " %g", field[i][len*j + k++]);}}
 fputc ('\n', fp);
      }
      fputc ('\n', fp);
    }
    fflush (fp);
  }

  matrix_free (field);
end_tracing("output_field","/home/pwachara/basilisk/src/output.h",92);}
#line 125 "/home/pwachara/basilisk/src/output.h"
     
void output_matrix (scalar f,
      FILE * fp,
      int n,
      bool linear,
      const char * file,
      coord box[2])
{tracing("output_matrix","/home/pwachara/basilisk/src/output.h",126);
  coord cn = {n}, p;
  double delta = (box[1].x - box[0].x)/n;
  cn.y = (int)((box[1].y - box[0].y)/delta);

  double ** ppm = (double **) matrix_new (cn.x, cn.y, sizeof(double));
  double * ppm0 = &ppm[0][0];
  unsigned int len = cn.x*cn.y;
  for (int i = 0; i < len; i++)
    ppm0[i] = - 1e30f;
  
  


  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/output.h", .line = 144, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);  
#line 148 "/home/pwachara/basilisk/src/output.h"
{                  
    
    
     
_stencil_interpolate_linear (point, f, NULL, NULL, NULL); _stencil_val(f,0,0,0);  
}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 25 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{
  {
    if (cn.x < 1) cn.x = 1;
    if (cn.y < 1) cn.y = 1;
    if (cn.z < 1) cn.z = 1;

    for (int _i = 0; _i < (int) cn.x; _i++) {
      p.x = box[0].x + (box[1].x - box[0].x)/cn.x*(_i + 0.5);
      for (int _j = 0; _j < (int) cn.y; _j++) {
 p.y = box[0].y + (box[1].y - box[0].y)/cn.y*(_j + 0.5);
 for (int _k = 0; _k < (int) cn.z; _k++) {
   p.z = box[0].z + (box[1].z - box[0].z)/cn.z*(_k + 0.5);
   Point point = locate (p.x, p.y, p.z);
   if (point.level >= 0) {
     int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);



  
#line 148 "/home/pwachara/basilisk/src/output.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 148 "/home/pwachara/basilisk/src/output.h"
{
    int i = (p.x - box[0].x)/(box[1].x - box[0].x)*cn.x;
    int j = (p.y - box[0].y)/(box[1].y - box[0].y)*cn.y;
    double ** alias = ppm;
    alias[i][j] = linear ? interpolate_linear (point, f, p.x, p.y, p.z) : val(f,0,0,0);
  }}   
#line 41 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
}
 }
      }
    }
  }
}
#line 153 "/home/pwachara/basilisk/src/output.h"
{mpi_all_reduce_array(ppm0,MPI_DOUBLE,MPI_MAX,len);}

  if (pid() == 0) {
    if (file) {
      fp = fopen (file, "wb");
      if (!fp) {
 perror (file);
 exit (1);
      }
    }
    float fn = cn.y;
    fwrite (&fn, sizeof(float), 1, fp);
    coord delta = {(box[1].x - box[0].x)/cn.x, (box[1].y - box[0].y)/cn.y};
    for (int j = 0; j < cn.y; j++) {
      float yp = box[0].y + delta.y*(j + 0.5);
      fwrite (&yp, sizeof(float), 1, fp);
    }
    for (int i = 0; i < cn.x; i++) {
      float xp = box[0].x + delta.x*(i + 0.5);
      fwrite (&xp, sizeof(float), 1, fp);
      for (int j = 0; j < cn.y; j++) {
 float z = ppm[i][j];
 fwrite (&z, sizeof(float), 1, fp);
      }
    }
    if (file)
      fclose (fp);
    else
      fflush (fp);
  }

  matrix_free (ppm);
end_tracing("output_matrix","/home/pwachara/basilisk/src/output.h",185);}
#line 194 "/home/pwachara/basilisk/src/output.h"
typedef void (* Colormap) (double cmap[127][3]);

void jet (double cmap[127][3])
{
  for (int i = 0; i < 127; i++) {
    cmap[i][0] =
      i <= 46 ? 0. :
      i >= 111 ? -0.03125*(i - 111) + 1. :
      i >= 78 ? 1. :
      0.03125*(i - 46);
    cmap[i][1] =
      i <= 14 || i >= 111 ? 0. :
      i >= 79 ? -0.03125*(i - 111) :
      i <= 46 ? 0.03125*(i - 14) :
      1.;
    cmap[i][2] =
      i >= 79 ? 0. :
      i >= 47 ? -0.03125*(i - 79) :
      i <= 14 ? 0.03125*(i - 14) + 1.:
      1.;
  }
}

void cool_warm (double cmap[127][3])
{






  static double basemap[33][3] = {
    {0.2298057, 0.298717966, 0.753683153},
    {0.26623388, 0.353094838, 0.801466763},
    {0.30386891, 0.406535296, 0.84495867},
    {0.342804478, 0.458757618, 0.883725899},
    {0.38301334, 0.50941904, 0.917387822},
    {0.424369608, 0.558148092, 0.945619588},
    {0.46666708, 0.604562568, 0.968154911},
    {0.509635204, 0.648280772, 0.98478814},
    {0.552953156, 0.688929332, 0.995375608},
    {0.596262162, 0.726149107, 0.999836203},
    {0.639176211, 0.759599947, 0.998151185},
    {0.681291281, 0.788964712, 0.990363227},
    {0.722193294, 0.813952739, 0.976574709},
    {0.761464949, 0.834302879, 0.956945269},
    {0.798691636, 0.849786142, 0.931688648},
    {0.833466556, 0.860207984, 0.901068838},
    {0.865395197, 0.86541021, 0.865395561},
    {0.897787179, 0.848937047, 0.820880546},
    {0.924127593, 0.827384882, 0.774508472},
    {0.944468518, 0.800927443, 0.726736146},
    {0.958852946, 0.769767752, 0.678007945},
    {0.96732803, 0.734132809, 0.628751763},
    {0.969954137, 0.694266682, 0.579375448},
    {0.966811177, 0.650421156, 0.530263762},
    {0.958003065, 0.602842431, 0.481775914},
    {0.943660866, 0.551750968, 0.434243684},
    {0.923944917, 0.49730856, 0.387970225},
    {0.89904617, 0.439559467, 0.343229596},
    {0.869186849, 0.378313092, 0.300267182},
    {0.834620542, 0.312874446, 0.259301199},
    {0.795631745, 0.24128379, 0.220525627},
    {0.752534934, 0.157246067, 0.184115123},
    {0.705673158, 0.01555616, 0.150232812}
  };

  for (int i = 0; i < 127; i++) {
    double x = i*(32 - 1e-10)/(127 - 1);
    int j = x; x -= j;
    for (int k = 0; k < 3; k++)
      cmap[i][k] = (1. - x)*basemap[j][k] + x*basemap[j+1][k];
  }
}

void gray (double cmap[127][3])
{
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = i/(127 - 1.);
}

void randomap (double cmap[127][3])
{
  srand(0);
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = (noise() + 1.)/2.;
}

void blue_white_red (double cmap[127][3])
{
  for (int i = 0; i < (127 + 1)/2; i++) {
    cmap[i][0] = i/((127 - 1)/2.);
    cmap[i][1] = i/((127 - 1)/2.);
    cmap[i][2] = 1.;
  }
  for (int i = 0; i < (127 - 1)/2; i++) {
    cmap[i + (127 + 1)/2][0] = 1.;
    cmap[i + (127 + 1)/2][1] = cmap[(127 - 3)/2 - i][1];
    cmap[i + (127 + 1)/2][2] = cmap[(127 - 3)/2 - i][1];
  }
}





typedef struct {
  unsigned char r, g, b;
} Color;

Color colormap_color (double cmap[127][3],
        double val, double min, double max)
{
  Color c;
  if (val == 1e30f) {
    c.r = c.g = c.b = 0;
    return c;
  }
  int i;
  double coef;
  if (max != min)
    val = (val - min)/(max - min);
  else
    val = 0.;
  if (val <= 0.) i = 0, coef = 0.;
  else if (val >= 1.) i = 127 - 2, coef = 1.;
  else {
    i = val*(127 - 1);
    coef = val*(127 - 1) - i;
  }
  if (!(i >= 0 && i < 127 - 1)) qassert ("/home/pwachara/basilisk/src/output.h", 326, "i >= 0 && i < NCMAP - 1");
  unsigned char * c1 = (unsigned char *) &c;
  for (int j = 0; j < 3; j++)
    c1[j] = 255*(cmap[i][j]*(1. - coef) + cmap[i + 1][j]*coef);
  return c;
}
#line 345 "/home/pwachara/basilisk/src/output.h"
static const char * extension (const char * file, const char * ext) {
  int len = strlen(file);
  return len > 4 && !strcmp (file + len - 4, ext) ? file + len - 4 : NULL;
}

static const char * is_animation (const char * file) {
  const char * ext;
  if ((ext = extension (file, ".mp4")) ||
      (ext = extension (file, ".ogv")) ||
      (ext = extension (file, ".gif")))
    return ext;
  return NULL;
}

static struct {
  FILE ** fp;
  char ** names;
  int n;
} open_image_data = {NULL, NULL, 0};

static void open_image_cleanup()
{
  for (int i = 0; i < open_image_data.n; i++) {
    qpclose (open_image_data.fp[i]);
    pfree (open_image_data.names[i],__func__,__FILE__,__LINE__);
  }
  pfree (open_image_data.fp,__func__,__FILE__,__LINE__);
  pfree (open_image_data.names,__func__,__FILE__,__LINE__);
  open_image_data.fp = NULL;
  open_image_data.names = NULL;
  open_image_data.n = 0;
}

static FILE * open_image_lookup (const char * file)
{
  for (int i = 0; i < open_image_data.n; i++)
    if (!strcmp (file, open_image_data.names[i]))
      return open_image_data.fp[i];
  return NULL;
}

static bool which (const char * command)
{
  char * s = getenv ("PATH");
  if (!s)
    return false;
  char path[strlen(s) + 1];
  strcpy (path, s);
  s = strtok (path, ":");
  while (s) {
    char f[strlen(s) + strlen(command) + 2];
    strcpy (f, s);
    strcat (f, "/");
    strcat (f, command);
    FILE * fp = fopen (f, "r");
    if (fp) {
      fclose (fp);
      return true;
    }
    s = strtok (NULL, ":");
  }
  return false;
}

static FILE * ppm_fallback (const char * file, const char * mode)
{
  char filename[strlen(file) + 5];
  strcpy (filename, file);
  strcat (filename, ".ppm");
  FILE * fp = fopen (filename, mode);
  if (!fp) {
    perror (file);

    MPI_Abort (MPI_COMM_WORLD, 1);

    exit (1);
  }
  return fp;
}

FILE * open_image (const char * file, const char * options)
{
#if __EMSCRIPTEN__
  return ppm_fallback (file, "w");
#else
  if (!(pid() == 0)) qassert ("/home/pwachara/basilisk/src/output.h", 430, "pid() == 0");
  const char * ext;
  if ((ext = is_animation (file))) {
    FILE * fp = open_image_lookup (file);
    if (fp)
      return fp;

    int len = strlen ("ppm2???    ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    strcpy (command, "ppm2"); strcat (command, ext + 1);

    static int has_ffmpeg = -1;
    if (has_ffmpeg < 0) {
      if (which (command) && (which ("ffmpeg") || which ("avconv")))
 has_ffmpeg = true;
      else {
 fprintf (ferr,
   "src/output.h:%d: warning: cannot find '%s' or 'ffmpeg'/'avconv'\n"
   "src/output.h:%d: warning: falling back to raw PPM outputs\n",
   450, command, 450);
 has_ffmpeg = false;
      }
    }
    if (!has_ffmpeg)
      return ppm_fallback (file, "a");

    static bool added = false;
    if (!added) {
      free_solver_func_add (open_image_cleanup);
      added = true;
    }
    open_image_data.n++;
    open_image_data.names = (char * *) prealloc (open_image_data.names, (open_image_data.n)*sizeof(char *),__func__,__FILE__,__LINE__);
    open_image_data.names[open_image_data.n - 1] = pstrdup (file,__func__,__FILE__,__LINE__);

    if (options) {
      strcat (command, " ");
      strcat (command, options);
    }
    strcat (command, !strcmp (ext, ".mp4") ? " " : " > ");
    strcat (command, file);
    open_image_data.fp = (FILE * *) prealloc (open_image_data.fp, (open_image_data.n)*sizeof(FILE *),__func__,__FILE__,__LINE__);
    return open_image_data.fp[open_image_data.n - 1] = qpopen (command, "w");
  }
  else {
    static int has_convert = -1;
    if (has_convert < 0) {
      if (which ("convert"))
 has_convert = true;
      else {
 fprintf (ferr,
   "src/output.h:%d: warning: cannot find 'convert'\n"
   "src/output.h:%d: warning: falling back to raw PPM outputs\n",
   484, 484);
 has_convert = false;
      }
    }
    if (!has_convert)
      return ppm_fallback (file, "w");

    int len = strlen ("convert ppm:-   ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    strcpy (command, "convert ppm:- ");
    if (options) {
      strcat (command, options);
      strcat (command, " ");
    }
    strcat (command, file);
    return qpopen (command, "w");
  }
#endif
}

void close_image (const char * file, FILE * fp)
{
  if (!(pid() == 0)) qassert ("/home/pwachara/basilisk/src/output.h", 507, "pid() == 0");
  if (is_animation (file)) {
    if (!open_image_lookup (file))
      fclose (fp);
  }
#if !__EMSCRIPTEN__
  else if (which ("convert"))
    qpclose (fp);
#endif
  else
    fclose (fp);
}
#line 593 "/home/pwachara/basilisk/src/output.h"
     
void output_ppm (scalar f,
   FILE * fp,
   int n,
   char * file,
   double min, double max, double spread,
   double z,
   bool linear,
   coord box[2],
   scalar mask,
   Colormap map,
   char * opt,
   int fps,
   FILE * checksum)
{tracing("output_ppm","/home/pwachara/basilisk/src/output.h",594);

  if (!min && !max) {
    stats s = statsf (f);
    if (spread < 0.)
      min = s.min, max = s.max;
    else {
      double avg = s.sum/s.volume;
      min = avg - spread*s.stddev; max = avg + spread*s.stddev;
    }
  }
  box[0].z = z, box[1].z = z;

  coord cn = {n}, p;
  double delta = (box[1].x - box[0].x)/n;
  cn.y = (int)((box[1].y - box[0].y)/delta);
  if (((int)cn.y) % 2) cn.y++;

  Color ** ppm = (Color **) matrix_new (cn.y, cn.x, sizeof(Color));
  unsigned char * ppm0 = &ppm[0][0].r;
  int len = 3*cn.x*cn.y;
  memset (ppm0, 0, len*sizeof (unsigned char));
  double cmap[127][3];
  (* map) (cmap);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/output.h", .line = 633, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);



  
#line 637 "/home/pwachara/basilisk/src/output.h"
{ 
    
    if (mask.i >= 0) {
      if (linear) {  
  _stencil_interpolate_linear (point, mask, NULL, NULL, NULL);
{ 
    
   
{ _stencil_interpolate_linear (point, f, NULL, NULL, NULL); }}      
}
      else {
_stencil_val(mask,0,0,0);{
     
   
{ _stencil_val(f,0,0,0); }}      
}
    }
    else if (linear)
      { _stencil_interpolate_linear (point, f, NULL, NULL, NULL); }
    else
      { _stencil_val(f,0,0,0); }                  
    
    
         
         
  }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 25 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
{
  {
    if (cn.x < 1) cn.x = 1;
    if (cn.y < 1) cn.y = 1;
    if (cn.z < 1) cn.z = 1;

    for (int _i = 0; _i < (int) cn.x; _i++) {
      p.x = box[0].x + (box[1].x - box[0].x)/cn.x*(_i + 0.5);
      for (int _j = 0; _j < (int) cn.y; _j++) {
 p.y = box[0].y + (box[1].y - box[0].y)/cn.y*(_j + 0.5);
 for (int _k = 0; _k < (int) cn.z; _k++) {
   p.z = box[0].z + (box[1].z - box[0].z)/cn.z*(_k + 0.5);
   Point point = locate (p.x, p.y, p.z);
   if (point.level >= 0) {
     int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);



  
#line 637 "/home/pwachara/basilisk/src/output.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 637 "/home/pwachara/basilisk/src/output.h"
{
    double v;
    if (mask.i >= 0) {
      if (linear) {
 double m = interpolate_linear (point, mask, p.x, p.y, p.z);
 if (m < 0.)
   v = 1e30f;
 else
   v = interpolate_linear (point, f, p.x, p.y, p.z);
      }
      else {
 if (val(mask,0,0,0) < 0.)
   v = 1e30f;
 else
   v = val(f,0,0,0);
      }
    }
    else if (linear)
      v = interpolate_linear (point, f, p.x, p.y, p.z);
    else
      v = val(f,0,0,0);
    int i = (p.x - box[0].x)/(box[1].x - box[0].x)*cn.x;
    int j = (p.y - box[0].y)/(box[1].y - box[0].y)*cn.y;
    Color ** alias = ppm;
    alias[(int)cn.y - 1 - j][i] = colormap_color (cmap, v, min, max);
  }}   
#line 41 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
}
 }
      }
    }
  }
}
#line 662 "/home/pwachara/basilisk/src/output.h"
{mpi_all_reduce_array(ppm0,MPI_UNSIGNED_CHAR,MPI_MAX,len);}

  if (pid() == 0) {
    if (file)
      fp = open_image (file, opt);

    fprintf (fp, "P6\n%g %g 255\n", cn.x, cn.y);
    fwrite (ppm0, sizeof(unsigned char), 3*cn.x*cn.y, fp);

    if (file)
      close_image (file, fp);
    else
      fflush (fp);

    if (checksum) {
      Adler32Hash hash;
      a32_hash_init (&hash);
      a32_hash_add (&hash, ppm0, sizeof(unsigned char)*3*cn.x*cn.y);
      fputs ("# ", checksum);
      if (file)
 fprintf (checksum, "%s: ", file);
      fprintf (checksum, "checksum: %08lx\n", (unsigned long) a32_hash (&hash));
    }
  }

  matrix_free (ppm);
end_tracing("output_ppm","/home/pwachara/basilisk/src/output.h",688);}
#line 720 "/home/pwachara/basilisk/src/output.h"
     
void output_grd (scalar f,
   FILE * fp,
   double Delta,
   bool linear,
   coord box[2],
   scalar mask)
{tracing("output_grd","/home/pwachara/basilisk/src/output.h",721);
  int nx = (box[1].x - box[0].x)/Delta;
  int ny = (box[1].y - box[0].y)/Delta;


  fprintf (fp, "ncols          %d\n", nx);
  fprintf (fp, "nrows          %d\n", ny);
  fprintf (fp, "xllcorner      %g\n", box[0].x);
  fprintf (fp, "yllcorner      %g\n", box[0].y);
  fprintf (fp, "cellsize       %g\n", Delta);
  fprintf (fp, "nodata_value   -9999\n");


  for (int j = ny-1; j >= 0; j--) {
    double yp = Delta*j + box[0].y + Delta/2.;
    for (int i = 0; i < nx; i++) {
      double xp = Delta*i + box[0].x + Delta/2., v;
      if (mask.i >= 0) {
 double m = interpolate (mask, xp, yp
#line 910 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
, 0.
#line 745 "/home/pwachara/basilisk/src/output.h"
, linear);
 if (m < 0.)
   v = 1e30f;
 else
   v = interpolate (f, xp, yp
#line 910 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
, 0.
#line 749 "/home/pwachara/basilisk/src/output.h"
, linear);
      }
      else
 v = interpolate (f, xp, yp
#line 910 "/home/pwachara/basilisk/src/grid/cartesian-common.h"
, 0.
#line 752 "/home/pwachara/basilisk/src/output.h"
, linear);
      if (v == 1e30f)
 fprintf (fp, "-9999 ");
      else
 fprintf (fp, "%f ", v);
    }
    fprintf (fp, "\n");
  }

  fflush (fp);
end_tracing("output_grd","/home/pwachara/basilisk/src/output.h",762);}
#line 789 "/home/pwachara/basilisk/src/output.h"
static char * replace (const char * input, int target, int with,
         bool translate)
{
  if (translate) {
    if (!strcmp (input, "u.x"))
      return pstrdup ("U",__func__,__FILE__,__LINE__);
    if (!strcmp (input, "u.y"))
      return pstrdup ("V",__func__,__FILE__,__LINE__);
    if (!strcmp (input, "u.z"))
      return pstrdup ("W",__func__,__FILE__,__LINE__);
  }
  char * name = pstrdup (input,__func__,__FILE__,__LINE__), * i = name;
  while (*i != '\0') {
    if (*i == target)
      *i = with;
    i++;
  }
  return name;
}

     
void output_gfs (FILE * fp,
   scalar * list,
   char * file,
   bool translate)
{tracing("output_gfs","/home/pwachara/basilisk/src/output.h",810);
  char * fname = file;



  not_mpi_compatible();

  FILE * sfp = fp;
  if (file == NULL) {
    long pid = getpid();
    MPI_Bcast (&pid, 1, MPI_LONG, 0, MPI_COMM_WORLD);
    fname = ((char *) pmalloc ((80)*sizeof(char),__func__,__FILE__,__LINE__));
    snprintf (fname, 80, ".output-%ld", pid);
    fp = NULL;
  }


  bool opened = false;
  if (fp == NULL) {
    if (fname == NULL)
      fp = fout;
    else if (!(fp = fopen (fname, "w"))) {
      perror (fname);
      exit (1);
    }
    else
      opened = true;
  }

  scalar * slist = list ? list : list_copy (all);

  restriction (slist);
  fprintf (fp,
    "1 0 GfsSimulation GfsBox GfsGEdge { binary = 1"
    " x = %g y = %g ",
    0.5 + X0/L0, 0.5 + Y0/L0);

  fprintf (fp, "z = %g ", 0.5 + Z0/L0);


  if (slist != NULL && slist[0].i != -1) {
    scalar s = slist[0];
    char * name = replace (_attribute[s.i].name, '.', '_', translate);
    fprintf (fp, "variables = %s", name);
    pfree (name,__func__,__FILE__,__LINE__);
    for (int i = 1; i < list_len(slist); i++) {
      scalar s = slist[i];
      if (_attribute[s.i].name) {
 char * name = replace (_attribute[s.i].name, '.', '_', translate);
 fprintf (fp, ",%s", name);
 pfree (name,__func__,__FILE__,__LINE__);
      }
    }
    fprintf (fp, " ");
  }
  fprintf (fp, "} {\n");
  fprintf (fp, "  Time { t = %g }\n", t);
  if (L0 != 1.)
    fprintf (fp, "  PhysicalParams { L = %g }\n", L0);
  fprintf (fp, "  VariableTracerVOF f\n");
  fprintf (fp, "}\nGfsBox { x = 0 y = 0 z = 0 } {\n");


  long header;
  if ((header = ftell (fp)) < 0) {
    perror ("output_gfs(): error in header");
    exit (1);
  }
  int cell_size = sizeof(unsigned) + sizeof(double);
  {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (_attribute[s.i].name)
      cell_size += sizeof(double);}}
  scalar index = new_scalar("index");
  size_t total_size = header + (z_indexing (index, false) + 1)*cell_size;
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 892 "/home/pwachara/basilisk/src/output.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 892 "/home/pwachara/basilisk/src/output.h"
{

    if (is_local(cell))

    {

      if (fseek (fp, header + val(index,0,0,0)*cell_size, SEEK_SET) < 0) {
 perror ("output_gfs(): error while seeking");
 exit (1);
      }

      unsigned flags =
 level == 0 ? 0 :
#line 913 "/home/pwachara/basilisk/src/output.h"
      child.x == -1 && child.y == -1 && child.z == -1 ? 0 :
 child.x == -1 && child.y == -1 && child.z == 1 ? 1 :
 child.x == -1 && child.y == 1 && child.z == -1 ? 2 :
 child.x == -1 && child.y == 1 && child.z == 1 ? 3 :
 child.x == 1 && child.y == -1 && child.z == -1 ? 4 :
 child.x == 1 && child.y == -1 && child.z == 1 ? 5 :
 child.x == 1 && child.y == 1 && child.z == -1 ? 6 :
 7;

      if (is_leaf(cell))
 flags |= (1 << 4);
      fwrite (&flags, sizeof (unsigned), 1, fp);
      double a = -1;
      fwrite (&a, sizeof (double), 1, fp);
      {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
 if (_attribute[s.i].name) {
   if (_attribute[s.i].v.x.i >= 0) {




     if (_attribute[s.i].v.x.i == s.i) {
       s = _attribute[s.i].v.y;
       a = is_local(cell) && val(s,0,0,0) != 1e30f ? val(s,0,0,0) : (double) DBL_MAX;
     }
     else if (_attribute[s.i].v.y.i == s.i) {
       s = _attribute[s.i].v.x;
       a = is_local(cell) && val(s,0,0,0) != 1e30f ? - val(s,0,0,0) : (double) DBL_MAX;
     }


     else
       a = is_local(cell) && val(s,0,0,0) != 1e30f ? val(s,0,0,0) : (double) DBL_MAX;

   }
   else
     a = is_local(cell) && val(s,0,0,0) != 1e30f ? val(s,0,0,0) : (double) DBL_MAX;
   fwrite (&a, sizeof (double), 1, fp);
 }}}
    }
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}


  
#line 958 "/home/pwachara/basilisk/src/output.h"
delete (((scalar[]){index,{-1}}));
  if (!pid() && fseek (fp, total_size, SEEK_SET) < 0) {
    perror ("output_gfs(): error while finishing");
    exit (1);
  }
  if (!pid())

    fputs ("}\n", fp);
  fflush (fp);

  if (!list)
    pfree (slist,__func__,__FILE__,__LINE__);
  if (opened)
    fclose (fp);


  if (file == NULL) {
    MPI_Barrier (MPI_COMM_WORLD);
    if (pid() == 0) {
      if (sfp == NULL)
 sfp = fout;
      fp = fopen (fname, "r");
      size_t l;
      unsigned char buffer[8192];
      while ((l = fread (buffer, 1, 8192, fp)) > 0)
 fwrite (buffer, 1, l, sfp);
      fflush (sfp);
      remove (fname);
    }
    pfree (fname,__func__,__FILE__,__LINE__);
  }

end_tracing("output_gfs","/home/pwachara/basilisk/src/output.h",990);}
#line 1017 "/home/pwachara/basilisk/src/output.h"
struct DumpHeader {
  double t;
  long len;
  int i, depth, npe, version;
  coord n;
};

static const int dump_version =

  170901;

static scalar * dump_list (scalar * lista, bool zero)
{
  scalar * list = is_constant(cm) ? NULL : list_concat (((scalar[]){cm,{-1}}), NULL);




  scalar * listb = list_copy (lista);

  {scalar*_i=(scalar*)( listb);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!_attribute[s.i].face && !_attribute[s.i].nodump && s.i != cm.i) {
      if (zero)
 list = list_add (list, s);
      else {
 stats ss = statsf (s);
 if (ss.min != 0. || ss.max != 0.)
   list = list_add (list, s);
      }
    }}}
  pfree (listb,__func__,__FILE__,__LINE__);
  return list;
}

static void dump_header (FILE * fp, struct DumpHeader * header, scalar * list)
{
  if (fwrite (header, sizeof(struct DumpHeader), 1, fp) < 1) {
    perror ("dump(): error while writing header");
    exit (1);
  }
  {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    unsigned len = strlen(_attribute[s.i].name);
    if (fwrite (&len, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing len");
      exit (1);
    }
    if (fwrite (_attribute[s.i].name, sizeof(char), len, fp) < len) {
      perror ("dump(): error while writing s.name");
      exit (1);
    }
  }}}
  double o[4] = {X0,Y0,Z0,L0};
  if (fwrite (o, sizeof(double), 4, fp) < 4) {
    perror ("dump(): error while writing coordinates");
    exit (1);
  }
}
#line 1141 "/home/pwachara/basilisk/src/output.h"
     
void dump (const char * file,
    scalar * list,
    FILE * fp,
    bool unbuffered,
    bool zero)
{tracing("dump","/home/pwachara/basilisk/src/output.h",1142);
  if (fp != NULL || file == NULL) {
    fprintf (ferr, "dump(): must specify a file name when using MPI\n");
    exit(1);
  }

  char name[strlen(file) + 2];
  strcpy (name, file);
  if (!unbuffered)
    strcat (name, "~");
  FILE * fh = fopen (name, "w");
  if (fh == NULL) {
    perror (name);
    exit (1);
  }

  scalar * dlist = dump_list (list, zero);
  scalar  size=new_scalar("size");
  scalar * slist = list_concat (((scalar[]){size,{-1}}), dlist); pfree (dlist,__func__,__FILE__,__LINE__);
  struct DumpHeader header = { t, list_len(slist), iter, depth(), npe(),
          dump_version };


  
    header.n.x = Dimensions.x;    header.n.y = Dimensions.y;    header.n.z = Dimensions.z;
  MPI_Barrier (MPI_COMM_WORLD);


  if (pid() == 0)
    dump_header (fh, &header, slist);

  scalar index = {-1};

  index = new_scalar("index");
  z_indexing (index, false);
  int cell_size = sizeof(unsigned) + header.len*sizeof(double);
  int sizeofheader = sizeof(header) + 4*sizeof(double);
  {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    sizeofheader += sizeof(unsigned) + sizeof(char)*strlen(_attribute[s.i].name);}}
  long pos = pid() ? 0 : sizeofheader;

  subtree_size (size, false);
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1190 "/home/pwachara/basilisk/src/output.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 1190 "/home/pwachara/basilisk/src/output.h"
{

    if (is_local(cell)) {
      long offset = sizeofheader + val(index,0,0,0)*cell_size;
      if (pos != offset) {
 fseek (fh, offset, SEEK_SET);
 pos = offset;
      }
      unsigned flags = is_leaf(cell) ? leaf : 0;
      fwrite (&flags, 1, sizeof(unsigned), fh);
      {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
 double val = val(s,0,0,0);
 fwrite (&val, 1, sizeof(double), fh);
      }}}
      pos += cell_size;
    }
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}

  
#line 1210 "/home/pwachara/basilisk/src/output.h"
delete (((scalar[]){index,{-1}}));

  pfree (slist,__func__,__FILE__,__LINE__);
  fclose (fh);
  if (!unbuffered && pid() == 0)
    rename (name, file);delete((scalar*)((scalar[]){size,{-1}}));
end_tracing("dump","/home/pwachara/basilisk/src/output.h",1216);}


     
bool restore (const char * file,
       scalar * list,
       FILE * fp)
{tracing("restore","/home/pwachara/basilisk/src/output.h",1220);
  if (!fp && (fp = fopen (file, "r")) == NULL)
    {end_tracing("restore","/home/pwachara/basilisk/src/output.h",1225);return false;}
  if (!(fp)) qassert ("/home/pwachara/basilisk/src/output.h", 1226, "fp");

  struct DumpHeader header = {0};
  if (fread (&header, sizeof(header), 1, fp) < 1) {
    fprintf (ferr, "restore(): error: expecting header\n");
    exit (1);
  }
#line 1243 "/home/pwachara/basilisk/src/output.h"
  if (header.npe != npe()) {
    fprintf (ferr,
      "restore(): error: the number of processes don't match:"
      " %d != %d\n",
      header.npe, npe());
    exit (1);
  }

  dimensions (header.n.x, header.n.y, header.n.z);
  double n = header.n.x;
  int depth = header.depth;
  while (n > 1)
    depth++, n /= 2;
  init_grid (1 << depth);


  bool restore_all = (list == all);
  scalar * slist = dump_list (list ? list : all, true);
  if (header.version == 161020) {
    if (header.len - 1 != list_len (slist)) {
      fprintf (ferr,
        "restore(): error: the list lengths don't match: "
        "%ld (file) != %d (code)\n",
        header.len - 1, list_len (slist));
      exit (1);
    }
  }
  else {
    if (header.version != dump_version) {
      fprintf (ferr,
        "restore(): error: file version mismatch: "
        "%d (file) != %d (code)\n",
        header.version, dump_version);
      exit (1);
    }

    scalar * input = NULL;
    for (int i = 0; i < header.len; i++) {
      unsigned len;
      if (fread (&len, sizeof(unsigned), 1, fp) < 1) {
 fprintf (ferr, "restore(): error: expecting len\n");
 exit (1);
      }
      char name[len + 1];
      if (fread (name, sizeof(char), len, fp) < 1) {
 fprintf (ferr, "restore(): error: expecting s.name\n");
 exit (1);
      }
      name[len] = '\0';

      if (i > 0) {
 bool found = false;
 {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
   if (!strcmp (_attribute[s.i].name, name)) {
     input = list_append (input, s);
     found = true; break;
   }}}
 if (!found) {
   if (restore_all) {
     scalar s = new_scalar("s");
     pfree (_attribute[s.i].name,__func__,__FILE__,__LINE__);
     _attribute[s.i].name = pstrdup (name,__func__,__FILE__,__LINE__);
     input = list_append (input, s);
   }
   else
     input = list_append (input, (scalar){INT_MAX});
 }
      }
    }
    pfree (slist,__func__,__FILE__,__LINE__);
    slist = input;

    double o[4];
    if (fread (o, sizeof(double), 4, fp) < 4) {
      fprintf (ferr, "restore(): error: expecting coordinates\n");
      exit (1);
    }
    origin (o[0], o[1], o[2]);
    size (o[3]);
  }


  long cell_size = sizeof(unsigned) + header.len*sizeof(double);
  long offset = pid()*((1 << 3*(header.depth + 1)) - 1)/
    ((1 << 3) - 1)*cell_size;
  if (fseek (fp, offset, SEEK_CUR) < 0) {
    perror ("restore(): error while seeking");
    exit (1);
  }


  scalar * listm = is_constant(cm) ? NULL : (scalar *)((vector[]){fm,{{-1},{-1},{-1}}});
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 1338 "/home/pwachara/basilisk/src/output.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 1338 "/home/pwachara/basilisk/src/output.h"
{
    unsigned flags;
    if (fread (&flags, sizeof(unsigned), 1, fp) != 1) {
      fprintf (ferr, "restore(): error: expecting 'flags'\n");
      exit (1);
    }

    fseek (fp, sizeof(double), SEEK_CUR);
    {scalar*_i=(scalar*)( slist);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      double val;
      if (fread (&val, sizeof(double), 1, fp) != 1) {
 fprintf (ferr, "restore(): error: expecting a scalar\n");
 exit (1);
      }
      if (s.i != INT_MAX)
 val(s,0,0,0) = isfinite(val) ? val : 1e30f;
    }}}
    if (!(flags & leaf) && is_leaf(cell))
      refine_cell (point, listm, 0, NULL);
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}





  
#line 1365 "/home/pwachara/basilisk/src/output.h"
{scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    _attribute[s.i].dirty = true;}}


  scalar * other = NULL;
  {scalar*_i=(scalar*)( all);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!list_lookup (slist, s) && !list_lookup (listm, s))
      other = list_append (other, s);}}
  reset (other, 0.);
  pfree (other,__func__,__FILE__,__LINE__);

  pfree (slist,__func__,__FILE__,__LINE__);
  if (file)
    fclose (fp);


  while (iter < header.i && events (false))
    iter = inext;
  events (false);
  while (t < header.t && events (false))
    t = tnext;
  t = header.t;
  events (false);

  {end_tracing("restore","/home/pwachara/basilisk/src/output.h",1389);return true;}
end_tracing("restore","/home/pwachara/basilisk/src/output.h",1390);}
#line 396 "/home/pwachara/basilisk/src/utils.h"
#line 12 "/home/pwachara/basilisk/src/run.h"

     
void run (void)
{tracing("run","/home/pwachara/basilisk/src/run.h",14);
  iter = 0, t = 0., dt = 1.;
  init_grid (N);

  perf.nc = perf.tnc = 0;
  perf.gt = timer_start();
  while (events (true)) {





    update_perf();
    iter = inext, t = tnext;
  }




  timer_print (perf.gt, iter, perf.tnc);

  free_grid();
end_tracing("run","/home/pwachara/basilisk/src/run.h",37);}




static int defaults_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int defaults_0(const int i,const double t,Event *_ev){tracing("defaults_0","/home/pwachara/basilisk/src/run.h",42); {
  display ("box();"
#line 494 "/home/pwachara/basilisk/src/common.h"
, false
#line 43 "/home/pwachara/basilisk/src/run.h"
);
}{end_tracing("defaults_0","/home/pwachara/basilisk/src/run.h",44);return 0;}end_tracing("defaults_0","/home/pwachara/basilisk/src/run.h",44);}





static int cleanup_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = TEND_EVENT)!=0;*ip=i;*tp=t;return ret;}      static int cleanup(const int i,const double t,Event *_ev){tracing("cleanup","/home/pwachara/basilisk/src/run.h",50); {
  display ("", true);
}{end_tracing("cleanup","/home/pwachara/basilisk/src/run.h",52);return 0;}end_tracing("cleanup","/home/pwachara/basilisk/src/run.h",52);}
#line 28 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
#line 1 "./timestep.h"
#line 1 "/home/pwachara/basilisk/src/timestep.h"

double timestep (const vector u, double dtmax)
{
  static double previous = 0.;
  if (t == 0.) previous = 0.;
  dtmax /= CFL;
if(!is_constant(fm.x)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/timestep.h", .line = 7, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 7 "/home/pwachara/basilisk/src/timestep.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{_stencil_val(u.x,0,0,0); {   
      _stencil_val(u.x,0,0,0);
_stencil_val(fm.x,0,0,0); 
_stencil_val(fm.x,0,0,0);    

}   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{_stencil_val(u.y,0,0,0); {   
      _stencil_val(u.y,0,0,0);
_stencil_val(fm.y,0,0,0); 
_stencil_val(fm.y,0,0,0);    

}   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{_stencil_val(u.z,0,0,0); {   
      _stencil_val(u.z,0,0,0);
_stencil_val(fm.z,0,0,0); 
_stencil_val(fm.z,0,0,0);    

}   }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(min:dtmax)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 7 "/home/pwachara/basilisk/src/timestep.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 8 "/home/pwachara/basilisk/src/timestep.h"
if (val(u.x,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.x,0,0,0));
      if (!(val(fm.x,0,0,0))) qassert ("/home/pwachara/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= val(fm.x,0,0,0);
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 8 "/home/pwachara/basilisk/src/timestep.h"
if (val(u.y,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.y,0,0,0));
      if (!(val(fm.y,0,0,0))) qassert ("/home/pwachara/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= val(fm.y,0,0,0);
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 8 "/home/pwachara/basilisk/src/timestep.h"
if (val(u.z,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.z,0,0,0));
      if (!(val(fm.z,0,0,0))) qassert ("/home/pwachara/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= val(fm.z,0,0,0);
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 13 "/home/pwachara/basilisk/src/timestep.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 13 "/home/pwachara/basilisk/src/timestep.h"
{mpi_all_reduce_array(&dtmax,MPI_DOUBLE,MPI_MIN,1);}}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/timestep.h", .line = 7, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 7 "/home/pwachara/basilisk/src/timestep.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{_stencil_val(u.x,0,0,0); {   
      _stencil_val(u.x,0,0,0);
;
;    

}   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{_stencil_val(u.y,0,0,0); {   
      _stencil_val(u.y,0,0,0);
;
;    

}   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{_stencil_val(u.z,0,0,0); {   
      _stencil_val(u.z,0,0,0);
;
;    

}   }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(min:dtmax)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 7 "/home/pwachara/basilisk/src/timestep.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 8 "/home/pwachara/basilisk/src/timestep.h"
if (val(u.x,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.x,0,0,0));
      if (!(_const_fm.x)) qassert ("/home/pwachara/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= _const_fm.x;
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 8 "/home/pwachara/basilisk/src/timestep.h"
if (val(u.y,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.y,0,0,0));
      if (!(_const_fm.y)) qassert ("/home/pwachara/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= _const_fm.y;
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 8 "/home/pwachara/basilisk/src/timestep.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 8 "/home/pwachara/basilisk/src/timestep.h"
if (val(u.z,0,0,0) != 0.) {
      double dt = Delta/fabs(val(u.z,0,0,0));
      if (!(_const_fm.z)) qassert ("/home/pwachara/basilisk/src/timestep.h", 10, "fm.x[]");
      dt *= _const_fm.z;
      if (dt < dtmax) dtmax = dt;
    }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 13 "/home/pwachara/basilisk/src/timestep.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 13 "/home/pwachara/basilisk/src/timestep.h"
{mpi_all_reduce_array(&dtmax,MPI_DOUBLE,MPI_MIN,1);}}
  dtmax *= CFL;
  if (dtmax > previous)
    dtmax = (previous + 0.1*dtmax)/1.1;
  previous = dtmax;
  return dtmax;
}
#line 29 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
#line 1 "./bcg.h"
#line 1 "/home/pwachara/basilisk/src/bcg.h"
#line 11 "/home/pwachara/basilisk/src/bcg.h"
     
void tracer_fluxes (scalar f,
      vector uf,
      vector flux,
      double dt,
              scalar src)
{tracing("tracer_fluxes","/home/pwachara/basilisk/src/bcg.h",12);





  vector  g=new_vector("g");
  gradients (((scalar[]){f,{-1}}),((vector[]) {g,{{-1},{-1},{-1}}}));




if(!is_constant(fm.x) && !is_constant(src)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/bcg.h", .line = 29, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{               







    _stencil_val(fm.x,0,0,0);_stencil_val(uf.x,0,0,0);              
    
    _stencil_val(g.x,o_stencil,0,0); _stencil_val(src,-1,0,0);_stencil_val(src,0,0,0);_stencil_val(f, o_stencil,0,0);





_stencil_val(fm.y,o_stencil,0,0); _stencil_val(fm.y,o_stencil,1,0); {     
       _stencil_val(fm.y,o_stencil,1,0);_stencil_val(fm.y,o_stencil,0,0); _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }


_stencil_val(fm.z,o_stencil,0,0); _stencil_val(fm.z,o_stencil,0,1); {     
       _stencil_val(fm.z,o_stencil,0,1);_stencil_val(fm.z,o_stencil,0,0); _stencil_val(uf.z,o_stencil,0,1);_stencil_val(uf.z,o_stencil,0,0);         
       _stencil_val(f,o_stencil,0,-1);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,0,1);
        
    }


_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux.x,0,0,0);  
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{               







    _stencil_val(fm.y,0,0,0);_stencil_val(uf.y,0,0,0);              
    
    _stencil_val(g.y,0,o_stencil,0); _stencil_val(src,0,-1,0);_stencil_val(src,0,0,0);_stencil_val(f,0, o_stencil,0);





_stencil_val(fm.z,0,o_stencil,0); _stencil_val(fm.z,0,o_stencil,1); {     
       _stencil_val(fm.z,0,o_stencil,1);_stencil_val(fm.z,0,o_stencil,0); _stencil_val(uf.z,0,o_stencil,1);_stencil_val(uf.z,0,o_stencil,0);         
       _stencil_val(f,0,o_stencil,-1);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,0,o_stencil,1);
        
    }


_stencil_val(fm.x,0,o_stencil,0); _stencil_val(fm.x,1,o_stencil,0); {     
       _stencil_val(fm.x,1,o_stencil,0);_stencil_val(fm.x,0,o_stencil,0); _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }


_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux.y,0,0,0);  
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{               







    _stencil_val(fm.z,0,0,0);_stencil_val(uf.z,0,0,0);              
    
    _stencil_val(g.z,0,0,o_stencil); _stencil_val(src,0,0,-1);_stencil_val(src,0,0,0);_stencil_val(f,0,0, o_stencil);





_stencil_val(fm.x,0,0,o_stencil); _stencil_val(fm.x,1,0,o_stencil); {     
       _stencil_val(fm.x,1,0,o_stencil);_stencil_val(fm.x,0,0,o_stencil); _stencil_val(uf.x,1,0,o_stencil);_stencil_val(uf.x,0,0,o_stencil);         
       _stencil_val(f,-1,0,o_stencil);_stencil_val(f,0,0, o_stencil);_stencil_val(f,0,0, o_stencil); _stencil_val(f,1,0,o_stencil);
        
    }


_stencil_val(fm.y,0,0,o_stencil); _stencil_val(fm.y,0,1,o_stencil); {     
       _stencil_val(fm.y,0,1,o_stencil);_stencil_val(fm.y,0,0,o_stencil); _stencil_val(uf.y,0,1,o_stencil);_stencil_val(uf.y,0,0,o_stencil);         
       _stencil_val(f,0,-1,o_stencil);_stencil_val(f,0,0, o_stencil);_stencil_val(f,0,0, o_stencil); _stencil_val(f,0,1,o_stencil);
        
    }


_stencil_val(uf.z,0,0,0);    _stencil_val_a(flux.z,0,0,0);  
  }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.x,0,0,0)/(val(fm.x,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (val(src,0,0,0) + val(src,-1,0,0))*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(val(fm.y,i,0,0) + val(fm.y,i,1,0));
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (val(fm.z,i,0,0) && val(fm.z,i,0,1)) {
      double wn = (val(uf.z,i,0,0) + val(uf.z,i,0,1))/(val(fm.z,i,0,0) + val(fm.z,i,0,1));
      double fzz = wn < 0. ? val(f,i,0,1) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,0,-1);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.y,0,0,0)/(val(fm.y,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (val(src,0,0,0) + val(src,0,-1,0))*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (val(fm.z,0,i,0) && val(fm.z,0,i,1)) {
      double vn = (val(uf.z,0,i,0) + val(uf.z,0,i,1))/(val(fm.z,0,i,0) + val(fm.z,0,i,1));
      double fyy = vn < 0. ? val(f,0,i,1) - val(f,0,i,0) : val(f,0,i,0) - val(f,0,i,-1);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double wn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(val(fm.x,0,i,0) + val(fm.x,1,i,0));
      double fzz = wn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.z,0,0,0)/(val(fm.z,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,0,i) + (val(src,0,0,0) + val(src,0,0,-1))*dt/4. + s*(1. - s*un)*val(g.z,0,0,i)*Delta/2.;





    if (val(fm.x,0,0,i) && val(fm.x,1,0,i)) {
      double vn = (val(uf.x,0,0,i) + val(uf.x,1,0,i))/(val(fm.x,0,0,i) + val(fm.x,1,0,i));
      double fyy = vn < 0. ? val(f,1,0,i) - val(f,0,0,i) : val(f,0,0,i) - val(f,-1,0,i);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (val(fm.y,0,0,i) && val(fm.y,0,1,i)) {
      double wn = (val(uf.y,0,0,i) + val(uf.y,0,1,i))/(val(fm.y,0,0,i) + val(fm.y,0,1,i));
      double fzz = wn < 0. ? val(f,0,1,i) - val(f,0,0,i) : val(f,0,0,i) - val(f,0,-1,i);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.z,0,0,0) = f2*val(uf.z,0,0,0);
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 60 "/home/pwachara/basilisk/src/bcg.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 60 "/home/pwachara/basilisk/src/bcg.h"
}else if(is_constant(fm.x) && !is_constant(src)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/bcg.h", .line = 29, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







;_stencil_val(uf.x,0,0,0);              
    
    _stencil_val(g.x,o_stencil,0,0); _stencil_val(src,-1,0,0);_stencil_val(src,0,0,0);_stencil_val(f, o_stencil,0,0);





;; {
;; _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }


;; {
;; _stencil_val(uf.z,o_stencil,0,1);_stencil_val(uf.z,o_stencil,0,0);         
       _stencil_val(f,o_stencil,0,-1);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,0,1);
        
    }


_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux.x,0,0,0);  
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







;_stencil_val(uf.y,0,0,0);              
    
    _stencil_val(g.y,0,o_stencil,0); _stencil_val(src,0,-1,0);_stencil_val(src,0,0,0);_stencil_val(f,0, o_stencil,0);





;; {
;; _stencil_val(uf.z,0,o_stencil,1);_stencil_val(uf.z,0,o_stencil,0);         
       _stencil_val(f,0,o_stencil,-1);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,0,o_stencil,1);
        
    }


;; {
;; _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }


_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux.y,0,0,0);  
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







;_stencil_val(uf.z,0,0,0);              
    
    _stencil_val(g.z,0,0,o_stencil); _stencil_val(src,0,0,-1);_stencil_val(src,0,0,0);_stencil_val(f,0,0, o_stencil);





;; {
;; _stencil_val(uf.x,1,0,o_stencil);_stencil_val(uf.x,0,0,o_stencil);         
       _stencil_val(f,-1,0,o_stencil);_stencil_val(f,0,0, o_stencil);_stencil_val(f,0,0, o_stencil); _stencil_val(f,1,0,o_stencil);
        
    }


;; {
;; _stencil_val(uf.y,0,1,o_stencil);_stencil_val(uf.y,0,0,o_stencil);         
       _stencil_val(f,0,-1,o_stencil);_stencil_val(f,0,0, o_stencil);_stencil_val(f,0,0, o_stencil); _stencil_val(f,0,1,o_stencil);
        
    }


_stencil_val(uf.z,0,0,0);    _stencil_val_a(flux.z,0,0,0);  
  }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.x,0,0,0)/(_const_fm.x*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (val(src,0,0,0) + val(src,-1,0,0))*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.z && _const_fm.z) {
      double wn = (val(uf.z,i,0,0) + val(uf.z,i,0,1))/(_const_fm.z + _const_fm.z);
      double fzz = wn < 0. ? val(f,i,0,1) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,0,-1);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.y,0,0,0)/(_const_fm.y*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (val(src,0,0,0) + val(src,0,-1,0))*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (_const_fm.z && _const_fm.z) {
      double vn = (val(uf.z,0,i,0) + val(uf.z,0,i,1))/(_const_fm.z + _const_fm.z);
      double fyy = vn < 0. ? val(f,0,i,1) - val(f,0,i,0) : val(f,0,i,0) - val(f,0,i,-1);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.x && _const_fm.x) {
      double wn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(_const_fm.x + _const_fm.x);
      double fzz = wn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.z,0,0,0)/(_const_fm.z*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,0,i) + (val(src,0,0,0) + val(src,0,0,-1))*dt/4. + s*(1. - s*un)*val(g.z,0,0,i)*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (val(uf.x,0,0,i) + val(uf.x,1,0,i))/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? val(f,1,0,i) - val(f,0,0,i) : val(f,0,0,i) - val(f,-1,0,i);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.y && _const_fm.y) {
      double wn = (val(uf.y,0,0,i) + val(uf.y,0,1,i))/(_const_fm.y + _const_fm.y);
      double fzz = wn < 0. ? val(f,0,1,i) - val(f,0,0,i) : val(f,0,0,i) - val(f,0,-1,i);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.z,0,0,0) = f2*val(uf.z,0,0,0);
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 60 "/home/pwachara/basilisk/src/bcg.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 60 "/home/pwachara/basilisk/src/bcg.h"
}else if(!is_constant(fm.x) && is_constant(src)){double _const_src=_constant[src.i-_NVARMAX];NOT_UNUSED(_const_src);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/bcg.h", .line = 29, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{               







    _stencil_val(fm.x,0,0,0);_stencil_val(uf.x,0,0,0);              
    
    _stencil_val(g.x,o_stencil,0,0);;;_stencil_val(f, o_stencil,0,0);





_stencil_val(fm.y,o_stencil,0,0); _stencil_val(fm.y,o_stencil,1,0); {     
       _stencil_val(fm.y,o_stencil,1,0);_stencil_val(fm.y,o_stencil,0,0); _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }


_stencil_val(fm.z,o_stencil,0,0); _stencil_val(fm.z,o_stencil,0,1); {     
       _stencil_val(fm.z,o_stencil,0,1);_stencil_val(fm.z,o_stencil,0,0); _stencil_val(uf.z,o_stencil,0,1);_stencil_val(uf.z,o_stencil,0,0);         
       _stencil_val(f,o_stencil,0,-1);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,0,1);
        
    }


_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux.x,0,0,0);  
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{               







    _stencil_val(fm.y,0,0,0);_stencil_val(uf.y,0,0,0);              
    
    _stencil_val(g.y,0,o_stencil,0);;;_stencil_val(f,0, o_stencil,0);





_stencil_val(fm.z,0,o_stencil,0); _stencil_val(fm.z,0,o_stencil,1); {     
       _stencil_val(fm.z,0,o_stencil,1);_stencil_val(fm.z,0,o_stencil,0); _stencil_val(uf.z,0,o_stencil,1);_stencil_val(uf.z,0,o_stencil,0);         
       _stencil_val(f,0,o_stencil,-1);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,0,o_stencil,1);
        
    }


_stencil_val(fm.x,0,o_stencil,0); _stencil_val(fm.x,1,o_stencil,0); {     
       _stencil_val(fm.x,1,o_stencil,0);_stencil_val(fm.x,0,o_stencil,0); _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }


_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux.y,0,0,0);  
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{               







    _stencil_val(fm.z,0,0,0);_stencil_val(uf.z,0,0,0);              
    
    _stencil_val(g.z,0,0,o_stencil);;;_stencil_val(f,0,0, o_stencil);





_stencil_val(fm.x,0,0,o_stencil); _stencil_val(fm.x,1,0,o_stencil); {     
       _stencil_val(fm.x,1,0,o_stencil);_stencil_val(fm.x,0,0,o_stencil); _stencil_val(uf.x,1,0,o_stencil);_stencil_val(uf.x,0,0,o_stencil);         
       _stencil_val(f,-1,0,o_stencil);_stencil_val(f,0,0, o_stencil);_stencil_val(f,0,0, o_stencil); _stencil_val(f,1,0,o_stencil);
        
    }


_stencil_val(fm.y,0,0,o_stencil); _stencil_val(fm.y,0,1,o_stencil); {     
       _stencil_val(fm.y,0,1,o_stencil);_stencil_val(fm.y,0,0,o_stencil); _stencil_val(uf.y,0,1,o_stencil);_stencil_val(uf.y,0,0,o_stencil);         
       _stencil_val(f,0,-1,o_stencil);_stencil_val(f,0,0, o_stencil);_stencil_val(f,0,0, o_stencil); _stencil_val(f,0,1,o_stencil);
        
    }


_stencil_val(uf.z,0,0,0);    _stencil_val_a(flux.z,0,0,0);  
  }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.x,0,0,0)/(val(fm.x,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(val(fm.y,i,0,0) + val(fm.y,i,1,0));
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (val(fm.z,i,0,0) && val(fm.z,i,0,1)) {
      double wn = (val(uf.z,i,0,0) + val(uf.z,i,0,1))/(val(fm.z,i,0,0) + val(fm.z,i,0,1));
      double fzz = wn < 0. ? val(f,i,0,1) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,0,-1);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.y,0,0,0)/(val(fm.y,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (val(fm.z,0,i,0) && val(fm.z,0,i,1)) {
      double vn = (val(uf.z,0,i,0) + val(uf.z,0,i,1))/(val(fm.z,0,i,0) + val(fm.z,0,i,1));
      double fyy = vn < 0. ? val(f,0,i,1) - val(f,0,i,0) : val(f,0,i,0) - val(f,0,i,-1);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double wn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(val(fm.x,0,i,0) + val(fm.x,1,i,0));
      double fzz = wn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.z,0,0,0)/(val(fm.z,0,0,0)*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,0,i) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.z,0,0,i)*Delta/2.;





    if (val(fm.x,0,0,i) && val(fm.x,1,0,i)) {
      double vn = (val(uf.x,0,0,i) + val(uf.x,1,0,i))/(val(fm.x,0,0,i) + val(fm.x,1,0,i));
      double fyy = vn < 0. ? val(f,1,0,i) - val(f,0,0,i) : val(f,0,0,i) - val(f,-1,0,i);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (val(fm.y,0,0,i) && val(fm.y,0,1,i)) {
      double wn = (val(uf.y,0,0,i) + val(uf.y,0,1,i))/(val(fm.y,0,0,i) + val(fm.y,0,1,i));
      double fzz = wn < 0. ? val(f,0,1,i) - val(f,0,0,i) : val(f,0,0,i) - val(f,0,-1,i);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.z,0,0,0) = f2*val(uf.z,0,0,0);
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 60 "/home/pwachara/basilisk/src/bcg.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 60 "/home/pwachara/basilisk/src/bcg.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_src=_constant[src.i-_NVARMAX];NOT_UNUSED(_const_src);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/bcg.h", .line = 29, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







;_stencil_val(uf.x,0,0,0);              
    
    _stencil_val(g.x,o_stencil,0,0);;;_stencil_val(f, o_stencil,0,0);





;; {
;; _stencil_val(uf.y,o_stencil,1,0);_stencil_val(uf.y,o_stencil,0,0);         
       _stencil_val(f,o_stencil,-1,0);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,1,0);
        
    }


;; {
;; _stencil_val(uf.z,o_stencil,0,1);_stencil_val(uf.z,o_stencil,0,0);         
       _stencil_val(f,o_stencil,0,-1);_stencil_val(f, o_stencil,0,0);_stencil_val(f, o_stencil,0,0); _stencil_val(f,o_stencil,0,1);
        
    }


_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux.x,0,0,0);  
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







;_stencil_val(uf.y,0,0,0);              
    
    _stencil_val(g.y,0,o_stencil,0);;;_stencil_val(f,0, o_stencil,0);





;; {
;; _stencil_val(uf.z,0,o_stencil,1);_stencil_val(uf.z,0,o_stencil,0);         
       _stencil_val(f,0,o_stencil,-1);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,0,o_stencil,1);
        
    }


;; {
;; _stencil_val(uf.x,1,o_stencil,0);_stencil_val(uf.x,0,o_stencil,0);         
       _stencil_val(f,-1,o_stencil,0);_stencil_val(f,0, o_stencil,0);_stencil_val(f,0, o_stencil,0); _stencil_val(f,1,o_stencil,0);
        
    }


_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux.y,0,0,0);  
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







;_stencil_val(uf.z,0,0,0);              
    
    _stencil_val(g.z,0,0,o_stencil);;;_stencil_val(f,0,0, o_stencil);





;; {
;; _stencil_val(uf.x,1,0,o_stencil);_stencil_val(uf.x,0,0,o_stencil);         
       _stencil_val(f,-1,0,o_stencil);_stencil_val(f,0,0, o_stencil);_stencil_val(f,0,0, o_stencil); _stencil_val(f,1,0,o_stencil);
        
    }


;; {
;; _stencil_val(uf.y,0,1,o_stencil);_stencil_val(uf.y,0,0,o_stencil);         
       _stencil_val(f,0,-1,o_stencil);_stencil_val(f,0,0, o_stencil);_stencil_val(f,0,0, o_stencil); _stencil_val(f,0,1,o_stencil);
        
    }


_stencil_val(uf.z,0,0,0);    _stencil_val_a(flux.z,0,0,0);  
  }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.x,0,0,0)/(_const_fm.x*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,i,0,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.x,i,0,0)*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (val(uf.y,i,0,0) + val(uf.y,i,1,0))/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? val(f,i,1,0) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,-1,0);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.z && _const_fm.z) {
      double wn = (val(uf.z,i,0,0) + val(uf.z,i,0,1))/(_const_fm.z + _const_fm.z);
      double fzz = wn < 0. ? val(f,i,0,1) - val(f,i,0,0) : val(f,i,0,0) - val(f,i,0,-1);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.x,0,0,0) = f2*val(uf.x,0,0,0);
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.y,0,0,0)/(_const_fm.y*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,i,0) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.y,0,i,0)*Delta/2.;





    if (_const_fm.z && _const_fm.z) {
      double vn = (val(uf.z,0,i,0) + val(uf.z,0,i,1))/(_const_fm.z + _const_fm.z);
      double fyy = vn < 0. ? val(f,0,i,1) - val(f,0,i,0) : val(f,0,i,0) - val(f,0,i,-1);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.x && _const_fm.x) {
      double wn = (val(uf.x,0,i,0) + val(uf.x,1,i,0))/(_const_fm.x + _const_fm.x);
      double fzz = wn < 0. ? val(f,1,i,0) - val(f,0,i,0) : val(f,0,i,0) - val(f,-1,i,0);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.y,0,0,0) = f2*val(uf.y,0,0,0);
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 29 "/home/pwachara/basilisk/src/bcg.h"
{







    double un = dt*val(uf.z,0,0,0)/(_const_fm.z*Delta + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    double f2 = val(f,0,0,i) + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*val(g.z,0,0,i)*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (val(uf.x,0,0,i) + val(uf.x,1,0,i))/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? val(f,1,0,i) - val(f,0,0,i) : val(f,0,0,i) - val(f,-1,0,i);
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.y && _const_fm.y) {
      double wn = (val(uf.y,0,0,i) + val(uf.y,0,1,i))/(_const_fm.y + _const_fm.y);
      double fzz = wn < 0. ? val(f,0,1,i) - val(f,0,0,i) : val(f,0,0,i) - val(f,0,-1,i);
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    val(flux.z,0,0,0) = f2*val(uf.z,0,0,0);
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 60 "/home/pwachara/basilisk/src/bcg.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 60 "/home/pwachara/basilisk/src/bcg.h"
}delete((scalar*)((vector[]){g,{{-1},{-1},{-1}}}));
end_tracing("tracer_fluxes","/home/pwachara/basilisk/src/bcg.h",61);}






     
void advection (scalar * tracers, vector u, double dt,
  scalar * src)
{tracing("advection","/home/pwachara/basilisk/src/bcg.h",69);




  scalar * psrc = src;
  if (!src)
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      const scalar zero = new_const_scalar("zero",16, 0.);
      src = list_append (src, zero);
    }}}
  if (!(list_len (tracers) == list_len (src))) qassert ("/home/pwachara/basilisk/src/bcg.h", 82, "list_len (tracers) == list_len (src)");

  scalar f, source;
  {scalar*_i0=src;scalar*_i1= tracers;if(_i0)for(source=*_i0,f=*_i1;_i0->i>= 0;source=*++_i0,f=*++_i1){ {
    vector  flux=new_face_vector("flux");
    tracer_fluxes (f, u, flux, dt, source);





    update_tracer (f, u, flux, dt);delete((scalar*)((vector[]){flux,{{-1},{-1},{-1}}}));

  }}}

  if (!psrc)
    pfree (src,__func__,__FILE__,__LINE__);
end_tracing("advection","/home/pwachara/basilisk/src/bcg.h",99);}
#line 30 "/home/pwachara/basilisk/src/navier-stokes/centered.h"

#line 1 "./viscosity-embed.h"
#line 1 "/home/pwachara/basilisk/src/viscosity-embed.h"
#line 31 "/home/pwachara/basilisk/src/viscosity-embed.h"
#line 1 "./poisson.h"
#line 1 "/home/pwachara/basilisk/src/poisson.h"
#line 32 "/home/pwachara/basilisk/src/poisson.h"
     
void mg_cycle (scalar * a, scalar * res, scalar * da,
        void (* relax) (scalar * da, scalar * res,
          int depth, void * data),
        void * data,
        int nrelax, int minlevel, int maxlevel)
{tracing("mg_cycle","/home/pwachara/basilisk/src/poisson.h",33);




  restriction (res);





  minlevel = ( minlevel < maxlevel ? minlevel : maxlevel);
  for (int l = minlevel; l <= maxlevel; l++) {




    if (l == minlevel)
      {
  
  
      
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 57 "/home/pwachara/basilisk/src/poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     {_stencil_val_a(s,0,0,0);  }}}
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 7 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 57 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 57 "/home/pwachara/basilisk/src/poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     val(s,0,0,0) = 0.;}}}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
#line 59 "/home/pwachara/basilisk/src/poisson.h"
}





    else {
      boundary_level (da, l - 1);
  
      
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 68 "/home/pwachara/basilisk/src/poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     { _stencil_bilinear_embed(point, s);_stencil_val_a(s,0,0,0); }}}
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
} 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 68 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 68 "/home/pwachara/basilisk/src/poisson.h"
{scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
  
     val(s,0,0,0) = bilinear_embed(point, s);}}}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}    
#line 71 "/home/pwachara/basilisk/src/poisson.h"
}





    for (int i = 0; i < nrelax; i++) {
      boundary_level (da, l);
      relax (da, res, l, data);
    }
  }
  




  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/poisson.h", .line = 86, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 86 "/home/pwachara/basilisk/src/poisson.h"
{
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 { _stencil_val(ds,0,0,0);_stencil_val_r(s,0,0,0); }}}
  }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 86 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 86 "/home/pwachara/basilisk/src/poisson.h"
{
    scalar s, ds;
    {scalar*_i0= da;scalar*_i1= a;if(_i0)for(ds=*_i0,s=*_i1;_i0->i>= 0;ds=*++_i0,s=*++_i1){
     
 val(s,0,0,0) += val(ds,0,0,0);}}
  }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
end_tracing("mg_cycle","/home/pwachara/basilisk/src/poisson.h",92);
#line 92 "/home/pwachara/basilisk/src/poisson.h"
}
#line 104 "/home/pwachara/basilisk/src/poisson.h"
int NITERMAX = 100, NITERMIN = 1;
double TOLERANCE = 1e-3;




typedef struct {
  int i;
  double resb, resa;
  double sum;
  int nrelax;
  int minlevel;
} mgstats;
#line 127 "/home/pwachara/basilisk/src/poisson.h"
     
mgstats mg_solve (scalar * a, scalar * b,
    double (* residual) (scalar * a, scalar * b, scalar * res,
           void * data),
    void (* relax) (scalar * da, scalar * res, int depth,
      void * data),
    void * data,
    int nrelax,
    scalar * res,
    int minlevel,
    double tolerance)
{tracing("mg_solve","/home/pwachara/basilisk/src/poisson.h",128);





  scalar * da = list_clone (a), * pres = res;
  if (!res)
    res = list_clone (b);






  for (int b = 0; b < nboundary; b++)
    {scalar*_i=(scalar*)( da);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b];}}




  mgstats s = {0};
  double sum = 0.;
  scalar rhs = b[0];
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/poisson.h", .line = 163, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 164 "/home/pwachara/basilisk/src/poisson.h"
{ _stencil_val(rhs,0,0,0); }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:sum)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 164 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 164 "/home/pwachara/basilisk/src/poisson.h"
sum += val(rhs,0,0,0);}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 164 "/home/pwachara/basilisk/src/poisson.h"
{mpi_all_reduce_array(&sum,MPI_DOUBLE,MPI_SUM,1);}
  s.sum = sum;
  s.nrelax = nrelax > 0 ? nrelax : 4;




  double resb;
  resb = s.resb = s.resa = (* residual) (a, b, res, data);






  for (s.i = 0;
       s.i < NITERMAX && (s.i < NITERMIN || s.resa > tolerance);
       s.i++) {
    mg_cycle (a, res, da, relax, data,
       s.nrelax,
       minlevel,
       grid->maxdepth);
    s.resa = (* residual) (a, b, res, data);
#line 195 "/home/pwachara/basilisk/src/poisson.h"
    if (s.resa > tolerance) {
      if (resb/s.resa < 1.2 && s.nrelax < 100)
 s.nrelax++;
      else if (resb/s.resa > 10 && s.nrelax > 2)
 s.nrelax--;
    }







    resb = s.resa;
  }
  s.minlevel = minlevel;




  if (s.resa > tolerance) {
    scalar v = a[0];
    fprintf (ferr,
      "src/poisson.h:%d: warning: convergence for %s not reached after %d iterations\n"
      "  res: %g sum: %g nrelax: %d tolerance: %g\n", 219, _attribute[v.i].name,
      s.i, s.resa, s.sum, s.nrelax, tolerance), fflush (ferr);
  }




  if (!pres)
    delete (res), pfree (res,__func__,__FILE__,__LINE__);
  delete (da), pfree (da,__func__,__FILE__,__LINE__);

  {end_tracing("mg_solve","/home/pwachara/basilisk/src/poisson.h",230);return s;}
end_tracing("mg_solve","/home/pwachara/basilisk/src/poisson.h",231);}
#line 254 "/home/pwachara/basilisk/src/poisson.h"
struct Poisson {
  scalar a, b;
          vector alpha;
          scalar lambda;
  double tolerance;
  int nrelax, minlevel;
  scalar * res;

  double (* embed_flux) (Point, scalar, vector, double *);

};





static void relax (scalar * al, scalar * bl, int l, void * data)
{
  scalar a = al[0], b = bl[0];
  struct Poisson * p = (struct Poisson *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;
#line 292 "/home/pwachara/basilisk/src/poisson.h"
  scalar c = a;
#line 305 "/home/pwachara/basilisk/src/poisson.h"
  if(!is_constant(lambda) && !is_constant(alpha.x)){
  
  
#line 305 "/home/pwachara/basilisk/src/poisson.h"
  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);  
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{         





     _stencil_val(lambda,0,0,0);_stencil_val(b,0,0,0);
     { 
_stencil_val(alpha.x,1,0,0);_stencil_val(a,1,0,0); _stencil_val(alpha.x,0,0,0);_stencil_val(a,-1,0,0);
         _stencil_val(alpha.x,1,0,0); _stencil_val(alpha.x,0,0,0);    
} 
#line 314
{ 
_stencil_val(alpha.y,0,1,0);_stencil_val(a,0,1,0); _stencil_val(alpha.y,0,0,0);_stencil_val(a,0,-1,0);
         _stencil_val(alpha.y,0,1,0); _stencil_val(alpha.y,0,0,0);    
} 
#line 314
{ 
_stencil_val(alpha.z,0,0,1);_stencil_val(a,0,0,1); _stencil_val(alpha.z,0,0,0);_stencil_val(a,0,0,-1);
         _stencil_val(alpha.z,0,0,1); _stencil_val(alpha.z,0,0,0);    
}

    if (p->embed_flux) {   
      default_stencil ( point,((scalar[]){alpha.x , alpha.y, alpha.z, a,{-1}}) );
         
         
    }
{
      {_stencil_val_a(c,0,0,0); _stencil_val_a(b,0,0,0);    }

      
{_stencil_val_a(c,0,0,0);  }}  
}
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 7 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++)

  
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{





    double n = - ( Delta*Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*( Delta*Delta);
     {
      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
    } 
#line 314
{
      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
    } 
#line 314
{
      n += val(alpha.z,0,0,1)*val(a,0,0,1) + val(alpha.z,0,0,0)*val(a,0,0,-1);
      d += val(alpha.z,0,0,1) + val(alpha.z,0,0,0);
    }

    if (p->embed_flux) {
      double c, e = p->embed_flux (point, a, alpha, &c);
      n -= c*( Delta*Delta);
      d += e*( Delta*Delta);
    }
    if (!d)
      val(c,0,0,0) = 0., val(b,0,0,0) = 0.;
    else

      val(c,0,0,0) = n/d;
  }}    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
#line 329 "/home/pwachara/basilisk/src/poisson.h"
}else if(is_constant(lambda) && !is_constant(alpha.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);
  
  
#line 305 "/home/pwachara/basilisk/src/poisson.h"
  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);  
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{





;_stencil_val(b,0,0,0);
     { 
_stencil_val(alpha.x,1,0,0);_stencil_val(a,1,0,0); _stencil_val(alpha.x,0,0,0);_stencil_val(a,-1,0,0);
         _stencil_val(alpha.x,1,0,0); _stencil_val(alpha.x,0,0,0);    
} 
#line 314
{ 
_stencil_val(alpha.y,0,1,0);_stencil_val(a,0,1,0); _stencil_val(alpha.y,0,0,0);_stencil_val(a,0,-1,0);
         _stencil_val(alpha.y,0,1,0); _stencil_val(alpha.y,0,0,0);    
} 
#line 314
{ 
_stencil_val(alpha.z,0,0,1);_stencil_val(a,0,0,1); _stencil_val(alpha.z,0,0,0);_stencil_val(a,0,0,-1);
         _stencil_val(alpha.z,0,0,1); _stencil_val(alpha.z,0,0,0);    
}

    if (p->embed_flux) {   
      default_stencil ( point,((scalar[]){alpha.x , alpha.y, alpha.z, a,{-1}}) );
         
         
    }
{
      {_stencil_val_a(c,0,0,0); _stencil_val_a(b,0,0,0);    }

      
{_stencil_val_a(c,0,0,0);  }}  
}
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 7 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++)

  
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{





    double n = - ( Delta*Delta)*val(b,0,0,0), d = - _const_lambda*( Delta*Delta);
     {
      n += val(alpha.x,1,0,0)*val(a,1,0,0) + val(alpha.x,0,0,0)*val(a,-1,0,0);
      d += val(alpha.x,1,0,0) + val(alpha.x,0,0,0);
    } 
#line 314
{
      n += val(alpha.y,0,1,0)*val(a,0,1,0) + val(alpha.y,0,0,0)*val(a,0,-1,0);
      d += val(alpha.y,0,1,0) + val(alpha.y,0,0,0);
    } 
#line 314
{
      n += val(alpha.z,0,0,1)*val(a,0,0,1) + val(alpha.z,0,0,0)*val(a,0,0,-1);
      d += val(alpha.z,0,0,1) + val(alpha.z,0,0,0);
    }

    if (p->embed_flux) {
      double c, e = p->embed_flux (point, a, alpha, &c);
      n -= c*( Delta*Delta);
      d += e*( Delta*Delta);
    }
    if (!d)
      val(c,0,0,0) = 0., val(b,0,0,0) = 0.;
    else

      val(c,0,0,0) = n/d;
  }}    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
#line 329 "/home/pwachara/basilisk/src/poisson.h"
}else if(!is_constant(lambda) && is_constant(alpha.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 305 "/home/pwachara/basilisk/src/poisson.h"
  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);  
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{         





     _stencil_val(lambda,0,0,0);_stencil_val(b,0,0,0);
     {
;_stencil_val(a,1,0,0);;_stencil_val(a,-1,0,0);
;;    
} 
#line 314
{
;_stencil_val(a,0,1,0);;_stencil_val(a,0,-1,0);
;;    
} 
#line 314
{
;_stencil_val(a,0,0,1);;_stencil_val(a,0,0,-1);
;;    
}

    if (p->embed_flux) {   
      default_stencil ( point,((scalar[]){alpha.x , alpha.y, alpha.z, a,{-1}}) );
         
         
    }
{
      {_stencil_val_a(c,0,0,0); _stencil_val_a(b,0,0,0);    }

      
{_stencil_val_a(c,0,0,0);  }}  
}
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 7 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++)

  
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{





    double n = - ( Delta*Delta)*val(b,0,0,0), d = - val(lambda,0,0,0)*( Delta*Delta);
     {
      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
      d += _const_alpha.x + _const_alpha.x;
    } 
#line 314
{
      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
      d += _const_alpha.y + _const_alpha.y;
    } 
#line 314
{
      n += _const_alpha.z*val(a,0,0,1) + _const_alpha.z*val(a,0,0,-1);
      d += _const_alpha.z + _const_alpha.z;
    }

    if (p->embed_flux) {
      double c, e = p->embed_flux (point, a, alpha, &c);
      n -= c*( Delta*Delta);
      d += e*( Delta*Delta);
    }
    if (!d)
      val(c,0,0,0) = 0., val(b,0,0,0) = 0.;
    else

      val(c,0,0,0) = n/d;
  }}    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
#line 329 "/home/pwachara/basilisk/src/poisson.h"
}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 305 "/home/pwachara/basilisk/src/poisson.h"
  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);  
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{





;_stencil_val(b,0,0,0);
     {
;_stencil_val(a,1,0,0);;_stencil_val(a,-1,0,0);
;;    
} 
#line 314
{
;_stencil_val(a,0,1,0);;_stencil_val(a,0,-1,0);
;;    
} 
#line 314
{
;_stencil_val(a,0,0,1);;_stencil_val(a,0,0,-1);
;;    
}

    if (p->embed_flux) {   
      default_stencil ( point,((scalar[]){alpha.x , alpha.y, alpha.z, a,{-1}}) );
         
         
    }
{
      {_stencil_val_a(c,0,0,0); _stencil_val_a(b,0,0,0);    }

      
{_stencil_val_a(c,0,0,0);  }}  
}
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 7 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++)

  
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 307 "/home/pwachara/basilisk/src/poisson.h"
{





    double n = - ( Delta*Delta)*val(b,0,0,0), d = - _const_lambda*( Delta*Delta);
     {
      n += _const_alpha.x*val(a,1,0,0) + _const_alpha.x*val(a,-1,0,0);
      d += _const_alpha.x + _const_alpha.x;
    } 
#line 314
{
      n += _const_alpha.y*val(a,0,1,0) + _const_alpha.y*val(a,0,-1,0);
      d += _const_alpha.y + _const_alpha.y;
    } 
#line 314
{
      n += _const_alpha.z*val(a,0,0,1) + _const_alpha.z*val(a,0,0,-1);
      d += _const_alpha.z + _const_alpha.z;
    }

    if (p->embed_flux) {
      double c, e = p->embed_flux (point, a, alpha, &c);
      n -= c*( Delta*Delta);
      d += e*( Delta*Delta);
    }
    if (!d)
      val(c,0,0,0) = 0., val(b,0,0,0) = 0.;
    else

      val(c,0,0,0) = n/d;
  }}    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
#line 329 "/home/pwachara/basilisk/src/poisson.h"
}
#line 347 "/home/pwachara/basilisk/src/poisson.h"
}






static double residual (scalar * al, scalar * bl, scalar * resl, void * data)
{
  scalar a = al[0], b = bl[0], res = resl[0];
  struct Poisson * p = (struct Poisson *) data;
          vector alpha = p->alpha;
          scalar lambda = p->lambda;
  double maxres = 0.;
#line 381 "/home/pwachara/basilisk/src/poisson.h"
  if(!is_constant(lambda) && !is_constant(alpha.x)){
  
#line 381 "/home/pwachara/basilisk/src/poisson.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/poisson.h", .line = 381, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{ 
_stencil_val(b,0,0,0); _stencil_val(lambda,0,0,0);_stencil_val(a,0,0,0);    _stencil_val_a(res,0,0,0);  
    
      {_stencil_val(alpha.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0 -1,0,0);
  _stencil_val(alpha.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, a, 1);_stencil_val(a,1,0,0); _stencil_val(a,1 -1,0,0);
#line 384
_stencil_val_r(res,0,0,0);                       
}      
#line 384
{_stencil_val(alpha.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0 -1,0);
  _stencil_val(alpha.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, a, 1);_stencil_val(a,0,1,0); _stencil_val(a,0,1 -1,0);
#line 384
_stencil_val_r(res,0,0,0);                       
}      
#line 384
{_stencil_val(alpha.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0,0 -1);
  _stencil_val(alpha.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, a, 1);_stencil_val(a,0,0,1); _stencil_val(a,0,0,1 -1);
#line 384
_stencil_val_r(res,0,0,0);                       
}

    if (p->embed_flux) {   
      default_stencil ( point,((scalar[]){alpha.x , alpha.y, alpha.z, a,{-1}}) );
_stencil_val(a,0,0,0);      _stencil_val_r(res,0,0,0);    
    }

_stencil_val(res,0,0,0);
      {_stencil_val(res,0,0,0);   }  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{
    val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
    
      val(res,0,0,0) += (val(alpha.x,0,0,0)*(_attribute[a.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, a, 0) : (val(a,0,0,0) - val(a,0 -1,0,0))/Delta) -
  val(alpha.x,1,0,0)*(_attribute[a.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, a, 1) : (val(a,1,0,0) - val(a,1 -1,0,0))/Delta))/Delta;      
#line 384
val(res,0,0,0) += (val(alpha.y,0,0,0)*(_attribute[a.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, a, 0) : (val(a,0,0,0) - val(a,0,0 -1,0))/Delta) -
  val(alpha.y,0,1,0)*(_attribute[a.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, a, 1) : (val(a,0,1,0) - val(a,0,1 -1,0))/Delta))/Delta;      
#line 384
val(res,0,0,0) += (val(alpha.z,0,0,0)*(_attribute[a.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, a, 0) : (val(a,0,0,0) - val(a,0,0,0 -1))/Delta) -
  val(alpha.z,0,0,1)*(_attribute[a.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, a, 1) : (val(a,0,0,1) - val(a,0,0,1 -1))/Delta))/Delta;

    if (p->embed_flux) {
      double c, e = p->embed_flux (point, a, alpha, &c);
      val(res,0,0,0) += c - e*val(a,0,0,0);
    }

    if (fabs (val(res,0,0,0)) > maxres)
      maxres = fabs (val(res,0,0,0));
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 394 "/home/pwachara/basilisk/src/poisson.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(lambda) && !is_constant(alpha.x)){double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);
  
#line 381 "/home/pwachara/basilisk/src/poisson.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/poisson.h", .line = 381, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{ 
_stencil_val(b,0,0,0);;_stencil_val(a,0,0,0);    _stencil_val_a(res,0,0,0);  
    
      {_stencil_val(alpha.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0 -1,0,0);
  _stencil_val(alpha.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, a, 1);_stencil_val(a,1,0,0); _stencil_val(a,1 -1,0,0);
#line 384
_stencil_val_r(res,0,0,0);                       
}      
#line 384
{_stencil_val(alpha.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0 -1,0);
  _stencil_val(alpha.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, a, 1);_stencil_val(a,0,1,0); _stencil_val(a,0,1 -1,0);
#line 384
_stencil_val_r(res,0,0,0);                       
}      
#line 384
{_stencil_val(alpha.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0,0 -1);
  _stencil_val(alpha.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, a, 1);_stencil_val(a,0,0,1); _stencil_val(a,0,0,1 -1);
#line 384
_stencil_val_r(res,0,0,0);                       
}

    if (p->embed_flux) {   
      default_stencil ( point,((scalar[]){alpha.x , alpha.y, alpha.z, a,{-1}}) );
_stencil_val(a,0,0,0);      _stencil_val_r(res,0,0,0);    
    }

_stencil_val(res,0,0,0);
      {_stencil_val(res,0,0,0);   }  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{
    val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
    
      val(res,0,0,0) += (val(alpha.x,0,0,0)*(_attribute[a.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, a, 0) : (val(a,0,0,0) - val(a,0 -1,0,0))/Delta) -
  val(alpha.x,1,0,0)*(_attribute[a.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, a, 1) : (val(a,1,0,0) - val(a,1 -1,0,0))/Delta))/Delta;      
#line 384
val(res,0,0,0) += (val(alpha.y,0,0,0)*(_attribute[a.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, a, 0) : (val(a,0,0,0) - val(a,0,0 -1,0))/Delta) -
  val(alpha.y,0,1,0)*(_attribute[a.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, a, 1) : (val(a,0,1,0) - val(a,0,1 -1,0))/Delta))/Delta;      
#line 384
val(res,0,0,0) += (val(alpha.z,0,0,0)*(_attribute[a.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, a, 0) : (val(a,0,0,0) - val(a,0,0,0 -1))/Delta) -
  val(alpha.z,0,0,1)*(_attribute[a.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, a, 1) : (val(a,0,0,1) - val(a,0,0,1 -1))/Delta))/Delta;

    if (p->embed_flux) {
      double c, e = p->embed_flux (point, a, alpha, &c);
      val(res,0,0,0) += c - e*val(a,0,0,0);
    }

    if (fabs (val(res,0,0,0)) > maxres)
      maxres = fabs (val(res,0,0,0));
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 394 "/home/pwachara/basilisk/src/poisson.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(lambda) && is_constant(alpha.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
#line 381 "/home/pwachara/basilisk/src/poisson.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/poisson.h", .line = 381, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{ 
_stencil_val(b,0,0,0); _stencil_val(lambda,0,0,0);_stencil_val(a,0,0,0);    _stencil_val_a(res,0,0,0);  
    
      {; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0 -1,0,0);
; _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, a, 1);_stencil_val(a,1,0,0); _stencil_val(a,1 -1,0,0);
#line 384
_stencil_val_r(res,0,0,0);                       
}      
#line 384
{; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0 -1,0);
; _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, a, 1);_stencil_val(a,0,1,0); _stencil_val(a,0,1 -1,0);
#line 384
_stencil_val_r(res,0,0,0);                       
}      
#line 384
{; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0,0 -1);
; _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, a, 1);_stencil_val(a,0,0,1); _stencil_val(a,0,0,1 -1);
#line 384
_stencil_val_r(res,0,0,0);                       
}

    if (p->embed_flux) {   
      default_stencil ( point,((scalar[]){alpha.x , alpha.y, alpha.z, a,{-1}}) );
_stencil_val(a,0,0,0);      _stencil_val_r(res,0,0,0);    
    }

_stencil_val(res,0,0,0);
      {_stencil_val(res,0,0,0);   }  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{
    val(res,0,0,0) = val(b,0,0,0) - val(lambda,0,0,0)*val(a,0,0,0);
    
      val(res,0,0,0) += (_const_alpha.x*(_attribute[a.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, a, 0) : (val(a,0,0,0) - val(a,0 -1,0,0))/Delta) -
  _const_alpha.x*(_attribute[a.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, a, 1) : (val(a,1,0,0) - val(a,1 -1,0,0))/Delta))/Delta;      
#line 384
val(res,0,0,0) += (_const_alpha.y*(_attribute[a.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, a, 0) : (val(a,0,0,0) - val(a,0,0 -1,0))/Delta) -
  _const_alpha.y*(_attribute[a.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, a, 1) : (val(a,0,1,0) - val(a,0,1 -1,0))/Delta))/Delta;      
#line 384
val(res,0,0,0) += (_const_alpha.z*(_attribute[a.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, a, 0) : (val(a,0,0,0) - val(a,0,0,0 -1))/Delta) -
  _const_alpha.z*(_attribute[a.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, a, 1) : (val(a,0,0,1) - val(a,0,0,1 -1))/Delta))/Delta;

    if (p->embed_flux) {
      double c, e = p->embed_flux (point, a, alpha, &c);
      val(res,0,0,0) += c - e*val(a,0,0,0);
    }

    if (fabs (val(res,0,0,0)) > maxres)
      maxres = fabs (val(res,0,0,0));
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 394 "/home/pwachara/basilisk/src/poisson.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else {double _const_lambda=_constant[lambda.i-_NVARMAX];NOT_UNUSED(_const_lambda);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
#line 381 "/home/pwachara/basilisk/src/poisson.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/poisson.h", .line = 381, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{ 
_stencil_val(b,0,0,0);;_stencil_val(a,0,0,0);    _stencil_val_a(res,0,0,0);  
    
      {; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0 -1,0,0);
; _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, a, 1);_stencil_val(a,1,0,0); _stencil_val(a,1 -1,0,0);
#line 384
_stencil_val_r(res,0,0,0);                       
}      
#line 384
{; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0 -1,0);
; _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, a, 1);_stencil_val(a,0,1,0); _stencil_val(a,0,1 -1,0);
#line 384
_stencil_val_r(res,0,0,0);                       
}      
#line 384
{; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, a, 0);_stencil_val(a,0,0,0); _stencil_val(a,0,0,0 -1);
; _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, a, 1);_stencil_val(a,0,0,1); _stencil_val(a,0,0,1 -1);
#line 384
_stencil_val_r(res,0,0,0);                       
}

    if (p->embed_flux) {   
      default_stencil ( point,((scalar[]){alpha.x , alpha.y, alpha.z, a,{-1}}) );
_stencil_val(a,0,0,0);      _stencil_val_r(res,0,0,0);    
    }

_stencil_val(res,0,0,0);
      {_stencil_val(res,0,0,0);   }  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 381 "/home/pwachara/basilisk/src/poisson.h"
{
    val(res,0,0,0) = val(b,0,0,0) - _const_lambda*val(a,0,0,0);
    
      val(res,0,0,0) += (_const_alpha.x*(_attribute[a.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, a, 0) : (val(a,0,0,0) - val(a,0 -1,0,0))/Delta) -
  _const_alpha.x*(_attribute[a.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, a, 1) : (val(a,1,0,0) - val(a,1 -1,0,0))/Delta))/Delta;      
#line 384
val(res,0,0,0) += (_const_alpha.y*(_attribute[a.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, a, 0) : (val(a,0,0,0) - val(a,0,0 -1,0))/Delta) -
  _const_alpha.y*(_attribute[a.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, a, 1) : (val(a,0,1,0) - val(a,0,1 -1,0))/Delta))/Delta;      
#line 384
val(res,0,0,0) += (_const_alpha.z*(_attribute[a.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, a, 0) : (val(a,0,0,0) - val(a,0,0,0 -1))/Delta) -
  _const_alpha.z*(_attribute[a.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, a, 1) : (val(a,0,0,1) - val(a,0,0,1 -1))/Delta))/Delta;

    if (p->embed_flux) {
      double c, e = p->embed_flux (point, a, alpha, &c);
      val(res,0,0,0) += c - e*val(a,0,0,0);
    }

    if (fabs (val(res,0,0,0)) > maxres)
      maxres = fabs (val(res,0,0,0));
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 394 "/home/pwachara/basilisk/src/poisson.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}

  return maxres;
}
#line 408 "/home/pwachara/basilisk/src/poisson.h"
     
mgstats poisson (scalar a, scalar b,
           vector alpha,
           scalar lambda,
   double tolerance,
   int nrelax,
   int minlevel,
   scalar * res,
   double (* flux) (Point, scalar, vector, double *))
{tracing("poisson","/home/pwachara/basilisk/src/poisson.h",409);






  if (alpha.x.i < 0)
    alpha = new_const_vector("alpha",0,(double[]) {1.,1.,1.});
  if (lambda.i < 0)
    lambda = new_const_scalar("lambda",3, 0.);






  restriction (((scalar[]){alpha.x,alpha.y,alpha.z,lambda,{-1}}));





  double defaultol = TOLERANCE;
  if (tolerance)
    TOLERANCE = tolerance;

  struct Poisson p = {a, b, alpha, lambda, tolerance, nrelax, minlevel, res };

  if (!flux && _attribute[a.i].boundary[embed] != symmetry)
    p.embed_flux = embed_flux;
  else
    p.embed_flux = flux;

  mgstats s = mg_solve ((
#line 128
scalar *
#line 451
)((scalar[]){a,{-1}}),( 
#line 128
scalar *
#line 451
)((scalar[]) {b,{-1}}), residual, relax, &p
,   nrelax, res, ( 1 > minlevel ? 1 : minlevel)
#line 136
, 
TOLERANCE
#line 452
);




  if (tolerance)
    TOLERANCE = defaultol;

  {end_tracing("poisson","/home/pwachara/basilisk/src/poisson.h",460);return s;}
end_tracing("poisson","/home/pwachara/basilisk/src/poisson.h",461);}
#line 480 "/home/pwachara/basilisk/src/poisson.h"
     
mgstats project (vector uf, scalar p,
           vector alpha,
   double dt,
   int nrelax)
{tracing("project","/home/pwachara/basilisk/src/poisson.h",481);






  scalar  div=new_scalar("div");  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/poisson.h", .line = 493, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 493 "/home/pwachara/basilisk/src/poisson.h"
{
    _stencil_val_a(div,0,0,0);  
    
      { _stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);_stencil_val_r(div,0,0,0);  }      { _stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);_stencil_val_r(div,0,0,0);  }      { _stencil_val(uf.z,0,0,1); _stencil_val(uf.z,0,0,0);_stencil_val_r(div,0,0,0);  }
    _stencil_val_r(div,0,0,0);  
  }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 493 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 493 "/home/pwachara/basilisk/src/poisson.h"
{
    val(div,0,0,0) = 0.;
    
      val(div,0,0,0) += val(uf.x,1,0,0) - val(uf.x,0,0,0);      val(div,0,0,0) += val(uf.y,0,1,0) - val(uf.y,0,0,0);      val(div,0,0,0) += val(uf.z,0,0,1) - val(uf.z,0,0,0);
    val(div,0,0,0) /= dt*Delta;
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 509 "/home/pwachara/basilisk/src/poisson.h"
  mgstats mgp = poisson (p, div, alpha
#line 410
,
( scalar) {-1}
#line 510
, TOLERANCE/( dt*dt), nrelax
#line 413
, 
0, 
NULL, 
NULL
#line 510
);




if(!is_constant(alpha.x)){  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/poisson.h", .line = 515, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 515 "/home/pwachara/basilisk/src/poisson.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{_stencil_val(alpha.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0 -1,0,0);_stencil_val_r(uf.x,0,0,0);            } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{_stencil_val(alpha.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0,0 -1,0);_stencil_val_r(uf.y,0,0,0);            } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{_stencil_val(alpha.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0,0,0 -1);_stencil_val_r(uf.z,0,0,0);            }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 515 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 516 "/home/pwachara/basilisk/src/poisson.h"
val(uf.x,0,0,0) -= dt*val(alpha.x,0,0,0)*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 516 "/home/pwachara/basilisk/src/poisson.h"
val(uf.y,0,0,0) -= dt*val(alpha.y,0,0,0)*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 516 "/home/pwachara/basilisk/src/poisson.h"
val(uf.z,0,0,0) -= dt*val(alpha.z,0,0,0)*(_attribute[p.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, p, 0) : (val(p,0,0,0) - val(p,0,0,0 -1))/Delta);}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 516 "/home/pwachara/basilisk/src/poisson.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 516 "/home/pwachara/basilisk/src/poisson.h"
}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/poisson.h", .line = 515, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 515 "/home/pwachara/basilisk/src/poisson.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0 -1,0,0);_stencil_val_r(uf.x,0,0,0);            } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0,0 -1,0);_stencil_val_r(uf.y,0,0,0);            } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, p, 0);_stencil_val(p,0,0,0); _stencil_val(p,0,0,0 -1);_stencil_val_r(uf.z,0,0,0);            }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 515 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 516 "/home/pwachara/basilisk/src/poisson.h"
val(uf.x,0,0,0) -= dt*_const_alpha.x*(_attribute[p.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, p, 0) : (val(p,0,0,0) - val(p,0 -1,0,0))/Delta);}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 516 "/home/pwachara/basilisk/src/poisson.h"
val(uf.y,0,0,0) -= dt*_const_alpha.y*(_attribute[p.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, p, 0) : (val(p,0,0,0) - val(p,0,0 -1,0))/Delta);}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 516 "/home/pwachara/basilisk/src/poisson.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 516 "/home/pwachara/basilisk/src/poisson.h"
val(uf.z,0,0,0) -= dt*_const_alpha.z*(_attribute[p.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, p, 0) : (val(p,0,0,0) - val(p,0,0,0 -1))/Delta);}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 516 "/home/pwachara/basilisk/src/poisson.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 516 "/home/pwachara/basilisk/src/poisson.h"
}

  {delete((scalar*)((scalar[]){div,{-1}}));{end_tracing("project","/home/pwachara/basilisk/src/poisson.h",518);return mgp;}}delete((scalar*)((scalar[]){div,{-1}}));
end_tracing("project","/home/pwachara/basilisk/src/poisson.h",519);}
#line 32 "/home/pwachara/basilisk/src/viscosity-embed.h"

struct Viscosity {
  vector mu;
  scalar rho;
  double dt;
  double (* embed_flux) (Point, scalar, vector, double *);
};
#line 52 "/home/pwachara/basilisk/src/viscosity-embed.h"
static void relax_diffusion (scalar * a, scalar * b, int l, void * data)
{
  struct Viscosity * p = (struct Viscosity *) data;
          vector mu = p->mu;
          scalar rho = p->rho;
  double dt = p->dt;
  vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0])));

  double (* embed_flux) (Point, scalar, vector, double *) = p->embed_flux;
  if(!is_constant(mu.x) && !is_constant(rho)){
  
  
  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{   
    
    
      { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }      { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }      { _stencil_val(mu.z,0,0,0); _stencil_val(mu.z,0,0,1);  }
        
     {         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.x,{-1}}) );
      scalar s = u.x;   
      
      
 { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } { _stencil_val(mu.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(mu.z,0,0,0);_stencil_val(s,0,0,-1);  }
_stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);      
#line 73
_stencil_val_a(u.x,0,0,0);              
 
    } 
#line 66
{         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.y,{-1}}) );
      scalar s = u.y;   
      
      
 { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } { _stencil_val(mu.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(mu.z,0,0,0);_stencil_val(s,0,0,-1);  } { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }
_stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);      
#line 73
_stencil_val_a(u.y,0,0,0);              
 
    } 
#line 66
{         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.z,{-1}}) );
      scalar s = u.z;   
      
      
 { _stencil_val(mu.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(mu.z,0,0,0);_stencil_val(s,0,0,-1);  } { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }
_stencil_val(r.z,0,0,0);
_stencil_val(rho,0,0,0);      
#line 73
_stencil_val_a(u.z,0,0,0);              
 
    }
  }
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 7 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{
    double avgmu = 0.;
    
      avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);      avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);      avgmu += val(mu.z,0,0,0) + val(mu.z,0,0,1);
    avgmu = dt*avgmu + 1e-30;
     {
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.x, mu, &c) : 0.;
      scalar s = u.x;
      double a = 0.;
      
 a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0); a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0); a += val(mu.z,0,0,1)*val(s,0,0,1) + val(mu.z,0,0,0)*val(s,0,0,-1);
      val(u.x,0,0,0) = (dt*a + (val(r.x,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(val(rho,0,0,0) + ((coord){0.,0.,0.}).x + dt*d) + avgmu);
    } 
#line 66
{
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.y, mu, &c) : 0.;
      scalar s = u.y;
      double a = 0.;
      
 a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0); a += val(mu.z,0,0,1)*val(s,0,0,1) + val(mu.z,0,0,0)*val(s,0,0,-1); a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
      val(u.y,0,0,0) = (dt*a + (val(r.y,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(val(rho,0,0,0) + ((coord){0.,0.,0.}).y + dt*d) + avgmu);
    } 
#line 66
{
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.z, mu, &c) : 0.;
      scalar s = u.z;
      double a = 0.;
      
 a += val(mu.z,0,0,1)*val(s,0,0,1) + val(mu.z,0,0,0)*val(s,0,0,-1); a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0); a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
      val(u.z,0,0,0) = (dt*a + (val(r.z,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(val(rho,0,0,0) + ((coord){0.,0.,0.}).z + dt*d) + avgmu);
    }
  }}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
#line 76 "/home/pwachara/basilisk/src/viscosity-embed.h"
}else if(is_constant(mu.x) && !is_constant(rho)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX],_constant[mu.z.i-_NVARMAX]};NOT_UNUSED(_const_mu);
  
  
  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{   
    
    
      {;;  }      {;;  }      {;;  }
        
     {         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.x,{-1}}) );
      scalar s = u.x;   
      
      
 {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } {;_stencil_val(s,0,0,1);;_stencil_val(s,0,0,-1);  }
_stencil_val(r.x,0,0,0);
_stencil_val(rho,0,0,0);      
#line 73
_stencil_val_a(u.x,0,0,0);              
 
    } 
#line 66
{         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.y,{-1}}) );
      scalar s = u.y;   
      
      
 {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } {;_stencil_val(s,0,0,1);;_stencil_val(s,0,0,-1);  } {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }
_stencil_val(r.y,0,0,0);
_stencil_val(rho,0,0,0);      
#line 73
_stencil_val_a(u.y,0,0,0);              
 
    } 
#line 66
{         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.z,{-1}}) );
      scalar s = u.z;   
      
      
 {;_stencil_val(s,0,0,1);;_stencil_val(s,0,0,-1);  } {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }
_stencil_val(r.z,0,0,0);
_stencil_val(rho,0,0,0);      
#line 73
_stencil_val_a(u.z,0,0,0);              
 
    }
  }
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 7 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{
    double avgmu = 0.;
    
      avgmu += _const_mu.x + _const_mu.x;      avgmu += _const_mu.y + _const_mu.y;      avgmu += _const_mu.z + _const_mu.z;
    avgmu = dt*avgmu + 1e-30;
     {
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.x, mu, &c) : 0.;
      scalar s = u.x;
      double a = 0.;
      
 a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0); a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0); a += _const_mu.z*val(s,0,0,1) + _const_mu.z*val(s,0,0,-1);
      val(u.x,0,0,0) = (dt*a + (val(r.x,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(val(rho,0,0,0) + ((coord){0.,0.,0.}).x + dt*d) + avgmu);
    } 
#line 66
{
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.y, mu, &c) : 0.;
      scalar s = u.y;
      double a = 0.;
      
 a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0); a += _const_mu.z*val(s,0,0,1) + _const_mu.z*val(s,0,0,-1); a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
      val(u.y,0,0,0) = (dt*a + (val(r.y,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(val(rho,0,0,0) + ((coord){0.,0.,0.}).y + dt*d) + avgmu);
    } 
#line 66
{
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.z, mu, &c) : 0.;
      scalar s = u.z;
      double a = 0.;
      
 a += _const_mu.z*val(s,0,0,1) + _const_mu.z*val(s,0,0,-1); a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0); a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
      val(u.z,0,0,0) = (dt*a + (val(r.z,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(val(rho,0,0,0) + ((coord){0.,0.,0.}).z + dt*d) + avgmu);
    }
  }}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
#line 76 "/home/pwachara/basilisk/src/viscosity-embed.h"
}else if(!is_constant(mu.x) && is_constant(rho)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);
  
  
  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{   
    
    
      { _stencil_val(mu.x,0,0,0); _stencil_val(mu.x,1,0,0);  }      { _stencil_val(mu.y,0,0,0); _stencil_val(mu.y,0,1,0);  }      { _stencil_val(mu.z,0,0,0); _stencil_val(mu.z,0,0,1);  }
        
     {         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.x,{-1}}) );
      scalar s = u.x;   
      
      
 { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } { _stencil_val(mu.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(mu.z,0,0,0);_stencil_val(s,0,0,-1);  }
_stencil_val(r.x,0,0,0);
;      
#line 73
_stencil_val_a(u.x,0,0,0);              
 
    } 
#line 66
{         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.y,{-1}}) );
      scalar s = u.y;   
      
      
 { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  } { _stencil_val(mu.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(mu.z,0,0,0);_stencil_val(s,0,0,-1);  } { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  }
_stencil_val(r.y,0,0,0);
;      
#line 73
_stencil_val_a(u.y,0,0,0);              
 
    } 
#line 66
{         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.z,{-1}}) );
      scalar s = u.z;   
      
      
 { _stencil_val(mu.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(mu.z,0,0,0);_stencil_val(s,0,0,-1);  } { _stencil_val(mu.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(mu.x,0,0,0);_stencil_val(s,-1,0,0);  } { _stencil_val(mu.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(mu.y,0,0,0);_stencil_val(s,0,-1,0);  }
_stencil_val(r.z,0,0,0);
;      
#line 73
_stencil_val_a(u.z,0,0,0);              
 
    }
  }
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 7 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{
    double avgmu = 0.;
    
      avgmu += val(mu.x,0,0,0) + val(mu.x,1,0,0);      avgmu += val(mu.y,0,0,0) + val(mu.y,0,1,0);      avgmu += val(mu.z,0,0,0) + val(mu.z,0,0,1);
    avgmu = dt*avgmu + 1e-30;
     {
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.x, mu, &c) : 0.;
      scalar s = u.x;
      double a = 0.;
      
 a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0); a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0); a += val(mu.z,0,0,1)*val(s,0,0,1) + val(mu.z,0,0,0)*val(s,0,0,-1);
      val(u.x,0,0,0) = (dt*a + (val(r.x,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(_const_rho + ((coord){0.,0.,0.}).x + dt*d) + avgmu);
    } 
#line 66
{
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.y, mu, &c) : 0.;
      scalar s = u.y;
      double a = 0.;
      
 a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0); a += val(mu.z,0,0,1)*val(s,0,0,1) + val(mu.z,0,0,0)*val(s,0,0,-1); a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0);
      val(u.y,0,0,0) = (dt*a + (val(r.y,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(_const_rho + ((coord){0.,0.,0.}).y + dt*d) + avgmu);
    } 
#line 66
{
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.z, mu, &c) : 0.;
      scalar s = u.z;
      double a = 0.;
      
 a += val(mu.z,0,0,1)*val(s,0,0,1) + val(mu.z,0,0,0)*val(s,0,0,-1); a += val(mu.x,1,0,0)*val(s,1,0,0) + val(mu.x,0,0,0)*val(s,-1,0,0); a += val(mu.y,0,1,0)*val(s,0,1,0) + val(mu.y,0,0,0)*val(s,0,-1,0);
      val(u.z,0,0,0) = (dt*a + (val(r.z,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(_const_rho + ((coord){0.,0.,0.}).z + dt*d) + avgmu);
    }
  }}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
#line 76 "/home/pwachara/basilisk/src/viscosity-embed.h"
}else {_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX],_constant[mu.z.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);
  
  
  
#line 347 "/home/pwachara/basilisk/src/grid/stencils.h"
if (0) {

    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{   
    
    
      {;;  }      {;;  }      {;;  }
        
     {         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.x,{-1}}) );
      scalar s = u.x;   
      
      
 {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } {;_stencil_val(s,0,0,1);;_stencil_val(s,0,0,-1);  }
_stencil_val(r.x,0,0,0);
;      
#line 73
_stencil_val_a(u.x,0,0,0);              
 
    } 
#line 66
{         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.y,{-1}}) );
      scalar s = u.y;   
      
      
 {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  } {;_stencil_val(s,0,0,1);;_stencil_val(s,0,0,-1);  } {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  }
_stencil_val(r.y,0,0,0);
;      
#line 73
_stencil_val_a(u.y,0,0,0);              
 
    } 
#line 66
{         
      
      default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.z,{-1}}) );
      scalar s = u.z;   
      
      
 {;_stencil_val(s,0,0,1);;_stencil_val(s,0,0,-1);  } {;_stencil_val(s,1,0,0);;_stencil_val(s,-1,0,0);  } {;_stencil_val(s,0,1,0);;_stencil_val(s,0,-1,0);  }
_stencil_val(r.z,0,0,0);
;      
#line 73
_stencil_val_a(u.z,0,0,0);              
 
    }
  }
  
#line 352 "/home/pwachara/basilisk/src/grid/stencils.h"
}
#line 7 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
{ 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = l;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 61 "/home/pwachara/basilisk/src/viscosity-embed.h"
{
    double avgmu = 0.;
    
      avgmu += _const_mu.x + _const_mu.x;      avgmu += _const_mu.y + _const_mu.y;      avgmu += _const_mu.z + _const_mu.z;
    avgmu = dt*avgmu + 1e-30;
     {
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.x, mu, &c) : 0.;
      scalar s = u.x;
      double a = 0.;
      
 a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0); a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0); a += _const_mu.z*val(s,0,0,1) + _const_mu.z*val(s,0,0,-1);
      val(u.x,0,0,0) = (dt*a + (val(r.x,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(_const_rho + ((coord){0.,0.,0.}).x + dt*d) + avgmu);
    } 
#line 66
{
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.y, mu, &c) : 0.;
      scalar s = u.y;
      double a = 0.;
      
 a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0); a += _const_mu.z*val(s,0,0,1) + _const_mu.z*val(s,0,0,-1); a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0);
      val(u.y,0,0,0) = (dt*a + (val(r.y,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(_const_rho + ((coord){0.,0.,0.}).y + dt*d) + avgmu);
    } 
#line 66
{
      double c = 0.;
      double d = embed_flux ? embed_flux (point, u.z, mu, &c) : 0.;
      scalar s = u.z;
      double a = 0.;
      
 a += _const_mu.z*val(s,0,0,1) + _const_mu.z*val(s,0,0,-1); a += _const_mu.x*val(s,1,0,0) + _const_mu.x*val(s,-1,0,0); a += _const_mu.y*val(s,0,1,0) + _const_mu.y*val(s,0,-1,0);
      val(u.z,0,0,0) = (dt*a + (val(r.z,0,0,0) - dt*c)*( Delta*Delta))/
 (( Delta*Delta)*(_const_rho + ((coord){0.,0.,0.}).z + dt*d) + avgmu);
    }
  }}
    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 10 "/home/pwachara/basilisk/src/grid/multigrid-common.h"
}
#line 76 "/home/pwachara/basilisk/src/viscosity-embed.h"
}
#line 88 "/home/pwachara/basilisk/src/viscosity-embed.h"
}

static double residual_diffusion (scalar * a, scalar * b, scalar * resl,
      void * data)
{
  struct Viscosity * p = (struct Viscosity *) data;
          vector mu = p->mu;
          scalar rho = p->rho;
  double dt = p->dt;
  double (* embed_flux) (Point, scalar, vector, double *) = p->embed_flux;
  vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0]))), res = (*((vector *)&(resl[0])));
  double maxres = 0.;
#line 122 "/home/pwachara/basilisk/src/viscosity-embed.h"
  if(!is_constant(mu.x) && !is_constant(rho)){
  
#line 122 "/home/pwachara/basilisk/src/viscosity-embed.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/viscosity-embed.h", .line = 122, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{ {
      scalar s = u.x;   
      
      
 { _stencil_val(mu.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } { _stencil_val(mu.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0); _stencil_val(mu.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } { _stencil_val(mu.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1); _stencil_val(mu.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(u.x,0,0,0);      _stencil_val_a(res.x,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.x,{-1}}) );
_stencil_val(u.x,0,0,0); _stencil_val_r(res.x,0,0,0);    
      }
_stencil_val(res.x,0,0,0);
 {_stencil_val(res.x,0,0,0);   }    
} 
#line 123
{
      scalar s = u.y;   
      
      
 { _stencil_val(mu.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0); _stencil_val(mu.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } { _stencil_val(mu.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1); _stencil_val(mu.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } { _stencil_val(mu.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(u.y,0,0,0);      _stencil_val_a(res.y,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.y,{-1}}) );
_stencil_val(u.y,0,0,0); _stencil_val_r(res.y,0,0,0);    
      }
_stencil_val(res.y,0,0,0);
 {_stencil_val(res.y,0,0,0);   }    
} 
#line 123
{
      scalar s = u.z;   
      
      
 { _stencil_val(mu.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1); _stencil_val(mu.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } { _stencil_val(mu.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } { _stencil_val(mu.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0); _stencil_val(mu.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } 
_stencil_val(r.z,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(u.z,0,0,0);      _stencil_val_a(res.z,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.z,{-1}}) );
_stencil_val(u.z,0,0,0); _stencil_val_r(res.z,0,0,0);    
      }
_stencil_val(res.z,0,0,0);
 {_stencil_val(res.z,0,0,0);   }    
}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{ {
      scalar s = u.x;
      double a = 0.;
      
 a += val(mu.x,0,0,0)*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - val(mu.x,1,0,0)*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta); a += val(mu.y,0,0,0)*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - val(mu.y,0,1,0)*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta); a += val(mu.z,0,0,0)*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - val(mu.z,0,0,1)*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta);
      val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0.,0.,0.}).x)*val(u.x,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.x, mu, &c);
 val(res.x,0,0,0) -= dt*(c + d*val(u.x,0,0,0));
      }
      if (fabs (val(res.x,0,0,0)) > maxres)
 maxres = fabs (val(res.x,0,0,0));
    } 
#line 123
{
      scalar s = u.y;
      double a = 0.;
      
 a += val(mu.y,0,0,0)*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - val(mu.y,0,1,0)*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta); a += val(mu.z,0,0,0)*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - val(mu.z,0,0,1)*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta); a += val(mu.x,0,0,0)*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - val(mu.x,1,0,0)*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta);
      val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0.,0.,0.}).y)*val(u.y,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.y, mu, &c);
 val(res.y,0,0,0) -= dt*(c + d*val(u.y,0,0,0));
      }
      if (fabs (val(res.y,0,0,0)) > maxres)
 maxres = fabs (val(res.y,0,0,0));
    } 
#line 123
{
      scalar s = u.z;
      double a = 0.;
      
 a += val(mu.z,0,0,0)*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - val(mu.z,0,0,1)*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta); a += val(mu.x,0,0,0)*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - val(mu.x,1,0,0)*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta); a += val(mu.y,0,0,0)*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - val(mu.y,0,1,0)*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta);
      val(res.z,0,0,0) = val(r.z,0,0,0) - (val(rho,0,0,0) + ((coord){0.,0.,0.}).z)*val(u.z,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.z, mu, &c);
 val(res.z,0,0,0) -= dt*(c + d*val(u.z,0,0,0));
      }
      if (fabs (val(res.z,0,0,0)) > maxres)
 maxres = fabs (val(res.z,0,0,0));
    }}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 135 "/home/pwachara/basilisk/src/viscosity-embed.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(mu.x) && !is_constant(rho)){_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX],_constant[mu.z.i-_NVARMAX]};NOT_UNUSED(_const_mu);
  
#line 122 "/home/pwachara/basilisk/src/viscosity-embed.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/viscosity-embed.h", .line = 122, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{ {
      scalar s = u.x;   
      
      
 {; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);; _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } {; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);; _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } {; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1);; _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } 
_stencil_val(r.x,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(u.x,0,0,0);      _stencil_val_a(res.x,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.x,{-1}}) );
_stencil_val(u.x,0,0,0); _stencil_val_r(res.x,0,0,0);    
      }
_stencil_val(res.x,0,0,0);
 {_stencil_val(res.x,0,0,0);   }    
} 
#line 123
{
      scalar s = u.y;   
      
      
 {; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);; _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } {; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1);; _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } {; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);; _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } 
_stencil_val(r.y,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(u.y,0,0,0);      _stencil_val_a(res.y,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.y,{-1}}) );
_stencil_val(u.y,0,0,0); _stencil_val_r(res.y,0,0,0);    
      }
_stencil_val(res.y,0,0,0);
 {_stencil_val(res.y,0,0,0);   }    
} 
#line 123
{
      scalar s = u.z;   
      
      
 {; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1);; _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } {; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);; _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } {; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);; _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } 
_stencil_val(r.z,0,0,0);_stencil_val(rho,0,0,0);_stencil_val(u.z,0,0,0);      _stencil_val_a(res.z,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.z,{-1}}) );
_stencil_val(u.z,0,0,0); _stencil_val_r(res.z,0,0,0);    
      }
_stencil_val(res.z,0,0,0);
 {_stencil_val(res.z,0,0,0);   }    
}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{ {
      scalar s = u.x;
      double a = 0.;
      
 a += _const_mu.x*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - _const_mu.x*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta); a += _const_mu.y*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - _const_mu.y*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta); a += _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta);
      val(res.x,0,0,0) = val(r.x,0,0,0) - (val(rho,0,0,0) + ((coord){0.,0.,0.}).x)*val(u.x,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.x, mu, &c);
 val(res.x,0,0,0) -= dt*(c + d*val(u.x,0,0,0));
      }
      if (fabs (val(res.x,0,0,0)) > maxres)
 maxres = fabs (val(res.x,0,0,0));
    } 
#line 123
{
      scalar s = u.y;
      double a = 0.;
      
 a += _const_mu.y*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - _const_mu.y*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta); a += _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta); a += _const_mu.x*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - _const_mu.x*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta);
      val(res.y,0,0,0) = val(r.y,0,0,0) - (val(rho,0,0,0) + ((coord){0.,0.,0.}).y)*val(u.y,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.y, mu, &c);
 val(res.y,0,0,0) -= dt*(c + d*val(u.y,0,0,0));
      }
      if (fabs (val(res.y,0,0,0)) > maxres)
 maxres = fabs (val(res.y,0,0,0));
    } 
#line 123
{
      scalar s = u.z;
      double a = 0.;
      
 a += _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta); a += _const_mu.x*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - _const_mu.x*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta); a += _const_mu.y*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - _const_mu.y*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta);
      val(res.z,0,0,0) = val(r.z,0,0,0) - (val(rho,0,0,0) + ((coord){0.,0.,0.}).z)*val(u.z,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.z, mu, &c);
 val(res.z,0,0,0) -= dt*(c + d*val(u.z,0,0,0));
      }
      if (fabs (val(res.z,0,0,0)) > maxres)
 maxres = fabs (val(res.z,0,0,0));
    }}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 135 "/home/pwachara/basilisk/src/viscosity-embed.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(mu.x) && is_constant(rho)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);
  
#line 122 "/home/pwachara/basilisk/src/viscosity-embed.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/viscosity-embed.h", .line = 122, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{ {
      scalar s = u.x;   
      
      
 { _stencil_val(mu.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } { _stencil_val(mu.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0); _stencil_val(mu.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } { _stencil_val(mu.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1); _stencil_val(mu.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } 
_stencil_val(r.x,0,0,0);;_stencil_val(u.x,0,0,0);      _stencil_val_a(res.x,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.x,{-1}}) );
_stencil_val(u.x,0,0,0); _stencil_val_r(res.x,0,0,0);    
      }
_stencil_val(res.x,0,0,0);
 {_stencil_val(res.x,0,0,0);   }    
} 
#line 123
{
      scalar s = u.y;   
      
      
 { _stencil_val(mu.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0); _stencil_val(mu.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } { _stencil_val(mu.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1); _stencil_val(mu.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } { _stencil_val(mu.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } 
_stencil_val(r.y,0,0,0);;_stencil_val(u.y,0,0,0);      _stencil_val_a(res.y,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.y,{-1}}) );
_stencil_val(u.y,0,0,0); _stencil_val_r(res.y,0,0,0);    
      }
_stencil_val(res.y,0,0,0);
 {_stencil_val(res.y,0,0,0);   }    
} 
#line 123
{
      scalar s = u.z;   
      
      
 { _stencil_val(mu.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1); _stencil_val(mu.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } { _stencil_val(mu.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0); _stencil_val(mu.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } { _stencil_val(mu.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0); _stencil_val(mu.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } 
_stencil_val(r.z,0,0,0);;_stencil_val(u.z,0,0,0);      _stencil_val_a(res.z,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.z,{-1}}) );
_stencil_val(u.z,0,0,0); _stencil_val_r(res.z,0,0,0);    
      }
_stencil_val(res.z,0,0,0);
 {_stencil_val(res.z,0,0,0);   }    
}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{ {
      scalar s = u.x;
      double a = 0.;
      
 a += val(mu.x,0,0,0)*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - val(mu.x,1,0,0)*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta); a += val(mu.y,0,0,0)*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - val(mu.y,0,1,0)*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta); a += val(mu.z,0,0,0)*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - val(mu.z,0,0,1)*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta);
      val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0.,0.,0.}).x)*val(u.x,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.x, mu, &c);
 val(res.x,0,0,0) -= dt*(c + d*val(u.x,0,0,0));
      }
      if (fabs (val(res.x,0,0,0)) > maxres)
 maxres = fabs (val(res.x,0,0,0));
    } 
#line 123
{
      scalar s = u.y;
      double a = 0.;
      
 a += val(mu.y,0,0,0)*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - val(mu.y,0,1,0)*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta); a += val(mu.z,0,0,0)*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - val(mu.z,0,0,1)*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta); a += val(mu.x,0,0,0)*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - val(mu.x,1,0,0)*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta);
      val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0.,0.,0.}).y)*val(u.y,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.y, mu, &c);
 val(res.y,0,0,0) -= dt*(c + d*val(u.y,0,0,0));
      }
      if (fabs (val(res.y,0,0,0)) > maxres)
 maxres = fabs (val(res.y,0,0,0));
    } 
#line 123
{
      scalar s = u.z;
      double a = 0.;
      
 a += val(mu.z,0,0,0)*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - val(mu.z,0,0,1)*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta); a += val(mu.x,0,0,0)*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - val(mu.x,1,0,0)*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta); a += val(mu.y,0,0,0)*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - val(mu.y,0,1,0)*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta);
      val(res.z,0,0,0) = val(r.z,0,0,0) - (_const_rho + ((coord){0.,0.,0.}).z)*val(u.z,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.z, mu, &c);
 val(res.z,0,0,0) -= dt*(c + d*val(u.z,0,0,0));
      }
      if (fabs (val(res.z,0,0,0)) > maxres)
 maxres = fabs (val(res.z,0,0,0));
    }}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 135 "/home/pwachara/basilisk/src/viscosity-embed.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}else {_coord _const_mu={_constant[mu.x.i-_NVARMAX],_constant[mu.y.i-_NVARMAX],_constant[mu.z.i-_NVARMAX]};NOT_UNUSED(_const_mu);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);
  
#line 122 "/home/pwachara/basilisk/src/viscosity-embed.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/viscosity-embed.h", .line = 122, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{ {
      scalar s = u.x;   
      
      
 {; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);; _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } {; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);; _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } {; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1);; _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } 
_stencil_val(r.x,0,0,0);;_stencil_val(u.x,0,0,0);      _stencil_val_a(res.x,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.x,{-1}}) );
_stencil_val(u.x,0,0,0); _stencil_val_r(res.x,0,0,0);    
      }
_stencil_val(res.x,0,0,0);
 {_stencil_val(res.x,0,0,0);   }    
} 
#line 123
{
      scalar s = u.y;   
      
      
 {; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);; _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } {; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1);; _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } {; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);; _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } 
_stencil_val(r.y,0,0,0);;_stencil_val(u.y,0,0,0);      _stencil_val_a(res.y,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.y,{-1}}) );
_stencil_val(u.y,0,0,0); _stencil_val_r(res.y,0,0,0);    
      }
_stencil_val(res.y,0,0,0);
 {_stencil_val(res.y,0,0,0);   }    
} 
#line 123
{
      scalar s = u.z;   
      
      
 {; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_gradient_z (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,0 -1);; _stencil_val(fs.z,0,0,1); _stencil_val(fs.z,0,0,1); _stencil_embed_face_gradient_z (point, s, 1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,1 -1);                      } {; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_gradient_x (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0 -1,0,0);; _stencil_val(fs.x,1,0,0); _stencil_val(fs.x,1,0,0); _stencil_embed_face_gradient_x (point, s, 1);_stencil_val(s,1,0,0); _stencil_val(s,1 -1,0,0);                      } {; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_gradient_y (point, s, 0);_stencil_val(s,0,0,0); _stencil_val(s,0,0 -1,0);; _stencil_val(fs.y,0,1,0); _stencil_val(fs.y,0,1,0); _stencil_embed_face_gradient_y (point, s, 1);_stencil_val(s,0,1,0); _stencil_val(s,0,1 -1,0);                      } 
_stencil_val(r.z,0,0,0);;_stencil_val(u.z,0,0,0);      _stencil_val_a(res.z,0,0,0);       
      if (embed_flux) {   
 default_stencil ( point,((scalar[]){mu.x , mu.y, mu.z, u.z,{-1}}) );
_stencil_val(u.z,0,0,0); _stencil_val_r(res.z,0,0,0);    
      }
_stencil_val(res.z,0,0,0);
 {_stencil_val(res.z,0,0,0);   }    
}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(max:maxres)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 123 "/home/pwachara/basilisk/src/viscosity-embed.h"
{ {
      scalar s = u.x;
      double a = 0.;
      
 a += _const_mu.x*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - _const_mu.x*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta); a += _const_mu.y*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - _const_mu.y*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta); a += _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta);
      val(res.x,0,0,0) = val(r.x,0,0,0) - (_const_rho + ((coord){0.,0.,0.}).x)*val(u.x,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.x, mu, &c);
 val(res.x,0,0,0) -= dt*(c + d*val(u.x,0,0,0));
      }
      if (fabs (val(res.x,0,0,0)) > maxres)
 maxres = fabs (val(res.x,0,0,0));
    } 
#line 123
{
      scalar s = u.y;
      double a = 0.;
      
 a += _const_mu.y*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - _const_mu.y*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta); a += _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta); a += _const_mu.x*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - _const_mu.x*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta);
      val(res.y,0,0,0) = val(r.y,0,0,0) - (_const_rho + ((coord){0.,0.,0.}).y)*val(u.y,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.y, mu, &c);
 val(res.y,0,0,0) -= dt*(c + d*val(u.y,0,0,0));
      }
      if (fabs (val(res.y,0,0,0)) > maxres)
 maxres = fabs (val(res.y,0,0,0));
    } 
#line 123
{
      scalar s = u.z;
      double a = 0.;
      
 a += _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_gradient_z (point, s, 0) : (val(s,0,0,0) - val(s,0,0,0 -1))/Delta) - _const_mu.z*(_attribute[s.i].third && val(fs.z,0,0,1) < 1. && val(fs.z,0,0,1) > 0. ? embed_face_gradient_z (point, s, 1) : (val(s,0,0,1) - val(s,0,0,1 -1))/Delta); a += _const_mu.x*(_attribute[s.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_gradient_x (point, s, 0) : (val(s,0,0,0) - val(s,0 -1,0,0))/Delta) - _const_mu.x*(_attribute[s.i].third && val(fs.x,1,0,0) < 1. && val(fs.x,1,0,0) > 0. ? embed_face_gradient_x (point, s, 1) : (val(s,1,0,0) - val(s,1 -1,0,0))/Delta); a += _const_mu.y*(_attribute[s.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_gradient_y (point, s, 0) : (val(s,0,0,0) - val(s,0,0 -1,0))/Delta) - _const_mu.y*(_attribute[s.i].third && val(fs.y,0,1,0) < 1. && val(fs.y,0,1,0) > 0. ? embed_face_gradient_y (point, s, 1) : (val(s,0,1,0) - val(s,0,1 -1,0))/Delta);
      val(res.z,0,0,0) = val(r.z,0,0,0) - (_const_rho + ((coord){0.,0.,0.}).z)*val(u.z,0,0,0) - dt*a/Delta;
      if (embed_flux) {
 double c, d = embed_flux (point, u.z, mu, &c);
 val(res.z,0,0,0) -= dt*(c + d*val(u.z,0,0,0));
      }
      if (fabs (val(res.z,0,0,0)) > maxres)
 maxres = fabs (val(res.z,0,0,0));
    }}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 135 "/home/pwachara/basilisk/src/viscosity-embed.h"
{mpi_all_reduce_array(&maxres,MPI_DOUBLE,MPI_MAX,1);}}

  return maxres;
}



double TOLERANCE_MU = 0.;

     
mgstats viscosity (vector u, vector mu, scalar rho, double dt,
     int nrelax, scalar * res)
{tracing("viscosity","/home/pwachara/basilisk/src/viscosity-embed.h",145);
  vector  r=new_vector("r");
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/viscosity-embed.h", .line = 149, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 150 "/home/pwachara/basilisk/src/viscosity-embed.h"
{
      { _stencil_val(rho,0,0,0);_stencil_val(u.x,0,0,0);_stencil_val_a(r.x,0,0,0); }      { _stencil_val(rho,0,0,0);_stencil_val(u.y,0,0,0);_stencil_val_a(r.y,0,0,0); }      { _stencil_val(rho,0,0,0);_stencil_val(u.z,0,0,0);_stencil_val_a(r.z,0,0,0); }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 150 "/home/pwachara/basilisk/src/viscosity-embed.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 150 "/home/pwachara/basilisk/src/viscosity-embed.h"
{
      val(r.x,0,0,0) = val(rho,0,0,0)*val(u.x,0,0,0);      val(r.y,0,0,0) = val(rho,0,0,0)*val(u.y,0,0,0);      val(r.z,0,0,0) = val(rho,0,0,0)*val(u.z,0,0,0);}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 153 "/home/pwachara/basilisk/src/viscosity-embed.h"
restriction (((scalar[]){mu.x,mu.y,mu.z, rho,{-1}}));
  struct Viscosity p = { mu, rho, dt };
  p.embed_flux = _attribute[u.x.i].boundary[embed] != antisymmetry ? embed_flux : NULL;
  { mgstats _ret= mg_solve ((scalar *)((vector[]){u,{{-1},{-1},{-1}}}), (scalar *)((vector[]){r,{{-1},{-1},{-1}}})
,     residual_diffusion, relax_diffusion, &p, nrelax, res
, 1

, TOLERANCE_MU ? TOLERANCE_MU : TOLERANCE);delete((scalar*)((vector[]){r,{{-1},{-1},{-1}}}));{end_tracing("viscosity","/home/pwachara/basilisk/src/viscosity-embed.h",160);return _ret;}}delete((scalar*)((vector[]){r,{{-1},{-1},{-1}}}));
end_tracing("viscosity","/home/pwachara/basilisk/src/viscosity-embed.h",161);}
#line 32 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
#line 44 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
scalar  p={4};
vector  u={{5},{6},{7}},  g={{8},{9},{10}};
scalar  pf={11};
vector  uf={{12},{13},{14}};
#line 70 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
        vector mu = {{_NVARMAX+4},{_NVARMAX+5},{_NVARMAX+6}}, a = {{_NVARMAX+4},{_NVARMAX+5},{_NVARMAX+6}}, alpha = {{_NVARMAX+7},{_NVARMAX+8},{_NVARMAX+9}};
        scalar rho = {_NVARMAX+10};
mgstats mgp = {0}, mgpf = {0}, mgu = {0};
bool stokes = false;
#line 91
static double _boundary0(Point point,Point neighbor,scalar _s,bool *data){if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*val(fm.x,1,0,0)/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*val(fm.x,1,0,0)/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*val(fm.x,1,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? val(a.x,1,0,0)*_const_fm.x/val(alpha.x,1,0,0) : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? val(a.x,1,0,0)*_const_fm.x/_const_alpha.x : val(a.x,1,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.x,1,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,1,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}}static double _boundary0_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 91 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? *((bool *)data) = false, 0 : val(_s,0,0,0)));}}}
static double _boundary1(Point point,Point neighbor,scalar _s,bool *data){if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*val(fm.x,0,0,0)/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*val(fm.x,0,0,0)/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*val(fm.x,0,0,0)/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? val(a.x,0,0,0)*_const_fm.x/val(alpha.x,0,0,0) : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? val(a.x,0,0,0)*_const_fm.x/_const_alpha.x : val(a.x,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.x,0,0,0) ? _const_a.x*_const_fm.x/val(alpha.x,0,0,0) : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.x ? _const_a.x*_const_fm.x/_const_alpha.x : _const_a.x*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}}static double _boundary1_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 92 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? *((bool *)data) = false, 0 : val(_s,0,0,0)));}}}








static double _boundary2(Point point,Point neighbor,scalar _s,bool *data){if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*val(fm.y,0,1,0)/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*val(fm.y,0,1,0)/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*val(fm.y,0,1,0)/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? val(a.y,0,1,0)*_const_fm.y/val(alpha.y,0,1,0) : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? val(a.y,0,1,0)*_const_fm.y/_const_alpha.y : val(a.y,0,1,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.y,0,1,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,1,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}}static double _boundary2_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 101 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? *((bool *)data) = false, 0 : val(_s,0,0,0)));}}}
static double _boundary3(Point point,Point neighbor,scalar _s,bool *data){if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : val(a.y,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : val(a.y,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? val(a.y,0,0,0)*val(fm.y,0,0,0)/_const_alpha.y : val(a.y,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.y ? val(a.y,0,0,0)*val(fm.y,0,0,0)/_const_alpha.y : val(a.y,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? _const_a.y*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? _const_a.y*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? _const_a.y*val(fm.y,0,0,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.y ? _const_a.y*val(fm.y,0,0,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*_const_fm.y/val(alpha.y,0,0,0) : val(a.y,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*_const_fm.y/val(alpha.y,0,0,0) : val(a.y,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? val(a.y,0,0,0)*_const_fm.y/_const_alpha.y : val(a.y,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.y ? val(a.y,0,0,0)*_const_fm.y/_const_alpha.y : val(a.y,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,0,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,0,0) : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : val(a.y,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : val(a.y,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? val(a.y,0,0,0)*val(fm.y,0,0,0)/_const_alpha.y : val(a.y,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.y ? val(a.y,0,0,0)*val(fm.y,0,0,0)/_const_alpha.y : val(a.y,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? _const_a.y*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? _const_a.y*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? _const_a.y*val(fm.y,0,0,0)/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.y ? _const_a.y*val(fm.y,0,0,0)/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*_const_fm.y/val(alpha.y,0,0,0) : val(a.y,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*_const_fm.y/val(alpha.y,0,0,0) : val(a.y,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? val(a.y,0,0,0)*_const_fm.y/_const_alpha.y : val(a.y,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.y ? val(a.y,0,0,0)*_const_fm.y/_const_alpha.y : val(a.y,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,0,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,0,0) : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : val(a.y,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : val(a.y,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? val(a.y,0,0,0)*val(fm.y,0,0,0)/_const_alpha.y : val(a.y,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.y ? val(a.y,0,0,0)*val(fm.y,0,0,0)/_const_alpha.y : val(a.y,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? _const_a.y*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? _const_a.y*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? _const_a.y*val(fm.y,0,0,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.y ? _const_a.y*val(fm.y,0,0,0)/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*_const_fm.y/val(alpha.y,0,0,0) : val(a.y,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*_const_fm.y/val(alpha.y,0,0,0) : val(a.y,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? val(a.y,0,0,0)*_const_fm.y/_const_alpha.y : val(a.y,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.y ? val(a.y,0,0,0)*_const_fm.y/_const_alpha.y : val(a.y,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,0,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,0,0) : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : val(a.y,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : val(a.y,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? val(a.y,0,0,0)*val(fm.y,0,0,0)/_const_alpha.y : val(a.y,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.y ? val(a.y,0,0,0)*val(fm.y,0,0,0)/_const_alpha.y : val(a.y,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? _const_a.y*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? _const_a.y*val(fm.y,0,0,0)/val(alpha.y,0,0,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? _const_a.y*val(fm.y,0,0,0)/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.y ? _const_a.y*val(fm.y,0,0,0)/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*_const_fm.y/val(alpha.y,0,0,0) : val(a.y,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? val(a.y,0,0,0)*_const_fm.y/val(alpha.y,0,0,0) : val(a.y,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? val(a.y,0,0,0)*_const_fm.y/_const_alpha.y : val(a.y,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.y ? val(a.y,0,0,0)*_const_fm.y/_const_alpha.y : val(a.y,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.y,0,0,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,0,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.y,0,0,0) ? _const_a.y*_const_fm.y/val(alpha.y,0,0,0) : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.y ? _const_a.y*_const_fm.y/_const_alpha.y : _const_a.y*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}}static double _boundary3_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 102 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? *((bool *)data) = false, 0 : val(_s,0,0,0)));}}}


static double _boundary4(Point point,Point neighbor,scalar _s,bool *data){if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : val(a.z,0,0,1)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : val(a.z,0,0,1)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? val(a.z,0,0,1)*val(fm.z,0,0,1)/_const_alpha.z : val(a.z,0,0,1)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.z ? val(a.z,0,0,1)*val(fm.z,0,0,1)/_const_alpha.z : val(a.z,0,0,1)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? _const_a.z*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? _const_a.z*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? _const_a.z*val(fm.z,0,0,1)/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.z ? _const_a.z*val(fm.z,0,0,1)/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*_const_fm.z/val(alpha.z,0,0,1) : val(a.z,0,0,1)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*_const_fm.z/val(alpha.z,0,0,1) : val(a.z,0,0,1)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? val(a.z,0,0,1)*_const_fm.z/_const_alpha.z : val(a.z,0,0,1)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.z ? val(a.z,0,0,1)*_const_fm.z/_const_alpha.z : val(a.z,0,0,1)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,1) : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,1) : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : val(a.z,0,0,1)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : val(a.z,0,0,1)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? val(a.z,0,0,1)*val(fm.z,0,0,1)/_const_alpha.z : val(a.z,0,0,1)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.z ? val(a.z,0,0,1)*val(fm.z,0,0,1)/_const_alpha.z : val(a.z,0,0,1)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? _const_a.z*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? _const_a.z*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? _const_a.z*val(fm.z,0,0,1)/_const_alpha.z : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.z ? _const_a.z*val(fm.z,0,0,1)/_const_alpha.z : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*_const_fm.z/val(alpha.z,0,0,1) : val(a.z,0,0,1)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*_const_fm.z/val(alpha.z,0,0,1) : val(a.z,0,0,1)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? val(a.z,0,0,1)*_const_fm.z/_const_alpha.z : val(a.z,0,0,1)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.z ? val(a.z,0,0,1)*_const_fm.z/_const_alpha.z : val(a.z,0,0,1)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,1) : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,1) : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*((_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : val(a.z,0,0,1)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : val(a.z,0,0,1)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? val(a.z,0,0,1)*val(fm.z,0,0,1)/_const_alpha.z : val(a.z,0,0,1)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.z ? val(a.z,0,0,1)*val(fm.z,0,0,1)/_const_alpha.z : val(a.z,0,0,1)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? _const_a.z*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? _const_a.z*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? _const_a.z*val(fm.z,0,0,1)/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.z ? _const_a.z*val(fm.z,0,0,1)/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*_const_fm.z/val(alpha.z,0,0,1) : val(a.z,0,0,1)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*_const_fm.z/val(alpha.z,0,0,1) : val(a.z,0,0,1)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? val(a.z,0,0,1)*_const_fm.z/_const_alpha.z : val(a.z,0,0,1)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.z ? val(a.z,0,0,1)*_const_fm.z/_const_alpha.z : val(a.z,0,0,1)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,1) : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,1) : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*((_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : val(a.z,0,0,1)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : val(a.z,0,0,1)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? val(a.z,0,0,1)*val(fm.z,0,0,1)/_const_alpha.z : val(a.z,0,0,1)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.z ? val(a.z,0,0,1)*val(fm.z,0,0,1)/_const_alpha.z : val(a.z,0,0,1)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? _const_a.z*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : _const_a.z*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? _const_a.z*val(fm.z,0,0,1)/val(alpha.z,0,0,1) : _const_a.z*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? _const_a.z*val(fm.z,0,0,1)/_const_alpha.z : _const_a.z*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.z ? _const_a.z*val(fm.z,0,0,1)/_const_alpha.z : _const_a.z*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*_const_fm.z/val(alpha.z,0,0,1) : val(a.z,0,0,1)*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? val(a.z,0,0,1)*_const_fm.z/val(alpha.z,0,0,1) : val(a.z,0,0,1)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? val(a.z,0,0,1)*_const_fm.z/_const_alpha.z : val(a.z,0,0,1)*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.z ? val(a.z,0,0,1)*_const_fm.z/_const_alpha.z : val(a.z,0,0,1)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((val(alpha.z,0,0,1) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,1) : _const_a.z*_const_rho/(_const_cm + 1e-30))) : Delta*((val(alpha.z,0,0,1) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,1) : _const_a.z*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, ((_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*_const_rho/(_const_cm + 1e-30))) : Delta*((_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}}static double _boundary4_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 105 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? *((bool *)data) = false, 0 : val(_s,0,0,0)));}}}
static double _boundary5(Point point,Point neighbor,scalar _s,bool *data){if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : val(a.z,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : val(a.z,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? val(a.z,0,0,0)*val(fm.z,0,0,0)/_const_alpha.z : val(a.z,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.z ? val(a.z,0,0,0)*val(fm.z,0,0,0)/_const_alpha.z : val(a.z,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? _const_a.z*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? _const_a.z*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? _const_a.z*val(fm.z,0,0,0)/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.z ? _const_a.z*val(fm.z,0,0,0)/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*_const_fm.z/val(alpha.z,0,0,0) : val(a.z,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*_const_fm.z/val(alpha.z,0,0,0) : val(a.z,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? val(a.z,0,0,0)*_const_fm.z/_const_alpha.z : val(a.z,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.z ? val(a.z,0,0,0)*_const_fm.z/_const_alpha.z : val(a.z,0,0,0)*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,0) : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,0) : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : val(a.z,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : val(a.z,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? val(a.z,0,0,0)*val(fm.z,0,0,0)/_const_alpha.z : val(a.z,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.z ? val(a.z,0,0,0)*val(fm.z,0,0,0)/_const_alpha.z : val(a.z,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? _const_a.z*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? _const_a.z*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? _const_a.z*val(fm.z,0,0,0)/_const_alpha.z : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.z ? _const_a.z*val(fm.z,0,0,0)/_const_alpha.z : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*_const_fm.z/val(alpha.z,0,0,0) : val(a.z,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*_const_fm.z/val(alpha.z,0,0,0) : val(a.z,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? val(a.z,0,0,0)*_const_fm.z/_const_alpha.z : val(a.z,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.z ? val(a.z,0,0,0)*_const_fm.z/_const_alpha.z : val(a.z,0,0,0)*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,0) : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,0) : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && !is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) : Delta*(- (_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*_const_rho/(val(cm,0,0,0) + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : val(a.z,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : val(a.z,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? val(a.z,0,0,0)*val(fm.z,0,0,0)/_const_alpha.z : val(a.z,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.z ? val(a.z,0,0,0)*val(fm.z,0,0,0)/_const_alpha.z : val(a.z,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? _const_a.z*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? _const_a.z*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? _const_a.z*val(fm.z,0,0,0)/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.z ? _const_a.z*val(fm.z,0,0,0)/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*_const_fm.z/val(alpha.z,0,0,0) : val(a.z,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*_const_fm.z/val(alpha.z,0,0,0) : val(a.z,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? val(a.z,0,0,0)*_const_fm.z/_const_alpha.z : val(a.z,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.z ? val(a.z,0,0,0)*_const_fm.z/_const_alpha.z : val(a.z,0,0,0)*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,0) : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,0) : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && !is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*val(rho,0,0,0)/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : val(a.z,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : val(a.z,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? val(a.z,0,0,0)*val(fm.z,0,0,0)/_const_alpha.z : val(a.z,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.z ? val(a.z,0,0,0)*val(fm.z,0,0,0)/_const_alpha.z : val(a.z,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? _const_a.z*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : _const_a.z*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? _const_a.z*val(fm.z,0,0,0)/val(alpha.z,0,0,0) : _const_a.z*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && is_constant(a.x) && !is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? _const_a.z*val(fm.z,0,0,0)/_const_alpha.z : _const_a.z*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.z ? _const_a.z*val(fm.z,0,0,0)/_const_alpha.z : _const_a.z*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*_const_fm.z/val(alpha.z,0,0,0) : val(a.z,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? val(a.z,0,0,0)*_const_fm.z/val(alpha.z,0,0,0) : val(a.z,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(is_constant(alpha.x) && !is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? val(a.z,0,0,0)*_const_fm.z/_const_alpha.z : val(a.z,0,0,0)*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.z ? val(a.z,0,0,0)*_const_fm.z/_const_alpha.z : val(a.z,0,0,0)*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else if(!is_constant(alpha.x) && is_constant(a.x) && is_constant(fm.x) && is_constant(rho) && is_constant(cm)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (val(alpha.z,0,0,0) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,0) : _const_a.z*_const_rho/(_const_cm + 1e-30))) : Delta*(- (val(alpha.z,0,0,0) ? _const_a.z*_const_fm.z/val(alpha.z,0,0,0) : _const_a.z*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}else {_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_rho=_constant[rho.i-_NVARMAX];NOT_UNUSED(_const_rho);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = false, (- (_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*_const_rho/(_const_cm + 1e-30))) : Delta*(- (_const_alpha.z ? _const_a.z*_const_fm.z/_const_alpha.z : _const_a.z*_const_rho/(_const_cm + 1e-30))) + val(_s,0,0,0)));}}}}}static double _boundary5_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 106 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{return( ( data ? *((bool *)data) = false, 0 : val(_s,0,0,0)));}}}
#line 126
static int defaults_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}
#line 126 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
      static int defaults_1(const int i,const double t,Event *_ev){tracing("defaults_1","/home/pwachara/basilisk/src/navier-stokes/centered.h",126);
{




  mgp = (mgstats){0};
  mgpf = (mgstats){0};
  mgu = (mgstats){0};

  CFL = 0.8;




  _attribute[p.i].nodump = _attribute[pf.i].nodump = true;





  if (alpha.x.i == unityf.x.i) {
    alpha = fm;
    rho = cm;
  }
  else if (!is_constant(alpha.x)) {
    vector alphav = alpha;
if(!is_constant(fm.x)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 153, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 153 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.x,0,0,0);_stencil_val_a(alphav.x,0,0,0); } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.y,0,0,0);_stencil_val_a(alphav.y,0,0,0); } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.z,0,0,0);_stencil_val_a(alphav.z,0,0,0); }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 153 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(alphav.x,0,0,0) = val(fm.x,0,0,0);}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(alphav.y,0,0,0) = val(fm.y,0,0,0);}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(alphav.z,0,0,0) = val(fm.z,0,0,0);}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 153, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 153 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;_stencil_val_a(alphav.x,0,0,0); } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;_stencil_val_a(alphav.y,0,0,0); } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;_stencil_val_a(alphav.z,0,0,0); }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 153 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(alphav.x,0,0,0) = _const_fm.x;}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(alphav.y,0,0,0) = _const_fm.y;}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);      
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(alphav.z,0,0,0) = _const_fm.z;}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 154 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
  }
  
#line 185 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 185, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 186 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
      {_stencil_val(u.x,0,0,0);   }      {_stencil_val(u.y,0,0,0);   }      {_stencil_val(u.z,0,0,0);   }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 186 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 186 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
      dimensional (val(u.x,0,0,0) == Delta/t);      dimensional (val(u.y,0,0,0) == Delta/t);      dimensional (val(u.z,0,0,0) == Delta/t);}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 188 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}{end_tracing("defaults_1","/home/pwachara/basilisk/src/navier-stokes/centered.h",188);return 0;}end_tracing("defaults_1","/home/pwachara/basilisk/src/navier-stokes/centered.h",188);}





static int default_display_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int default_display(const int i,const double t,Event *_ev){tracing("default_display","/home/pwachara/basilisk/src/navier-stokes/centered.h",194);
{display ("squares (color = 'u.x', spread = -1);"
#line 494 "/home/pwachara/basilisk/src/common.h"
, false
#line 195 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
);  }{end_tracing("default_display","/home/pwachara/basilisk/src/navier-stokes/centered.h",195);return 0;}end_tracing("default_display","/home/pwachara/basilisk/src/navier-stokes/centered.h",195);}





double dtmax;

static int init_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int init(const int i,const double t,Event *_ev){tracing("init","/home/pwachara/basilisk/src/navier-stokes/centered.h",203);
{
  trash (((vector[]){uf,{{-1},{-1},{-1}}}));
if(!is_constant(fm.x)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 206, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 206 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val_a(uf.x,0,0,0);                 } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(cs,0,0 -1,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0 -1,0);_stencil_val_a(uf.y,0,0,0);                 } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_value_z (point, u.z, 0);_stencil_val(u.z,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.z,0,0,0 -1); _stencil_val(cs,0,0,0 -1);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0 -1);_stencil_val_a(uf.z,0,0,0);                 }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 206 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.x,0,0,0) = val(fm.x,0,0,0)*(_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.)));}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.y,0,0,0) = val(fm.y,0,0,0)*(_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.)));}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.z,0,0,0) = val(fm.z,0,0,0)*(_attribute[u.z.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_value_z (point, u.z, 0) : ((val(u.z,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.z,0,0,0 -1)*(1.5 + val(cs,0,0,0 -1)))/ (val(cs,0,0,0) + val(cs,0,0,0 -1) + 3.)));}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 206, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 206 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val_a(uf.x,0,0,0);                 } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(cs,0,0 -1,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0 -1,0);_stencil_val_a(uf.y,0,0,0);                 } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_value_z (point, u.z, 0);_stencil_val(u.z,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.z,0,0,0 -1); _stencil_val(cs,0,0,0 -1);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0 -1);_stencil_val_a(uf.z,0,0,0);                 }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 206 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.x,0,0,0) = _const_fm.x*(_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.)));}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.y,0,0,0) = _const_fm.y*(_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.)));}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.z,0,0,0) = _const_fm.z*(_attribute[u.z.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_value_z (point, u.z, 0) : ((val(u.z,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.z,0,0,0 -1)*(1.5 + val(cs,0,0,0 -1)))/ (val(cs,0,0,0) + val(cs,0,0,0 -1) + 3.)));}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 207 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}




  event ("properties");





  dtmax = DT;
  event ("stability");
}{end_tracing("init","/home/pwachara/basilisk/src/navier-stokes/centered.h",220);return 0;}end_tracing("init","/home/pwachara/basilisk/src/navier-stokes/centered.h",220);}








static int set_dtmax_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 229 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
      static int set_dtmax(const int i,const double t,Event *_ev){tracing("set_dtmax","/home/pwachara/basilisk/src/navier-stokes/centered.h",229);{dtmax = DT; }{end_tracing("set_dtmax","/home/pwachara/basilisk/src/navier-stokes/centered.h",229);return 0;}end_tracing("set_dtmax","/home/pwachara/basilisk/src/navier-stokes/centered.h",229);}

static int stability_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int stability(const int i,const double t,Event *_ev){tracing("stability","/home/pwachara/basilisk/src/navier-stokes/centered.h",231); {
  dt = dtnext (stokes ? dtmax : timestep (uf, dtmax));
}{end_tracing("stability","/home/pwachara/basilisk/src/navier-stokes/centered.h",233);return 0;}end_tracing("stability","/home/pwachara/basilisk/src/navier-stokes/centered.h",233);}







static int vof_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int vof(const int i,const double t,Event *_ev){;return 0;}
static int tracer_advection_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int tracer_advection(const int i,const double t,Event *_ev){;return 0;}
static int tracer_diffusion_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int tracer_diffusion(const int i,const double t,Event *_ev){;return 0;}






static int properties_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int properties(const int i,const double t,Event *_ev){;return 0;}
#line 262 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
void prediction()
{
  vector du;
   {
    scalar s = new_scalar("s");
    du.x = s;
  } 
#line 265
{
    scalar s = new_scalar("s");
    du.y = s;
  } 
#line 265
{
    scalar s = new_scalar("s");
    du.z = s;
  }

  if (_attribute[u.x.i].gradient)
    {
  
    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 271, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);      
#line 272 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ {

_stencil_val(fs.x,0,0,0);_stencil_val(fs.x,1,0,0);{
   {_stencil_val_a(du.x,0,0,0);  }

   
{_stencil_val(u.x,-1,0,0); _stencil_val(u.x,0,0,0); _stencil_val(u.x,1,0,0);_stencil_val_a(du.x,0,0,0);   }}      
} 
#line 272
{

_stencil_val(fs.y,0,0,0);_stencil_val(fs.y,0,1,0);{
   {_stencil_val_a(du.y,0,0,0);  }

   
{_stencil_val(u.y,0,-1,0); _stencil_val(u.y,0,0,0); _stencil_val(u.y,0,1,0);_stencil_val_a(du.y,0,0,0);   }}      
} 
#line 272
{

_stencil_val(fs.z,0,0,0);_stencil_val(fs.z,0,0,1);{
   {_stencil_val_a(du.z,0,0,0);  }

   
{_stencil_val(u.z,0,0,-1); _stencil_val(u.z,0,0,0); _stencil_val(u.z,0,0,1);_stencil_val_a(du.z,0,0,0);   }}      
}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)      
#line 272 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 272 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ {

        if (!val(fs.x,0,0,0) || !val(fs.x,1,0,0))
   val(du.x,0,0,0) = 0.;
 else

   val(du.x,0,0,0) = _attribute[u.x.i].gradient (val(u.x,-1,0,0), val(u.x,0,0,0), val(u.x,1,0,0))/Delta;
      } 
#line 272
{

        if (!val(fs.y,0,0,0) || !val(fs.y,0,1,0))
   val(du.y,0,0,0) = 0.;
 else

   val(du.y,0,0,0) = _attribute[u.y.i].gradient (val(u.y,0,-1,0), val(u.y,0,0,0), val(u.y,0,1,0))/Delta;
      } 
#line 272
{

        if (!val(fs.z,0,0,0) || !val(fs.z,0,0,1))
   val(du.z,0,0,0) = 0.;
 else

   val(du.z,0,0,0) = _attribute[u.z.i].gradient (val(u.z,0,0,-1), val(u.z,0,0,0), val(u.z,0,0,1))/Delta;
      }}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 279 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
  else
    {
  
    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 281, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);      
#line 282 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ {

_stencil_val(fs.x,0,0,0);_stencil_val(fs.x,1,0,0);{
   {_stencil_val_a(du.x,0,0,0);  }

   
{_stencil_val(u.x,1,0,0); _stencil_val(u.x,-1,0,0);_stencil_val_a(du.x,0,0,0);   }}    
} 
#line 282
{

_stencil_val(fs.y,0,0,0);_stencil_val(fs.y,0,1,0);{
   {_stencil_val_a(du.y,0,0,0);  }

   
{_stencil_val(u.y,0,1,0); _stencil_val(u.y,0,-1,0);_stencil_val_a(du.y,0,0,0);   }}    
} 
#line 282
{

_stencil_val(fs.z,0,0,0);_stencil_val(fs.z,0,0,1);{
   {_stencil_val_a(du.z,0,0,0);  }

   
{_stencil_val(u.z,0,0,1); _stencil_val(u.z,0,0,-1);_stencil_val_a(du.z,0,0,0);   }}    
}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
      
#line 282 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 282 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ {

        if (!val(fs.x,0,0,0) || !val(fs.x,1,0,0))
   val(du.x,0,0,0) = 0.;
 else

   val(du.x,0,0,0) = (val(u.x,1,0,0) - val(u.x,-1,0,0))/(2.*Delta);
    } 
#line 282
{

        if (!val(fs.y,0,0,0) || !val(fs.y,0,1,0))
   val(du.y,0,0,0) = 0.;
 else

   val(du.y,0,0,0) = (val(u.y,0,1,0) - val(u.y,0,-1,0))/(2.*Delta);
    } 
#line 282
{

        if (!val(fs.z,0,0,0) || !val(fs.z,0,0,1))
   val(du.z,0,0,0) = 0.;
 else

   val(du.z,0,0,0) = (val(u.z,0,0,1) - val(u.z,0,0,-1))/(2.*Delta);
    }}}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 289 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}

  trash (((vector[]){uf,{{-1},{-1},{-1}}}));
if(!is_constant(fm.x)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 292, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{              
     _stencil_val(u.x,-1,0,0);_stencil_val(u.x,0,0,0);     
    
_stencil_val(u.x, o_stencil,0,0);_stencil_val(g.x,0,0,0); _stencil_val(g.x,-1,0,0);_stencil_val(du.x,o_stencil,0,0);    _stencil_val_a(uf.x,0,0,0);

_stencil_val(fm.y,o_stencil,0,0); _stencil_val(fm.y,o_stencil,1,0); {        
       _stencil_val(u.x,o_stencil,-1,0);_stencil_val(u.x, o_stencil,0,0);_stencil_val(u.x, o_stencil,0,0); _stencil_val(u.x,o_stencil,1,0);_stencil_val(u.y, o_stencil,0,0);
_stencil_val(u.y,o_stencil,0,0);      _stencil_val_r(uf.x,0,0,0);  
    }


_stencil_val(fm.z,o_stencil,0,0); _stencil_val(fm.z,o_stencil,0,1); {        
       _stencil_val(u.x,o_stencil,0,-1);_stencil_val(u.x, o_stencil,0,0);_stencil_val(u.x, o_stencil,0,0); _stencil_val(u.x,o_stencil,0,1);_stencil_val(u.z, o_stencil,0,0);
_stencil_val(u.z,o_stencil,0,0);      _stencil_val_r(uf.x,0,0,0);  
    } 

_stencil_val(fm.x,0,0,0);    _stencil_val_r(uf.x,0,0,0); 
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{              
     _stencil_val(u.y,0,-1,0);_stencil_val(u.y,0,0,0);     
    
_stencil_val(u.y,0, o_stencil,0);_stencil_val(g.y,0,0,0); _stencil_val(g.y,0,-1,0);_stencil_val(du.y,0,o_stencil,0);    _stencil_val_a(uf.y,0,0,0);

_stencil_val(fm.z,0,o_stencil,0); _stencil_val(fm.z,0,o_stencil,1); {        
       _stencil_val(u.y,0,o_stencil,-1);_stencil_val(u.y,0, o_stencil,0);_stencil_val(u.y,0, o_stencil,0); _stencil_val(u.y,0,o_stencil,1);_stencil_val(u.z,0, o_stencil,0);
_stencil_val(u.z,0,o_stencil,0);      _stencil_val_r(uf.y,0,0,0);  
    }


_stencil_val(fm.x,0,o_stencil,0); _stencil_val(fm.x,1,o_stencil,0); {        
       _stencil_val(u.y,-1,o_stencil,0);_stencil_val(u.y,0, o_stencil,0);_stencil_val(u.y,0, o_stencil,0); _stencil_val(u.y,1,o_stencil,0);_stencil_val(u.x,0, o_stencil,0);
_stencil_val(u.x,0,o_stencil,0);      _stencil_val_r(uf.y,0,0,0);  
    } 

_stencil_val(fm.y,0,0,0);    _stencil_val_r(uf.y,0,0,0); 
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{              
     _stencil_val(u.z,0,0,-1);_stencil_val(u.z,0,0,0);     
    
_stencil_val(u.z,0,0, o_stencil);_stencil_val(g.z,0,0,0); _stencil_val(g.z,0,0,-1);_stencil_val(du.z,0,0,o_stencil);    _stencil_val_a(uf.z,0,0,0);

_stencil_val(fm.x,0,0,o_stencil); _stencil_val(fm.x,1,0,o_stencil); {        
       _stencil_val(u.z,-1,0,o_stencil);_stencil_val(u.z,0,0, o_stencil);_stencil_val(u.z,0,0, o_stencil); _stencil_val(u.z,1,0,o_stencil);_stencil_val(u.x,0,0, o_stencil);
_stencil_val(u.x,0,0,o_stencil);      _stencil_val_r(uf.z,0,0,0);  
    }


_stencil_val(fm.y,0,0,o_stencil); _stencil_val(fm.y,0,1,o_stencil); {        
       _stencil_val(u.z,0,-1,o_stencil);_stencil_val(u.z,0,0, o_stencil);_stencil_val(u.z,0,0, o_stencil); _stencil_val(u.z,0,1,o_stencil);_stencil_val(u.y,0,0, o_stencil);
_stencil_val(u.y,0,0,o_stencil);      _stencil_val_r(uf.z,0,0,0);  
    } 

_stencil_val(fm.z,0,0,0);    _stencil_val_r(uf.z,0,0,0); 
  }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
    double un = dt*(val(u.x,0,0,0) + val(u.x,-1,0,0))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.x,0,0,0) = val(u.x,i,0,0) + (val(g.x,0,0,0) + val(g.x,-1,0,0))*dt/4. + s*(1. - s*un)*val(du.x,i,0,0)*Delta/2.;

    if (val(fm.y,i,0,0) && val(fm.y,i,1,0)) {
      double fyy = val(u.y,i,0,0) < 0. ? val(u.x,i,1,0) - val(u.x,i,0,0) : val(u.x,i,0,0) - val(u.x,i,-1,0);
      val(uf.x,0,0,0) -= dt*val(u.y,i,0,0)*fyy/(2.*Delta);
    }


    if (val(fm.z,i,0,0) && val(fm.z,i,0,1)) {
      double fzz = val(u.z,i,0,0) < 0. ? val(u.x,i,0,1) - val(u.x,i,0,0) : val(u.x,i,0,0) - val(u.x,i,0,-1);
      val(uf.x,0,0,0) -= dt*val(u.z,i,0,0)*fzz/(2.*Delta);
    }

    val(uf.x,0,0,0) *= val(fm.x,0,0,0);
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
    double un = dt*(val(u.y,0,0,0) + val(u.y,0,-1,0))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.y,0,0,0) = val(u.y,0,i,0) + (val(g.y,0,0,0) + val(g.y,0,-1,0))*dt/4. + s*(1. - s*un)*val(du.y,0,i,0)*Delta/2.;

    if (val(fm.z,0,i,0) && val(fm.z,0,i,1)) {
      double fyy = val(u.z,0,i,0) < 0. ? val(u.y,0,i,1) - val(u.y,0,i,0) : val(u.y,0,i,0) - val(u.y,0,i,-1);
      val(uf.y,0,0,0) -= dt*val(u.z,0,i,0)*fyy/(2.*Delta);
    }


    if (val(fm.x,0,i,0) && val(fm.x,1,i,0)) {
      double fzz = val(u.x,0,i,0) < 0. ? val(u.y,1,i,0) - val(u.y,0,i,0) : val(u.y,0,i,0) - val(u.y,-1,i,0);
      val(uf.y,0,0,0) -= dt*val(u.x,0,i,0)*fzz/(2.*Delta);
    }

    val(uf.y,0,0,0) *= val(fm.y,0,0,0);
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
    double un = dt*(val(u.z,0,0,0) + val(u.z,0,0,-1))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.z,0,0,0) = val(u.z,0,0,i) + (val(g.z,0,0,0) + val(g.z,0,0,-1))*dt/4. + s*(1. - s*un)*val(du.z,0,0,i)*Delta/2.;

    if (val(fm.x,0,0,i) && val(fm.x,1,0,i)) {
      double fyy = val(u.x,0,0,i) < 0. ? val(u.z,1,0,i) - val(u.z,0,0,i) : val(u.z,0,0,i) - val(u.z,-1,0,i);
      val(uf.z,0,0,0) -= dt*val(u.x,0,0,i)*fyy/(2.*Delta);
    }


    if (val(fm.y,0,0,i) && val(fm.y,0,1,i)) {
      double fzz = val(u.y,0,0,i) < 0. ? val(u.z,0,1,i) - val(u.z,0,0,i) : val(u.z,0,0,i) - val(u.z,0,-1,i);
      val(uf.z,0,0,0) -= dt*val(u.y,0,0,i)*fzz/(2.*Delta);
    }

    val(uf.z,0,0,0) *= val(fm.z,0,0,0);
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 309 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 309 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 292, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{              
     _stencil_val(u.x,-1,0,0);_stencil_val(u.x,0,0,0);     
    
_stencil_val(u.x, o_stencil,0,0);_stencil_val(g.x,0,0,0); _stencil_val(g.x,-1,0,0);_stencil_val(du.x,o_stencil,0,0);    _stencil_val_a(uf.x,0,0,0);

;; {        
       _stencil_val(u.x,o_stencil,-1,0);_stencil_val(u.x, o_stencil,0,0);_stencil_val(u.x, o_stencil,0,0); _stencil_val(u.x,o_stencil,1,0);_stencil_val(u.y, o_stencil,0,0);
_stencil_val(u.y,o_stencil,0,0);      _stencil_val_r(uf.x,0,0,0);  
    }


;; {        
       _stencil_val(u.x,o_stencil,0,-1);_stencil_val(u.x, o_stencil,0,0);_stencil_val(u.x, o_stencil,0,0); _stencil_val(u.x,o_stencil,0,1);_stencil_val(u.z, o_stencil,0,0);
_stencil_val(u.z,o_stencil,0,0);      _stencil_val_r(uf.x,0,0,0);  
    }

;    _stencil_val_r(uf.x,0,0,0); 
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{              
     _stencil_val(u.y,0,-1,0);_stencil_val(u.y,0,0,0);     
    
_stencil_val(u.y,0, o_stencil,0);_stencil_val(g.y,0,0,0); _stencil_val(g.y,0,-1,0);_stencil_val(du.y,0,o_stencil,0);    _stencil_val_a(uf.y,0,0,0);

;; {        
       _stencil_val(u.y,0,o_stencil,-1);_stencil_val(u.y,0, o_stencil,0);_stencil_val(u.y,0, o_stencil,0); _stencil_val(u.y,0,o_stencil,1);_stencil_val(u.z,0, o_stencil,0);
_stencil_val(u.z,0,o_stencil,0);      _stencil_val_r(uf.y,0,0,0);  
    }


;; {        
       _stencil_val(u.y,-1,o_stencil,0);_stencil_val(u.y,0, o_stencil,0);_stencil_val(u.y,0, o_stencil,0); _stencil_val(u.y,1,o_stencil,0);_stencil_val(u.x,0, o_stencil,0);
_stencil_val(u.x,0,o_stencil,0);      _stencil_val_r(uf.y,0,0,0);  
    }

;    _stencil_val_r(uf.y,0,0,0); 
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{              
     _stencil_val(u.z,0,0,-1);_stencil_val(u.z,0,0,0);     
    
_stencil_val(u.z,0,0, o_stencil);_stencil_val(g.z,0,0,0); _stencil_val(g.z,0,0,-1);_stencil_val(du.z,0,0,o_stencil);    _stencil_val_a(uf.z,0,0,0);

;; {        
       _stencil_val(u.z,-1,0,o_stencil);_stencil_val(u.z,0,0, o_stencil);_stencil_val(u.z,0,0, o_stencil); _stencil_val(u.z,1,0,o_stencil);_stencil_val(u.x,0,0, o_stencil);
_stencil_val(u.x,0,0,o_stencil);      _stencil_val_r(uf.z,0,0,0);  
    }


;; {        
       _stencil_val(u.z,0,-1,o_stencil);_stencil_val(u.z,0,0, o_stencil);_stencil_val(u.z,0,0, o_stencil); _stencil_val(u.z,0,1,o_stencil);_stencil_val(u.y,0,0, o_stencil);
_stencil_val(u.y,0,0,o_stencil);      _stencil_val_r(uf.z,0,0,0);  
    }

;    _stencil_val_r(uf.z,0,0,0); 
  }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
    double un = dt*(val(u.x,0,0,0) + val(u.x,-1,0,0))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.x,0,0,0) = val(u.x,i,0,0) + (val(g.x,0,0,0) + val(g.x,-1,0,0))*dt/4. + s*(1. - s*un)*val(du.x,i,0,0)*Delta/2.;

    if (_const_fm.y && _const_fm.y) {
      double fyy = val(u.y,i,0,0) < 0. ? val(u.x,i,1,0) - val(u.x,i,0,0) : val(u.x,i,0,0) - val(u.x,i,-1,0);
      val(uf.x,0,0,0) -= dt*val(u.y,i,0,0)*fyy/(2.*Delta);
    }


    if (_const_fm.z && _const_fm.z) {
      double fzz = val(u.z,i,0,0) < 0. ? val(u.x,i,0,1) - val(u.x,i,0,0) : val(u.x,i,0,0) - val(u.x,i,0,-1);
      val(uf.x,0,0,0) -= dt*val(u.z,i,0,0)*fzz/(2.*Delta);
    }

    val(uf.x,0,0,0) *= _const_fm.x;
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
    double un = dt*(val(u.y,0,0,0) + val(u.y,0,-1,0))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.y,0,0,0) = val(u.y,0,i,0) + (val(g.y,0,0,0) + val(g.y,0,-1,0))*dt/4. + s*(1. - s*un)*val(du.y,0,i,0)*Delta/2.;

    if (_const_fm.z && _const_fm.z) {
      double fyy = val(u.z,0,i,0) < 0. ? val(u.y,0,i,1) - val(u.y,0,i,0) : val(u.y,0,i,0) - val(u.y,0,i,-1);
      val(uf.y,0,0,0) -= dt*val(u.z,0,i,0)*fyy/(2.*Delta);
    }


    if (_const_fm.x && _const_fm.x) {
      double fzz = val(u.x,0,i,0) < 0. ? val(u.y,1,i,0) - val(u.y,0,i,0) : val(u.y,0,i,0) - val(u.y,-1,i,0);
      val(uf.y,0,0,0) -= dt*val(u.x,0,i,0)*fzz/(2.*Delta);
    }

    val(uf.y,0,0,0) *= _const_fm.y;
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 292 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
    double un = dt*(val(u.z,0,0,0) + val(u.z,0,0,-1))/(2.*Delta), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;
    val(uf.z,0,0,0) = val(u.z,0,0,i) + (val(g.z,0,0,0) + val(g.z,0,0,-1))*dt/4. + s*(1. - s*un)*val(du.z,0,0,i)*Delta/2.;

    if (_const_fm.x && _const_fm.x) {
      double fyy = val(u.x,0,0,i) < 0. ? val(u.z,1,0,i) - val(u.z,0,0,i) : val(u.z,0,0,i) - val(u.z,-1,0,i);
      val(uf.z,0,0,0) -= dt*val(u.x,0,0,i)*fyy/(2.*Delta);
    }


    if (_const_fm.y && _const_fm.y) {
      double fzz = val(u.y,0,0,i) < 0. ? val(u.z,0,1,i) - val(u.z,0,0,i) : val(u.z,0,0,i) - val(u.z,0,-1,i);
      val(uf.z,0,0,0) -= dt*val(u.y,0,0,i)*fzz/(2.*Delta);
    }

    val(uf.z,0,0,0) *= _const_fm.z;
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 309 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 309 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}

  delete ((scalar *)((vector[]){du,{{-1},{-1},{-1}}}));
}
#line 323
static int advection_term_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 323 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
      static int advection_term(const int i,const double t,Event *_ev){tracing("advection_term","/home/pwachara/basilisk/src/navier-stokes/centered.h",323);
{
  if (!stokes) {
    prediction();
    mgpf = project (uf, pf, alpha, dt/2., mgpf.nrelax);
    advection ((scalar *)((vector[]){u,{{-1},{-1},{-1}}}), uf, dt, (scalar *)((vector[]){g,{{-1},{-1},{-1}}}));
  }
}{end_tracing("advection_term","/home/pwachara/basilisk/src/navier-stokes/centered.h",330);return 0;}end_tracing("advection_term","/home/pwachara/basilisk/src/navier-stokes/centered.h",330);}







static void correction (double dt)
{  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 340, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 341 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
      {_stencil_val(g.x,0,0,0);_stencil_val_r(u.x,0,0,0);  }      {_stencil_val(g.y,0,0,0);_stencil_val_r(u.y,0,0,0);  }      {_stencil_val(g.z,0,0,0);_stencil_val_r(u.z,0,0,0);  }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 341 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 341 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
      val(u.x,0,0,0) += dt*val(g.x,0,0,0);      val(u.y,0,0,0) += dt*val(g.y,0,0,0);      val(u.z,0,0,0) += dt*val(g.z,0,0,0);}}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}

#line 343 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}








static int viscous_term_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 352 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
      static int viscous_term(const int i,const double t,Event *_ev){tracing("viscous_term","/home/pwachara/basilisk/src/navier-stokes/centered.h",352);
{
  if (constant(mu.x) != 0.) {
    correction (dt);
    mgu = viscosity (u, mu, rho, dt, mgu.nrelax
#line 146 "/home/pwachara/basilisk/src/viscosity-embed.h"
, NULL
#line 356 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
);
    correction (-dt);
  }




  if (!is_constant(a.x)) {
    vector af = a;
    trash (((vector[]){af,{{-1},{-1},{-1}}}));  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 366, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 366 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);      
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{_stencil_val_a(af.x,0,0,0);  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);      
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{_stencil_val_a(af.y,0,0,0);  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);      
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{_stencil_val_a(af.z,0,0,0);  }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 366 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);      
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(af.x,0,0,0) = 0.;}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);      
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(af.y,0,0,0) = 0.;}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);      
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(af.z,0,0,0) = 0.;}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 367 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
  
#line 368 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
}{end_tracing("viscous_term","/home/pwachara/basilisk/src/navier-stokes/centered.h",369);return 0;}end_tracing("viscous_term","/home/pwachara/basilisk/src/navier-stokes/centered.h",369);}
#line 388
static int acceleration_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 388 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
      static int acceleration(const int i,const double t,Event *_ev){tracing("acceleration","/home/pwachara/basilisk/src/navier-stokes/centered.h",388);
{
  trash (((vector[]){uf,{{-1},{-1},{-1}}}));
if(!is_constant(fm.x) && !is_constant(a.x)){  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 391, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 391 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(a.x,0,0,0);_stencil_val_a(uf.x,0,0,0);                   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(cs,0,0 -1,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0 -1,0);_stencil_val(a.y,0,0,0);_stencil_val_a(uf.y,0,0,0);                   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_value_z (point, u.z, 0);_stencil_val(u.z,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.z,0,0,0 -1); _stencil_val(cs,0,0,0 -1);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0 -1);_stencil_val(a.z,0,0,0);_stencil_val_a(uf.z,0,0,0);                   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 391 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.x,0,0,0) = val(fm.x,0,0,0)*((_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.))) + dt*val(a.x,0,0,0));}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.y,0,0,0) = val(fm.y,0,0,0)*((_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.))) + dt*val(a.y,0,0,0));}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.z,0,0,0) = val(fm.z,0,0,0)*((_attribute[u.z.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_value_z (point, u.z, 0) : ((val(u.z,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.z,0,0,0 -1)*(1.5 + val(cs,0,0,0 -1)))/ (val(cs,0,0,0) + val(cs,0,0,0 -1) + 3.))) + dt*val(a.z,0,0,0));}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else if(is_constant(fm.x) && !is_constant(a.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 391, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 391 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(a.x,0,0,0);_stencil_val_a(uf.x,0,0,0);                   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(cs,0,0 -1,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0 -1,0);_stencil_val(a.y,0,0,0);_stencil_val_a(uf.y,0,0,0);                   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_value_z (point, u.z, 0);_stencil_val(u.z,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.z,0,0,0 -1); _stencil_val(cs,0,0,0 -1);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0 -1);_stencil_val(a.z,0,0,0);_stencil_val_a(uf.z,0,0,0);                   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 391 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.x,0,0,0) = _const_fm.x*((_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.))) + dt*val(a.x,0,0,0));}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.y,0,0,0) = _const_fm.y*((_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.))) + dt*val(a.y,0,0,0));}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.z,0,0,0) = _const_fm.z*((_attribute[u.z.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_value_z (point, u.z, 0) : ((val(u.z,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.z,0,0,0 -1)*(1.5 + val(cs,0,0,0 -1)))/ (val(cs,0,0,0) + val(cs,0,0,0 -1) + 3.))) + dt*val(a.z,0,0,0));}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else if(!is_constant(fm.x) && is_constant(a.x)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 391, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 391 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0 -1,0,0);;_stencil_val_a(uf.x,0,0,0);                   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(cs,0,0 -1,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0 -1,0);;_stencil_val_a(uf.y,0,0,0);                   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_value_z (point, u.z, 0);_stencil_val(u.z,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.z,0,0,0 -1); _stencil_val(cs,0,0,0 -1);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0 -1);;_stencil_val_a(uf.z,0,0,0);                   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 391 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.x,0,0,0) = val(fm.x,0,0,0)*((_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.))) + dt*_const_a.x);}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.y,0,0,0) = val(fm.y,0,0,0)*((_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.))) + dt*_const_a.y);}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.z,0,0,0) = val(fm.z,0,0,0)*((_attribute[u.z.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_value_z (point, u.z, 0) : ((val(u.z,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.z,0,0,0 -1)*(1.5 + val(cs,0,0,0 -1)))/ (val(cs,0,0,0) + val(cs,0,0,0 -1) + 3.))) + dt*_const_a.z);}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 391, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 391 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{; _stencil_val(fs.x,0,0,0); _stencil_val(fs.x,0,0,0); _stencil_embed_face_value_x (point, u.x, 0);_stencil_val(u.x,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.x,0 -1,0,0); _stencil_val(cs,0 -1,0,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0 -1,0,0);;_stencil_val_a(uf.x,0,0,0);                   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{; _stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,0,0); _stencil_embed_face_value_y (point, u.y, 0);_stencil_val(u.y,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.y,0,0 -1,0); _stencil_val(cs,0,0 -1,0);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0 -1,0);;_stencil_val_a(uf.y,0,0,0);                   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{; _stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,0); _stencil_embed_face_value_z (point, u.z, 0);_stencil_val(u.z,0,0,0); _stencil_val(cs,0,0,0); _stencil_val(u.z,0,0,0 -1); _stencil_val(cs,0,0,0 -1);_stencil_val(cs,0,0,0); _stencil_val(cs,0,0,0 -1);;_stencil_val_a(uf.z,0,0,0);                   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 391 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.x,0,0,0) = _const_fm.x*((_attribute[u.x.i].third && val(fs.x,0,0,0) < 1. && val(fs.x,0,0,0) > 0. ? embed_face_value_x (point, u.x, 0) : ((val(u.x,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.x,0 -1,0,0)*(1.5 + val(cs,0 -1,0,0)))/ (val(cs,0,0,0) + val(cs,0 -1,0,0) + 3.))) + dt*_const_a.x);}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.y,0,0,0) = _const_fm.y*((_attribute[u.y.i].third && val(fs.y,0,0,0) < 1. && val(fs.y,0,0,0) > 0. ? embed_face_value_y (point, u.y, 0) : ((val(u.y,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.y,0,0 -1,0)*(1.5 + val(cs,0,0 -1,0)))/ (val(cs,0,0,0) + val(cs,0,0 -1,0) + 3.))) + dt*_const_a.y);}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(uf.z,0,0,0) = _const_fm.z*((_attribute[u.z.i].third && val(fs.z,0,0,0) < 1. && val(fs.z,0,0,0) > 0. ? embed_face_value_z (point, u.z, 0) : ((val(u.z,0,0,0)*(1.5 + val(cs,0,0,0)) + val(u.z,0,0,0 -1)*(1.5 + val(cs,0,0,0 -1)))/ (val(cs,0,0,0) + val(cs,0,0,0 -1) + 3.))) + dt*_const_a.z);}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 392 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}
}{end_tracing("acceleration","/home/pwachara/basilisk/src/navier-stokes/centered.h",393);return 0;}end_tracing("acceleration","/home/pwachara/basilisk/src/navier-stokes/centered.h",393);}
#line 402 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
void centered_gradient (scalar p, vector g)
{





  vector  gf=new_face_vector("gf");
if(!is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x)){  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 410, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.x,0,0,0);_stencil_val(a.x,0,0,0); _stencil_val(alpha.x,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);_stencil_val_a(gf.x,0,0,0);   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.y,0,0,0);_stencil_val(a.y,0,0,0); _stencil_val(alpha.y,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);_stencil_val_a(gf.y,0,0,0);   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.z,0,0,0);_stencil_val(a.z,0,0,0); _stencil_val(alpha.z,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,0,-1);_stencil_val_a(gf.z,0,0,0);   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.x,0,0,0) = val(fm.x,0,0,0)*val(a.x,0,0,0) - val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.y,0,0,0) = val(fm.y,0,0,0)*val(a.y,0,0,0) - val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.z,0,0,0) = val(fm.z,0,0,0)*val(a.z,0,0,0) - val(alpha.z,0,0,0)*(val(p,0,0,0) - val(p,0,0,-1))/Delta;}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else if(is_constant(fm.x) && !is_constant(a.x) && !is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 410, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;_stencil_val(a.x,0,0,0); _stencil_val(alpha.x,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);_stencil_val_a(gf.x,0,0,0);   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;_stencil_val(a.y,0,0,0); _stencil_val(alpha.y,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);_stencil_val_a(gf.y,0,0,0);   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;_stencil_val(a.z,0,0,0); _stencil_val(alpha.z,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,0,-1);_stencil_val_a(gf.z,0,0,0);   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.x,0,0,0) = _const_fm.x*val(a.x,0,0,0) - val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.y,0,0,0) = _const_fm.y*val(a.y,0,0,0) - val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.z,0,0,0) = _const_fm.z*val(a.z,0,0,0) - val(alpha.z,0,0,0)*(val(p,0,0,0) - val(p,0,0,-1))/Delta;}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else if(!is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 410, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.x,0,0,0);; _stencil_val(alpha.x,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);_stencil_val_a(gf.x,0,0,0);   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.y,0,0,0);; _stencil_val(alpha.y,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);_stencil_val_a(gf.y,0,0,0);   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.z,0,0,0);; _stencil_val(alpha.z,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,0,-1);_stencil_val_a(gf.z,0,0,0);   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.x,0,0,0) = val(fm.x,0,0,0)*_const_a.x - val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.y,0,0,0) = val(fm.y,0,0,0)*_const_a.y - val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.z,0,0,0) = val(fm.z,0,0,0)*_const_a.z - val(alpha.z,0,0,0)*(val(p,0,0,0) - val(p,0,0,-1))/Delta;}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else if(is_constant(fm.x) && is_constant(a.x) && !is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 410, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;; _stencil_val(alpha.x,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);_stencil_val_a(gf.x,0,0,0);   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;; _stencil_val(alpha.y,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);_stencil_val_a(gf.y,0,0,0);   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;; _stencil_val(alpha.z,0,0,0);_stencil_val(p,0,0,0); _stencil_val(p,0,0,-1);_stencil_val_a(gf.z,0,0,0);   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.x,0,0,0) = _const_fm.x*_const_a.x - val(alpha.x,0,0,0)*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.y,0,0,0) = _const_fm.y*_const_a.y - val(alpha.y,0,0,0)*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.z,0,0,0) = _const_fm.z*_const_a.z - val(alpha.z,0,0,0)*(val(p,0,0,0) - val(p,0,0,-1))/Delta;}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else if(!is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 410, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.x,0,0,0);_stencil_val(a.x,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);_stencil_val_a(gf.x,0,0,0);   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.y,0,0,0);_stencil_val(a.y,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);_stencil_val_a(gf.y,0,0,0);   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.z,0,0,0);_stencil_val(a.z,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,0,0,-1);_stencil_val_a(gf.z,0,0,0);   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.x,0,0,0) = val(fm.x,0,0,0)*val(a.x,0,0,0) - _const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.y,0,0,0) = val(fm.y,0,0,0)*val(a.y,0,0,0) - _const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.z,0,0,0) = val(fm.z,0,0,0)*val(a.z,0,0,0) - _const_alpha.z*(val(p,0,0,0) - val(p,0,0,-1))/Delta;}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else if(is_constant(fm.x) && !is_constant(a.x) && is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 410, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;_stencil_val(a.x,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);_stencil_val_a(gf.x,0,0,0);   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;_stencil_val(a.y,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);_stencil_val_a(gf.y,0,0,0);   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;_stencil_val(a.z,0,0,0);;_stencil_val(p,0,0,0); _stencil_val(p,0,0,-1);_stencil_val_a(gf.z,0,0,0);   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.x,0,0,0) = _const_fm.x*val(a.x,0,0,0) - _const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.y,0,0,0) = _const_fm.y*val(a.y,0,0,0) - _const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.z,0,0,0) = _const_fm.z*val(a.z,0,0,0) - _const_alpha.z*(val(p,0,0,0) - val(p,0,0,-1))/Delta;}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else if(!is_constant(fm.x) && is_constant(a.x) && is_constant(alpha.x)){_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 410, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.x,0,0,0);;;_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);_stencil_val_a(gf.x,0,0,0);   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.y,0,0,0);;;_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);_stencil_val_a(gf.y,0,0,0);   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ _stencil_val(fm.z,0,0,0);;;_stencil_val(p,0,0,0); _stencil_val(p,0,0,-1);_stencil_val_a(gf.z,0,0,0);   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.x,0,0,0) = val(fm.x,0,0,0)*_const_a.x - _const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.y,0,0,0) = val(fm.y,0,0,0)*_const_a.y - _const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.z,0,0,0) = val(fm.z,0,0,0)*_const_a.z - _const_alpha.z*(val(p,0,0,0) - val(p,0,0,-1))/Delta;}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 410, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;;;_stencil_val(p,0,0,0); _stencil_val(p,-1,0,0);_stencil_val_a(gf.x,0,0,0);   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;;;_stencil_val(p,0,0,0); _stencil_val(p,0,-1,0);_stencil_val_a(gf.y,0,0,0);   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{;;;_stencil_val(p,0,0,0); _stencil_val(p,0,0,-1);_stencil_val_a(gf.z,0,0,0);   }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 410 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.x,0,0,0) = _const_fm.x*_const_a.x - _const_alpha.x*(val(p,0,0,0) - val(p,-1,0,0))/Delta;}  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.y,0,0,0) = _const_fm.y*_const_a.y - _const_alpha.y*(val(p,0,0,0) - val(p,0,-1,0))/Delta;}  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);
    
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
val(gf.z,0,0,0) = _const_fm.z*_const_a.z - _const_alpha.z*(val(p,0,0,0) - val(p,0,0,-1))/Delta;}  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 411 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}





  trash (((vector[]){g,{{-1},{-1},{-1}}}));
  if(!is_constant(fm.x)){  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 418, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 419 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
      {_stencil_val(gf.x,0,0,0); _stencil_val(gf.x,1,0,0);_stencil_val(fm.x,0,0,0); _stencil_val(fm.x,1,0,0);_stencil_val_a(g.x,0,0,0);      }      {_stencil_val(gf.y,0,0,0); _stencil_val(gf.y,0,1,0);_stencil_val(fm.y,0,0,0); _stencil_val(fm.y,0,1,0);_stencil_val_a(g.y,0,0,0);      }      {_stencil_val(gf.z,0,0,0); _stencil_val(gf.z,0,0,1);_stencil_val(fm.z,0,0,0); _stencil_val(fm.z,0,0,1);_stencil_val_a(g.z,0,0,0);      }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 419 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 419 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
      val(g.x,0,0,0) = (val(gf.x,0,0,0) + val(gf.x,1,0,0))/(val(fm.x,0,0,0) + val(fm.x,1,0,0) + 1e-30);      val(g.y,0,0,0) = (val(gf.y,0,0,0) + val(gf.y,0,1,0))/(val(fm.y,0,0,0) + val(fm.y,0,1,0) + 1e-30);      val(g.z,0,0,0) = (val(gf.z,0,0,0) + val(gf.z,0,0,1))/(val(fm.z,0,0,0) + val(fm.z,0,0,1) + 1e-30);}}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 420 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/centered.h", .line = 418, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 419 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
      {_stencil_val(gf.x,0,0,0); _stencil_val(gf.x,1,0,0);;;_stencil_val_a(g.x,0,0,0);      }      {_stencil_val(gf.y,0,0,0); _stencil_val(gf.y,0,1,0);;;_stencil_val_a(g.y,0,0,0);      }      {_stencil_val(gf.z,0,0,0); _stencil_val(gf.z,0,0,1);;;_stencil_val_a(g.z,0,0,0);      }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 419 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 419 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
{
      val(g.x,0,0,0) = (val(gf.x,0,0,0) + val(gf.x,1,0,0))/(_const_fm.x + _const_fm.x + 1e-30);      val(g.y,0,0,0) = (val(gf.y,0,0,0) + val(gf.y,0,1,0))/(_const_fm.y + _const_fm.y + 1e-30);      val(g.z,0,0,0) = (val(gf.z,0,0,0) + val(gf.z,0,0,1))/(_const_fm.z + _const_fm.z + 1e-30);}}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 420 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
}delete((scalar*)((vector[]){gf,{{-1},{-1},{-1}}}));
}






static int projection_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int projection(const int i,const double t,Event *_ev){tracing("projection","/home/pwachara/basilisk/src/navier-stokes/centered.h",428);
{
  mgp = project (uf, p, alpha, dt, mgp.nrelax);
  centered_gradient (p, g);




  correction (dt);
}{end_tracing("projection","/home/pwachara/basilisk/src/navier-stokes/centered.h",437);return 0;}end_tracing("projection","/home/pwachara/basilisk/src/navier-stokes/centered.h",437);}





static int end_timestep_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}static int end_timestep(const int i,const double t,Event *_ev){;return 0;}
#line 4 "CubicTest.c"
#line 1 "two-phase.h"
#line 1 "/home/pwachara/basilisk/src/two-phase.h"
#line 13 "/home/pwachara/basilisk/src/two-phase.h"
#line 1 "vof.h"
#line 1 "/home/pwachara/basilisk/src/vof.h"
#line 27 "/home/pwachara/basilisk/src/vof.h"

#line 44 "/home/pwachara/basilisk/src/vof.h"
extern scalar * interfaces;
extern vector uf;
extern double dt;








static double vof_concentration_gradient_x (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 57 "/home/pwachara/basilisk/src/vof.h"
static const double cmin = 0.5;
  double cl = val(c,-1,0,0), cc = val(c,0,0,0), cr = val(c,1,0,0);
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (val(t,-1,0,0)/cl, val(t,0,0,0)/cc, val(t,1,0,0)/cr)/Delta;
 else
   return (val(t,1,0,0)/cr - val(t,-1,0,0)/cl)/(2.*Delta);
      }
      else
 return (val(t,1,0,0)/cr - val(t,0,0,0)/cc)/Delta;
    }
    else if (cl >= cmin)
      return (val(t,0,0,0)/cc - val(t,-1,0,0)/cl)/Delta;
  }
  return 0.;
}
#line 55
static double vof_concentration_gradient_y (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 57 "/home/pwachara/basilisk/src/vof.h"
static const double cmin = 0.5;
  double cl = val(c,0,-1,0), cc = val(c,0,0,0), cr = val(c,0,1,0);
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (val(t,0,-1,0)/cl, val(t,0,0,0)/cc, val(t,0,1,0)/cr)/Delta;
 else
   return (val(t,0,1,0)/cr - val(t,0,-1,0)/cl)/(2.*Delta);
      }
      else
 return (val(t,0,1,0)/cr - val(t,0,0,0)/cc)/Delta;
    }
    else if (cl >= cmin)
      return (val(t,0,0,0)/cc - val(t,0,-1,0)/cl)/Delta;
  }
  return 0.;
}
#line 55
static double vof_concentration_gradient_z (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 57 "/home/pwachara/basilisk/src/vof.h"
static const double cmin = 0.5;
  double cl = val(c,0,0,-1), cc = val(c,0,0,0), cr = val(c,0,0,1);
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (val(t,0,0,-1)/cl, val(t,0,0,0)/cc, val(t,0,0,1)/cr)/Delta;
 else
   return (val(t,0,0,1)/cr - val(t,0,0,-1)/cl)/(2.*Delta);
      }
      else
 return (val(t,0,0,1)/cr - val(t,0,0,0)/cc)/Delta;
    }
    else if (cl >= cmin)
      return (val(t,0,0,0)/cc - val(t,0,0,-1)/cl)/Delta;
  }
  return 0.;
}
#line 55
static void _stencil_vof_concentration_gradient_x (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 58 "/home/pwachara/basilisk/src/vof.h"
_stencil_val(c,1,0,0); _stencil_val(c,0,0,0); _stencil_val(c,-1,0,0); 


{
{ {
{ {
 if (_attribute[t.i].gradient)
   {_stencil_val(t,-1,0,0); _stencil_val(t,0,0,0); _stencil_val(t,1,0,0);  }
 else
   {_stencil_val(t,1,0,0); _stencil_val(t,-1,0,0);  }
      }
 
{_stencil_val(t,1,0,0); _stencil_val(t,0,0,0);  }}    
}
      
{_stencil_val(t,0,0,0); _stencil_val(t,-1,0,0);  }}  
}  
return ;
}
#line 55
static void _stencil_vof_concentration_gradient_y (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 58 "/home/pwachara/basilisk/src/vof.h"
_stencil_val(c,0,1,0); _stencil_val(c,0,0,0); _stencil_val(c,0,-1,0); 


{
{ {
{ {
 if (_attribute[t.i].gradient)
   {_stencil_val(t,0,-1,0); _stencil_val(t,0,0,0); _stencil_val(t,0,1,0);  }
 else
   {_stencil_val(t,0,1,0); _stencil_val(t,0,-1,0);  }
      }
 
{_stencil_val(t,0,1,0); _stencil_val(t,0,0,0);  }}    
}
      
{_stencil_val(t,0,0,0); _stencil_val(t,0,-1,0);  }}  
}  
return ;
}
#line 55
static void _stencil_vof_concentration_gradient_z (Point point, scalar c, scalar t)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 58 "/home/pwachara/basilisk/src/vof.h"
_stencil_val(c,0,0,1); _stencil_val(c,0,0,0); _stencil_val(c,0,0,-1); 


{
{ {
{ {
 if (_attribute[t.i].gradient)
   {_stencil_val(t,0,0,-1); _stencil_val(t,0,0,0); _stencil_val(t,0,0,1);  }
 else
   {_stencil_val(t,0,0,1); _stencil_val(t,0,0,-1);  }
      }
 
{_stencil_val(t,0,0,1); _stencil_val(t,0,0,0);  }}    
}
      
{_stencil_val(t,0,0,0); _stencil_val(t,0,0,-1);  }}  
}  
return ;
}
#line 127
static int defaults_2_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}
#line 127 "/home/pwachara/basilisk/src/vof.h"
      static int defaults_2(const int i,const double t,Event *_ev){tracing("defaults_2","/home/pwachara/basilisk/src/vof.h",127);
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
    scalar * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){
      _attribute[t.i].depends = list_add (_attribute[t.i].depends, c);}}
  }}}
}{end_tracing("defaults_2","/home/pwachara/basilisk/src/vof.h",134);return 0;}end_tracing("defaults_2","/home/pwachara/basilisk/src/vof.h",134);}





static int stability_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int stability_0(const int i,const double t,Event *_ev){tracing("stability_0","/home/pwachara/basilisk/src/vof.h",140); {
  if (CFL > 0.5)
    CFL = 0.5;
}{end_tracing("stability_0","/home/pwachara/basilisk/src/vof.h",143);return 0;}end_tracing("stability_0","/home/pwachara/basilisk/src/vof.h",143);}
#line 157 "/home/pwachara/basilisk/src/vof.h"

static void sweep_x (scalar c, scalar cc, scalar * tcl)
{
  vector  n=new_vector("n");
  scalar  alpha=new_scalar("alpha"),  flux=new_scalar("flux");
  double cfl = 0.;
#line 171 "/home/pwachara/basilisk/src/vof.h"
  scalar * tracers = _attribute[c.i].tracers, * gfl = NULL, * tfluxl = NULL;
  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }}}
  




    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 182, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 182 "/home/pwachara/basilisk/src/vof.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 { _stencil_vof_concentration_gradient_x (point, c, t);_stencil_val_a(gf,0,0,0); }}}
    }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 182 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 182 "/home/pwachara/basilisk/src/vof.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 val(gf,0,0,0) = vof_concentration_gradient_x (point, c, t);}}
    }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 187 "/home/pwachara/basilisk/src/vof.h"
}






  reconstruction (c, n, alpha);
if(!is_constant(fm.x) && !is_constant(cm)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{              






    _stencil_val(fm.x,0,0,0); _stencil_val(uf.x,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);
      {_stencil_val(fm.x,0,0,0);_stencil_val(cm,0,0,0);    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha, o_stencil,0,0);_stencil_val(n.z, o_stencil,0,0);_stencil_val(n.y, o_stencil,0,0);_stencil_val(n.x,o_stencil,0,0);
#line 225
_stencil_val(c, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(c,o_stencil,0,0);








_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c, o_stencil,0,0);


{ {               
 _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
_stencil_val(uf.x,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 385
{
  if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.x,0,0,0)*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*val(fm.x,0,0,0)*s/(val(cm,0,0,0) + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.) ? val(c,i,0,0) :
      rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), val(n.z,i,0,0)}, val(alpha,i,0,0),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.x,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,i,0,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,i,0,0)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.x,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(fm.x) && !is_constant(cm)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






; _stencil_val(uf.x,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {;_stencil_val(cm,0,0,0);
      {;_stencil_val(cm,0,0,0);    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha, o_stencil,0,0);_stencil_val(n.z, o_stencil,0,0);_stencil_val(n.y, o_stencil,0,0);_stencil_val(n.x,o_stencil,0,0);
#line 225
_stencil_val(c, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(c,o_stencil,0,0);








_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c, o_stencil,0,0);


{ {               
 _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
_stencil_val(uf.x,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 385
{
  if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.x*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*_const_fm.x*s/(val(cm,0,0,0) + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.) ? val(c,i,0,0) :
      rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), val(n.z,i,0,0)}, val(alpha,i,0,0),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.x,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,i,0,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,i,0,0)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.x,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(fm.x) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{              






    _stencil_val(fm.x,0,0,0); _stencil_val(uf.x,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {_stencil_val(fm.x,0,0,0);;
      {_stencil_val(fm.x,0,0,0);;    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha, o_stencil,0,0);_stencil_val(n.z, o_stencil,0,0);_stencil_val(n.y, o_stencil,0,0);_stencil_val(n.x,o_stencil,0,0);
#line 225
_stencil_val(c, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(c,o_stencil,0,0);








_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c, o_stencil,0,0);


{ {               
 _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
_stencil_val(uf.x,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 385
{
  if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.x,0,0,0)*dt/(Delta*val(fm.x,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.x,0,0,0)*s/(_const_cm + 1e-30) > cfl)
      cfl = un*val(fm.x,0,0,0)*s/(_const_cm + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.) ? val(c,i,0,0) :
      rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), val(n.z,i,0,0)}, val(alpha,i,0,0),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.x,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,i,0,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,i,0,0)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.x,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






; _stencil_val(uf.x,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {;;
      {;;    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha, o_stencil,0,0);_stencil_val(n.z, o_stencil,0,0);_stencil_val(n.y, o_stencil,0,0);_stencil_val(n.x,o_stencil,0,0);
#line 225
_stencil_val(c, o_stencil,0,0);_stencil_val(c, o_stencil,0,0);_stencil_val(c,o_stencil,0,0);








_stencil_val(uf.x,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c, o_stencil,0,0);


{ {               
 _stencil_val(gf,o_stencil,0,0);_stencil_val(t, o_stencil,0,0);
_stencil_val(uf.x,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 385
{
  if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.x,0,0,0)*dt/(Delta*_const_fm.x + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.x*s/(_const_cm + 1e-30) > cfl)
      cfl = un*_const_fm.x*s/(_const_cm + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,i,0,0) <= 0. || val(c,i,0,0) >= 1.) ? val(c,i,0,0) :
      rectangle_fraction ((coord){-s*val(n.x,i,0,0), val(n.y,i,0,0), val(n.z,i,0,0)}, val(alpha,i,0,0),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.x,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,i,0,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,i,0,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,i,0,0)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.x,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}
  delete (gfl); pfree (gfl,__func__,__FILE__,__LINE__);




  if (cfl > 0.5 + 1e-6)
    fprintf (ferr,
      "src/vof.h:%d: warning: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      262, cfl - 0.5), fflush (ferr);
#line 303 "/home/pwachara/basilisk/src/vof.h"
  if(!is_constant(cm)){
  
#line 303 "/home/pwachara/basilisk/src/vof.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 303, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{_stencil_val(cs,0,0,0); {
_stencil_val(cs,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,1,0,0); _stencil_val(cc,0,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);_stencil_val(cm,0,0,0);      _stencil_val_r(c,0,0,0);     




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 {_stencil_val(cs,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,1,0,0); _stencil_val(tc,0,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);_stencil_val(cm,0,0,0);_stencil_val_r(t,0,0,0);     }}}

    }   }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 304 "/home/pwachara/basilisk/src/vof.h"
if (val(cs,0,0,0) > 0.) {
      val(c,0,0,0) += dt*val(cs,0,0,0)*(val(flux,0,0,0) - val(flux,1,0,0) + val(cc,0,0,0)*(val(uf.x,1,0,0) - val(uf.x,0,0,0)))/(val(cm,0,0,0)*Delta);




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 val(t,0,0,0) += dt*val(cs,0,0,0)*(val(tflux,0,0,0) - val(tflux,1,0,0) + val(tc,0,0,0)*(val(uf.x,1,0,0) - val(uf.x,0,0,0)))/(val(cm,0,0,0)*Delta);}}

    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 314 "/home/pwachara/basilisk/src/vof.h"
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#line 303 "/home/pwachara/basilisk/src/vof.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 303, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{_stencil_val(cs,0,0,0); {
_stencil_val(cs,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,1,0,0); _stencil_val(cc,0,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);;      _stencil_val_r(c,0,0,0);     




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 {_stencil_val(cs,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,1,0,0); _stencil_val(tc,0,0,0);_stencil_val(uf.x,1,0,0); _stencil_val(uf.x,0,0,0);;_stencil_val_r(t,0,0,0);     }}}

    }   }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 304 "/home/pwachara/basilisk/src/vof.h"
if (val(cs,0,0,0) > 0.) {
      val(c,0,0,0) += dt*val(cs,0,0,0)*(val(flux,0,0,0) - val(flux,1,0,0) + val(cc,0,0,0)*(val(uf.x,1,0,0) - val(uf.x,0,0,0)))/(_const_cm*Delta);




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 val(t,0,0,0) += dt*val(cs,0,0,0)*(val(tflux,0,0,0) - val(tflux,1,0,0) + val(tc,0,0,0)*(val(uf.x,1,0,0) - val(uf.x,0,0,0)))/(_const_cm*Delta);}}

    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 314 "/home/pwachara/basilisk/src/vof.h"
}


  delete (tfluxl); pfree (tfluxl,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){flux,alpha,n.x,n.y,n.z,{-1}}));
}
#line 158
static void sweep_y (scalar c, scalar cc, scalar * tcl)
{
  vector  n=new_vector("n");
  scalar  alpha=new_scalar("alpha"),  flux=new_scalar("flux");
  double cfl = 0.;
#line 171 "/home/pwachara/basilisk/src/vof.h"
  scalar * tracers = _attribute[c.i].tracers, * gfl = NULL, * tfluxl = NULL;
  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }}}
  




    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 182, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 182 "/home/pwachara/basilisk/src/vof.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 { _stencil_vof_concentration_gradient_y (point, c, t);_stencil_val_a(gf,0,0,0); }}}
    }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 182 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 182 "/home/pwachara/basilisk/src/vof.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 val(gf,0,0,0) = vof_concentration_gradient_y (point, c, t);}}
    }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 187 "/home/pwachara/basilisk/src/vof.h"
}






  reconstruction (c, n, alpha);
if(!is_constant(fm.y) && !is_constant(cm)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{              






    _stencil_val(fm.y,0,0,0); _stencil_val(uf.y,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);
      {_stencil_val(fm.y,0,0,0);_stencil_val(cm,0,0,0);    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha,0, o_stencil,0);_stencil_val(n.x,0, o_stencil,0);_stencil_val(n.z,0, o_stencil,0);_stencil_val(n.y,0,o_stencil,0);
#line 225
_stencil_val(c,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(c,0,o_stencil,0);








_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0, o_stencil,0);


{ {               
 _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
_stencil_val(uf.y,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 392
{
  if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.y,0,0,0)*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*val(fm.y,0,0,0)*s/(val(cm,0,0,0) + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.) ? val(c,0,i,0) :
      rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.z,0,i,0), val(n.x,0,i,0)}, val(alpha,0,i,0),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.y,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,0,i,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,i,0)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.y,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(fm.y) && !is_constant(cm)){_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






; _stencil_val(uf.y,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {;_stencil_val(cm,0,0,0);
      {;_stencil_val(cm,0,0,0);    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha,0, o_stencil,0);_stencil_val(n.x,0, o_stencil,0);_stencil_val(n.z,0, o_stencil,0);_stencil_val(n.y,0,o_stencil,0);
#line 225
_stencil_val(c,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(c,0,o_stencil,0);








_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0, o_stencil,0);


{ {               
 _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
_stencil_val(uf.y,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 392
{
  if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.y*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*_const_fm.y*s/(val(cm,0,0,0) + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.) ? val(c,0,i,0) :
      rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.z,0,i,0), val(n.x,0,i,0)}, val(alpha,0,i,0),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.y,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,0,i,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,i,0)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.y,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(fm.y) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{              






    _stencil_val(fm.y,0,0,0); _stencil_val(uf.y,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {_stencil_val(fm.y,0,0,0);;
      {_stencil_val(fm.y,0,0,0);;    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha,0, o_stencil,0);_stencil_val(n.x,0, o_stencil,0);_stencil_val(n.z,0, o_stencil,0);_stencil_val(n.y,0,o_stencil,0);
#line 225
_stencil_val(c,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(c,0,o_stencil,0);








_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0, o_stencil,0);


{ {               
 _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
_stencil_val(uf.y,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 392
{
  if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.y,0,0,0)*dt/(Delta*val(fm.y,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.y,0,0,0)*s/(_const_cm + 1e-30) > cfl)
      cfl = un*val(fm.y,0,0,0)*s/(_const_cm + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.) ? val(c,0,i,0) :
      rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.z,0,i,0), val(n.x,0,i,0)}, val(alpha,0,i,0),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.y,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,0,i,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,i,0)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.y,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else {_coord _const_fm={_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX],_constant[fm.x.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






; _stencil_val(uf.y,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {;;
      {;;    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha,0, o_stencil,0);_stencil_val(n.x,0, o_stencil,0);_stencil_val(n.z,0, o_stencil,0);_stencil_val(n.y,0,o_stencil,0);
#line 225
_stencil_val(c,0, o_stencil,0);_stencil_val(c,0, o_stencil,0);_stencil_val(c,0,o_stencil,0);








_stencil_val(uf.y,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0, o_stencil,0);


{ {               
 _stencil_val(gf,0,o_stencil,0);_stencil_val(t,0, o_stencil,0);
_stencil_val(uf.y,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 392
{
  if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.y,0,0,0)*dt/(Delta*_const_fm.y + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.y*s/(_const_cm + 1e-30) > cfl)
      cfl = un*_const_fm.y*s/(_const_cm + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,0,i,0) <= 0. || val(c,0,i,0) >= 1.) ? val(c,0,i,0) :
      rectangle_fraction ((coord){-s*val(n.y,0,i,0), val(n.z,0,i,0), val(n.x,0,i,0)}, val(alpha,0,i,0),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.y,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,i,0);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,0,i,0)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,i,0)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.y,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}
  delete (gfl); pfree (gfl,__func__,__FILE__,__LINE__);




  if (cfl > 0.5 + 1e-6)
    fprintf (ferr,
      "src/vof.h:%d: warning: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      262, cfl - 0.5), fflush (ferr);
#line 303 "/home/pwachara/basilisk/src/vof.h"
  if(!is_constant(cm)){
  
#line 303 "/home/pwachara/basilisk/src/vof.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 303, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{_stencil_val(cs,0,0,0); {
_stencil_val(cs,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,0,1,0); _stencil_val(cc,0,0,0);_stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);_stencil_val(cm,0,0,0);      _stencil_val_r(c,0,0,0);     




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 {_stencil_val(cs,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,0,1,0); _stencil_val(tc,0,0,0);_stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);_stencil_val(cm,0,0,0);_stencil_val_r(t,0,0,0);     }}}

    }   }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 304 "/home/pwachara/basilisk/src/vof.h"
if (val(cs,0,0,0) > 0.) {
      val(c,0,0,0) += dt*val(cs,0,0,0)*(val(flux,0,0,0) - val(flux,0,1,0) + val(cc,0,0,0)*(val(uf.y,0,1,0) - val(uf.y,0,0,0)))/(val(cm,0,0,0)*Delta);




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 val(t,0,0,0) += dt*val(cs,0,0,0)*(val(tflux,0,0,0) - val(tflux,0,1,0) + val(tc,0,0,0)*(val(uf.y,0,1,0) - val(uf.y,0,0,0)))/(val(cm,0,0,0)*Delta);}}

    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 314 "/home/pwachara/basilisk/src/vof.h"
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#line 303 "/home/pwachara/basilisk/src/vof.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 303, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{_stencil_val(cs,0,0,0); {
_stencil_val(cs,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,0,1,0); _stencil_val(cc,0,0,0);_stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);;      _stencil_val_r(c,0,0,0);     




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 {_stencil_val(cs,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,0,1,0); _stencil_val(tc,0,0,0);_stencil_val(uf.y,0,1,0); _stencil_val(uf.y,0,0,0);;_stencil_val_r(t,0,0,0);     }}}

    }   }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 304 "/home/pwachara/basilisk/src/vof.h"
if (val(cs,0,0,0) > 0.) {
      val(c,0,0,0) += dt*val(cs,0,0,0)*(val(flux,0,0,0) - val(flux,0,1,0) + val(cc,0,0,0)*(val(uf.y,0,1,0) - val(uf.y,0,0,0)))/(_const_cm*Delta);




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 val(t,0,0,0) += dt*val(cs,0,0,0)*(val(tflux,0,0,0) - val(tflux,0,1,0) + val(tc,0,0,0)*(val(uf.y,0,1,0) - val(uf.y,0,0,0)))/(_const_cm*Delta);}}

    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 314 "/home/pwachara/basilisk/src/vof.h"
}


  delete (tfluxl); pfree (tfluxl,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){flux,alpha,n.x,n.y,n.z,{-1}}));
}
#line 158
static void sweep_z (scalar c, scalar cc, scalar * tcl)
{
  vector  n=new_vector("n");
  scalar  alpha=new_scalar("alpha"),  flux=new_scalar("flux");
  double cfl = 0.;
#line 171 "/home/pwachara/basilisk/src/vof.h"
  scalar * tracers = _attribute[c.i].tracers, * gfl = NULL, * tfluxl = NULL;
  if (tracers) {
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }}}
  




    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 182, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 182 "/home/pwachara/basilisk/src/vof.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 { _stencil_vof_concentration_gradient_z (point, c, t);_stencil_val_a(gf,0,0,0); }}}
    }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 182 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 182 "/home/pwachara/basilisk/src/vof.h"
{
      scalar t, gf;
      {scalar*_i0=gfl;scalar*_i1= tracers;if(_i0)for(gf=*_i0,t=*_i1;_i0->i>= 0;gf=*++_i0,t=*++_i1){
 val(gf,0,0,0) = vof_concentration_gradient_z (point, c, t);}}
    }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 187 "/home/pwachara/basilisk/src/vof.h"
}






  reconstruction (c, n, alpha);
if(!is_constant(fm.z) && !is_constant(cm)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 379
{ _loop.face |= (1 << 2); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{              






    _stencil_val(fm.z,0,0,0); _stencil_val(uf.z,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {_stencil_val(fm.z,0,0,0);_stencil_val(cm,0,0,0);
      {_stencil_val(fm.z,0,0,0);_stencil_val(cm,0,0,0);    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha,0,0, o_stencil);_stencil_val(n.y,0,0, o_stencil);_stencil_val(n.x,0,0, o_stencil);_stencil_val(n.z,0,0,o_stencil);
#line 225
_stencil_val(c,0,0, o_stencil);_stencil_val(c,0,0, o_stencil);_stencil_val(c,0,0,o_stencil);








_stencil_val(uf.z,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0,0, o_stencil);


{ {               
 _stencil_val(gf,0,0,o_stencil);_stencil_val(t,0,0, o_stencil);
_stencil_val(uf.z,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 399
{
  if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.z,0,0,0)*dt/(Delta*val(fm.z,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.z,0,0,0)*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*val(fm.z,0,0,0)*s/(val(cm,0,0,0) + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,0,0,i) <= 0. || val(c,0,0,i) >= 1.) ? val(c,0,0,i) :
      rectangle_fraction ((coord){-s*val(n.z,0,0,i), val(n.x,0,0,i), val(n.y,0,0,i)}, val(alpha,0,0,i),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.z,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,0,i);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,0,0,i)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,0,i)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.z,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(is_constant(fm.z) && !is_constant(cm)){_coord _const_fm={_constant[fm.z.i-_NVARMAX],_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 379
{ _loop.face |= (1 << 2); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






; _stencil_val(uf.z,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {;_stencil_val(cm,0,0,0);
      {;_stencil_val(cm,0,0,0);    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha,0,0, o_stencil);_stencil_val(n.y,0,0, o_stencil);_stencil_val(n.x,0,0, o_stencil);_stencil_val(n.z,0,0,o_stencil);
#line 225
_stencil_val(c,0,0, o_stencil);_stencil_val(c,0,0, o_stencil);_stencil_val(c,0,0,o_stencil);








_stencil_val(uf.z,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0,0, o_stencil);


{ {               
 _stencil_val(gf,0,0,o_stencil);_stencil_val(t,0,0, o_stencil);
_stencil_val(uf.z,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 399
{
  if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.z,0,0,0)*dt/(Delta*_const_fm.z + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.z*s/(val(cm,0,0,0) + 1e-30) > cfl)
      cfl = un*_const_fm.z*s/(val(cm,0,0,0) + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,0,0,i) <= 0. || val(c,0,0,i) >= 1.) ? val(c,0,0,i) :
      rectangle_fraction ((coord){-s*val(n.z,0,0,i), val(n.x,0,0,i), val(n.y,0,0,i)}, val(alpha,0,0,i),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.z,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,0,i);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,0,0,i)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,0,i)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.z,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else if(!is_constant(fm.z) && is_constant(cm)){double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 379
{ _loop.face |= (1 << 2); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{              






    _stencil_val(fm.z,0,0,0); _stencil_val(uf.z,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {_stencil_val(fm.z,0,0,0);;
      {_stencil_val(fm.z,0,0,0);;    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha,0,0, o_stencil);_stencil_val(n.y,0,0, o_stencil);_stencil_val(n.x,0,0, o_stencil);_stencil_val(n.z,0,0,o_stencil);
#line 225
_stencil_val(c,0,0, o_stencil);_stencil_val(c,0,0, o_stencil);_stencil_val(c,0,0,o_stencil);








_stencil_val(uf.z,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0,0, o_stencil);


{ {               
 _stencil_val(gf,0,0,o_stencil);_stencil_val(t,0,0, o_stencil);
_stencil_val(uf.z,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 399
{
  if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.z,0,0,0)*dt/(Delta*val(fm.z,0,0,0) + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*val(fm.z,0,0,0)*s/(_const_cm + 1e-30) > cfl)
      cfl = un*val(fm.z,0,0,0)*s/(_const_cm + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,0,0,i) <= 0. || val(c,0,0,i) >= 1.) ? val(c,0,0,i) :
      rectangle_fraction ((coord){-s*val(n.z,0,0,i), val(n.x,0,0,i), val(n.y,0,0,i)}, val(alpha,0,0,i),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.z,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,0,i);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,0,0,i)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,0,i)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.z,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}else {_coord _const_fm={_constant[fm.z.i-_NVARMAX],_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX]};NOT_UNUSED(_const_fm);double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 195, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 379
{ _loop.face |= (1 << 2); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






; _stencil_val(uf.z,0,0,0);     
    





_stencil_val(cs,0,0,0);

    {;;
      {;;    }     }              
       
      
      





       
#line 225 "/home/pwachara/basilisk/src/vof.h"
    
_stencil_val(alpha,0,0, o_stencil);_stencil_val(n.y,0,0, o_stencil);_stencil_val(n.x,0,0, o_stencil);_stencil_val(n.z,0,0,o_stencil);
#line 225
_stencil_val(c,0,0, o_stencil);_stencil_val(c,0,0, o_stencil);_stencil_val(c,0,0,o_stencil);








_stencil_val(uf.z,0,0,0);    _stencil_val_a(flux,0,0,0);  






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {     
      _stencil_val(c,0,0, o_stencil);


{ {               
 _stencil_val(gf,0,0,o_stencil);_stencil_val(t,0,0, o_stencil);
_stencil_val(uf.z,0,0,0); _stencil_val_a(tflux,0,0,0);  
      }
 
{_stencil_val_a(tflux,0,0,0);  }}    
}}}
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction (max:cfl)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 399
{
  if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 195 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 195 "/home/pwachara/basilisk/src/vof.h"
{






    double un = val(uf.z,0,0,0)*dt/(Delta*_const_fm.z + 1e-30), s = ( (int)(un > 0 ? 1 : -1));
    int i = -(s + 1.)/2.;





    if (val(cs,0,0,0) >= 1.)

    if (un*_const_fm.z*s/(_const_cm + 1e-30) > cfl)
      cfl = un*_const_fm.z*s/(_const_cm + 1e-30);
#line 225 "/home/pwachara/basilisk/src/vof.h"
    double cf = (val(c,0,0,i) <= 0. || val(c,0,0,i) >= 1.) ? val(c,0,0,i) :
      rectangle_fraction ((coord){-s*val(n.z,0,0,i), val(n.x,0,0,i), val(n.y,0,0,i)}, val(alpha,0,0,i),
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    val(flux,0,0,0) = cf*val(uf.z,0,0,0);






    scalar t, gf, tflux;
    {scalar*_i0=tfluxl;scalar*_i1=gfl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,gf=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,gf=*++_i1,t=*++_i2){ {
      double cf1 = cf, ci = val(c,0,0,i);
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = val(t,0,0,i)/ci + s*( 1. < (1. - s*un) ? 1. : (1. - s*un))*val(gf,0,0,i)*Delta/2.;
 val(tflux,0,0,0) = ff*cf1*val(uf.z,0,0,0);
      }
      else
 val(tflux,0,0,0) = 0.;
    }}}
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 253 "/home/pwachara/basilisk/src/vof.h"
{mpi_all_reduce_array(&cfl,MPI_DOUBLE,MPI_MAX,1);}}
  delete (gfl); pfree (gfl,__func__,__FILE__,__LINE__);




  if (cfl > 0.5 + 1e-6)
    fprintf (ferr,
      "src/vof.h:%d: warning: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      262, cfl - 0.5), fflush (ferr);
#line 303 "/home/pwachara/basilisk/src/vof.h"
  if(!is_constant(cm)){
  
#line 303 "/home/pwachara/basilisk/src/vof.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 303, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{_stencil_val(cs,0,0,0); {
_stencil_val(cs,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,0,0,1); _stencil_val(cc,0,0,0);_stencil_val(uf.z,0,0,1); _stencil_val(uf.z,0,0,0);_stencil_val(cm,0,0,0);      _stencil_val_r(c,0,0,0);     




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 {_stencil_val(cs,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,0,0,1); _stencil_val(tc,0,0,0);_stencil_val(uf.z,0,0,1); _stencil_val(uf.z,0,0,0);_stencil_val(cm,0,0,0);_stencil_val_r(t,0,0,0);     }}}

    }   }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 304 "/home/pwachara/basilisk/src/vof.h"
if (val(cs,0,0,0) > 0.) {
      val(c,0,0,0) += dt*val(cs,0,0,0)*(val(flux,0,0,0) - val(flux,0,0,1) + val(cc,0,0,0)*(val(uf.z,0,0,1) - val(uf.z,0,0,0)))/(val(cm,0,0,0)*Delta);




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 val(t,0,0,0) += dt*val(cs,0,0,0)*(val(tflux,0,0,0) - val(tflux,0,0,1) + val(tc,0,0,0)*(val(uf.z,0,0,1) - val(uf.z,0,0,0)))/(val(cm,0,0,0)*Delta);}}

    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 314 "/home/pwachara/basilisk/src/vof.h"
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  
#line 303 "/home/pwachara/basilisk/src/vof.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 303, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{_stencil_val(cs,0,0,0); {
_stencil_val(cs,0,0,0);_stencil_val(flux,0,0,0); _stencil_val(flux,0,0,1); _stencil_val(cc,0,0,0);_stencil_val(uf.z,0,0,1); _stencil_val(uf.z,0,0,0);;      _stencil_val_r(c,0,0,0);     




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 {_stencil_val(cs,0,0,0);_stencil_val(tflux,0,0,0); _stencil_val(tflux,0,0,1); _stencil_val(tc,0,0,0);_stencil_val(uf.z,0,0,1); _stencil_val(uf.z,0,0,0);;_stencil_val_r(t,0,0,0);     }}}

    }   }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 304 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 304 "/home/pwachara/basilisk/src/vof.h"
if (val(cs,0,0,0) > 0.) {
      val(c,0,0,0) += dt*val(cs,0,0,0)*(val(flux,0,0,0) - val(flux,0,0,1) + val(cc,0,0,0)*(val(uf.z,0,0,1) - val(uf.z,0,0,0)))/(_const_cm*Delta);




      scalar t, tc, tflux;
      {scalar*_i0= tfluxl;scalar*_i1= tcl;scalar*_i2= tracers;if(_i0)for(tflux=*_i0,tc=*_i1,t=*_i2;_i0->i>= 0;tflux=*++_i0,tc=*++_i1,t=*++_i2){
 val(t,0,0,0) += dt*val(cs,0,0,0)*(val(tflux,0,0,0) - val(tflux,0,0,1) + val(tc,0,0,0)*(val(uf.z,0,0,1) - val(uf.z,0,0,0)))/(_const_cm*Delta);}}

    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 314 "/home/pwachara/basilisk/src/vof.h"
}


  delete (tfluxl); pfree (tfluxl,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){flux,alpha,n.x,n.y,n.z,{-1}}));
}






void vof_advection (scalar * interfaces, int i)
{
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){ {
#line 337 "/home/pwachara/basilisk/src/vof.h"
    scalar  cc=new_scalar("cc"), * tcl = NULL, * tracers = _attribute[c.i].tracers;
    {scalar*_i=(scalar*)( tracers);if(_i)for(scalar t=*_i;(&t)->i>=0;t=*++_i){ {

      scalar tc = new_scalar("tc");
      tcl = list_append (tcl, tc);
#line 351 "/home/pwachara/basilisk/src/vof.h"
    }}}    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/vof.h", .line = 352, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 352 "/home/pwachara/basilisk/src/vof.h"
{
_stencil_val(c,0,0,0);      _stencil_val_a(cc,0,0,0);    

      scalar t, tc;
      {scalar*_i0= tcl;scalar*_i1= tracers;if(_i0)for(tc=*_i0,t=*_i1;_i0->i>= 0;tc=*++_i0,t=*++_i1){ {
 if (_attribute[t.i].inverse)
   { _stencil_val(c,0,0,0); _stencil_val(t,0,0,0); _stencil_val(c,0,0,0);_stencil_val_a(tc,0,0,0);       }
 else
   { _stencil_val(c,0,0,0); _stencil_val(t,0,0,0);_stencil_val(c,0,0,0);_stencil_val_a(tc,0,0,0);      }
      }}}

    }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 352 "/home/pwachara/basilisk/src/vof.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 352 "/home/pwachara/basilisk/src/vof.h"
{
      val(cc,0,0,0) = (val(c,0,0,0) > 0.5);

      scalar t, tc;
      {scalar*_i0= tcl;scalar*_i1= tracers;if(_i0)for(tc=*_i0,t=*_i1;_i0->i>= 0;tc=*++_i0,t=*++_i1){ {
 if (_attribute[t.i].inverse)
   val(tc,0,0,0) = val(c,0,0,0) < 0.5 ? val(t,0,0,0)/(1. - val(c,0,0,0)) : 0.;
 else
   val(tc,0,0,0) = val(c,0,0,0) > 0.5 ? val(t,0,0,0)/val(c,0,0,0) : 0.;
      }}}

    }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}






    
#line 370 "/home/pwachara/basilisk/src/vof.h"
void (* sweep[3]) (scalar, scalar, scalar *);
    int d = 0;
    
      sweep[d++] = sweep_x;      sweep[d++] = sweep_y;      sweep[d++] = sweep_z;
    for (d = 0; d < 3; d++)
      sweep[(i + d) % 3] (c, cc, tcl);
    delete (tcl), pfree (tcl,__func__,__FILE__,__LINE__);delete((scalar*)((scalar[]){cc,{-1}}));
  }}}
}

static int vof_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int vof_0(const int i,const double t,Event *_ev){tracing("vof_0","/home/pwachara/basilisk/src/vof.h",380);
{vof_advection (interfaces, i);  }{end_tracing("vof_0","/home/pwachara/basilisk/src/vof.h",381);return 0;}end_tracing("vof_0","/home/pwachara/basilisk/src/vof.h",381);}
#line 14 "/home/pwachara/basilisk/src/two-phase.h"

scalar  f={15}, * interfaces =((scalar[]) {{15},{-1}});

#line 1 "two-phase-generic.h"
#line 1 "/home/pwachara/basilisk/src/two-phase-generic.h"
double rho1 = 1., mu1 = 0., rho2 = 1., mu2 = 0.;





vector  alphav={{16},{17},{18}};
scalar  rhov={19};

static int defaults_3_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}      static int defaults_3(const int i,const double t,Event *_ev){tracing("defaults_3","/home/pwachara/basilisk/src/two-phase-generic.h",10);
{
  alpha = alphav;
  rho = rhov;





  if (mu1 || mu2)
    mu = new_face_vector("mu");




  display ("draw_vof (c = 'f');"
#line 494 "/home/pwachara/basilisk/src/common.h"
, false
#line 25 "/home/pwachara/basilisk/src/two-phase-generic.h"
);
}{end_tracing("defaults_3","/home/pwachara/basilisk/src/two-phase-generic.h",26);return 0;}end_tracing("defaults_3","/home/pwachara/basilisk/src/two-phase-generic.h",26);}
#line 50
static int tracer_advection_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 50 "/home/pwachara/basilisk/src/two-phase-generic.h"
static int tracer_advection_0(const int i,const double t,Event *_ev){
{
#line 79 "/home/pwachara/basilisk/src/two-phase-generic.h"
}return 0;}



static int properties_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int properties_0(const int i,const double t,Event *_ev){tracing("properties_0","/home/pwachara/basilisk/src/two-phase-generic.h",83);
{
if(!is_constant(fm.x)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/two-phase-generic.h", .line = 85, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{    
     _stencil_val(f,-1,0,0);_stencil_val(f,0,0,0); 
_stencil_val(fm.x,0,0,0);    _stencil_val_a(alphav.x,0,0,0);                  
    if (mu1 || mu2) {
      vector muv = mu; 
_stencil_val(fm.x,0,0,0);      _stencil_val_a(muv.x,0,0,0);                  
    }
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{    
     _stencil_val(f,0,-1,0);_stencil_val(f,0,0,0); 
_stencil_val(fm.y,0,0,0);    _stencil_val_a(alphav.y,0,0,0);                  
    if (mu1 || mu2) {
      vector muv = mu; 
_stencil_val(fm.y,0,0,0);      _stencil_val_a(muv.y,0,0,0);                  
    }
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{    
     _stencil_val(f,0,0,-1);_stencil_val(f,0,0,0); 
_stencil_val(fm.z,0,0,0);    _stencil_val_a(alphav.z,0,0,0);                  
    if (mu1 || mu2) {
      vector muv = mu; 
_stencil_val(fm.z,0,0,0);      _stencil_val_a(muv.z,0,0,0);                  
    }
  }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{
    double ff = (val(f,0,0,0) + val(f,-1,0,0))/2.;
    val(alphav.x,0,0,0) = val(fm.x,0,0,0)/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      val(muv.x,0,0,0) = val(fm.x,0,0,0)*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
    }
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{
    double ff = (val(f,0,0,0) + val(f,0,-1,0))/2.;
    val(alphav.y,0,0,0) = val(fm.y,0,0,0)/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      val(muv.y,0,0,0) = val(fm.y,0,0,0)*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
    }
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{
    double ff = (val(f,0,0,0) + val(f,0,0,-1))/2.;
    val(alphav.z,0,0,0) = val(fm.z,0,0,0)/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      val(muv.z,0,0,0) = val(fm.z,0,0,0)*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
    }
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 92 "/home/pwachara/basilisk/src/two-phase-generic.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 92 "/home/pwachara/basilisk/src/two-phase-generic.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/two-phase-generic.h", .line = 85, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{    
     _stencil_val(f,-1,0,0);_stencil_val(f,0,0,0);
;    _stencil_val_a(alphav.x,0,0,0);                  
    if (mu1 || mu2) {
      vector muv = mu;
;      _stencil_val_a(muv.x,0,0,0);                  
    }
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{    
     _stencil_val(f,0,-1,0);_stencil_val(f,0,0,0);
;    _stencil_val_a(alphav.y,0,0,0);                  
    if (mu1 || mu2) {
      vector muv = mu;
;      _stencil_val_a(muv.y,0,0,0);                  
    }
  } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{    
     _stencil_val(f,0,0,-1);_stencil_val(f,0,0,0);
;    _stencil_val_a(alphav.z,0,0,0);                  
    if (mu1 || mu2) {
      vector muv = mu;
;      _stencil_val_a(muv.z,0,0,0);                  
    }
  }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{
    double ff = (val(f,0,0,0) + val(f,-1,0,0))/2.;
    val(alphav.x,0,0,0) = _const_fm.x/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      val(muv.x,0,0,0) = _const_fm.x*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
    }
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{
    double ff = (val(f,0,0,0) + val(f,0,-1,0))/2.;
    val(alphav.y,0,0,0) = _const_fm.y/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      val(muv.y,0,0,0) = _const_fm.y*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
    }
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 85 "/home/pwachara/basilisk/src/two-phase-generic.h"
{
    double ff = (val(f,0,0,0) + val(f,0,0,-1))/2.;
    val(alphav.z,0,0,0) = _const_fm.z/(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      val(muv.z,0,0,0) = _const_fm.z*(( ff < 0. ? 0. : ff > 1. ? 1. : ff)*(mu1 - mu2) + mu2);
    }
  }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 92 "/home/pwachara/basilisk/src/two-phase-generic.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 92 "/home/pwachara/basilisk/src/two-phase-generic.h"
}

  if(!is_constant(cm)){
  

  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/two-phase-generic.h", .line = 94, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 95 "/home/pwachara/basilisk/src/two-phase-generic.h"
{ _stencil_val(cm,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val_a(rhov,0,0,0);                  }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 95 "/home/pwachara/basilisk/src/two-phase-generic.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 95 "/home/pwachara/basilisk/src/two-phase-generic.h"
val(rhov,0,0,0) = val(cm,0,0,0)*(( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)))*(rho1 - rho2) + rho2);}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 95 "/home/pwachara/basilisk/src/two-phase-generic.h"
}else {double _const_cm=_constant[cm.i-_NVARMAX];NOT_UNUSED(_const_cm);
  

  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/two-phase-generic.h", .line = 94, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 95 "/home/pwachara/basilisk/src/two-phase-generic.h"
{;_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val_a(rhov,0,0,0);                  }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 95 "/home/pwachara/basilisk/src/two-phase-generic.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 95 "/home/pwachara/basilisk/src/two-phase-generic.h"
val(rhov,0,0,0) = _const_cm*(( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)))*(rho1 - rho2) + rho2);}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 95 "/home/pwachara/basilisk/src/two-phase-generic.h"
}





}{end_tracing("properties_0","/home/pwachara/basilisk/src/two-phase-generic.h",101);return 0;}end_tracing("properties_0","/home/pwachara/basilisk/src/two-phase-generic.h",101);}
#line 37 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
static int defaults_4_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}
#line 18 "/home/pwachara/basilisk/src/two-phase.h"
#line 5 "CubicTest.c"
#line 1 "navier-stokes/conserving.h"
#line 1 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
#line 37 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
      static int defaults_4(const int i,const double t,Event *_ev){tracing("defaults_4","/home/pwachara/basilisk/src/navier-stokes/conserving.h",37);
{
  stokes = true;
#line 66 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
}{end_tracing("defaults_4","/home/pwachara/basilisk/src/navier-stokes/conserving.h",66);return 0;}end_tracing("defaults_4","/home/pwachara/basilisk/src/navier-stokes/conserving.h",66);}





static int stability_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int stability_1(const int i,const double t,Event *_ev){tracing("stability_1","/home/pwachara/basilisk/src/navier-stokes/conserving.h",72);
{dtmax = timestep (uf, dtmax);  }{end_tracing("stability_1","/home/pwachara/basilisk/src/navier-stokes/conserving.h",73);return 0;}end_tracing("stability_1","/home/pwachara/basilisk/src/navier-stokes/conserving.h",73);}








static double boundary_q1_x (Point neighbor, Point point, scalar q1, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 84 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
return ( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)))*rho1*val(u.x,0,0,0);
}
#line 82
static double boundary_q1_y (Point neighbor, Point point, scalar q1, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 84 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
return ( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)))*rho1*val(u.y,0,0,0);
}
#line 82
static double boundary_q1_z (Point neighbor, Point point, scalar q1, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 84 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
return ( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)))*rho1*val(u.z,0,0,0);
}


static double boundary_q2_x (Point neighbor, Point point, scalar q2, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 90 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
return (1. - ( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0))))*rho2*val(u.x,0,0,0);
}
#line 88
static double boundary_q2_y (Point neighbor, Point point, scalar q2, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 90 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
return (1. - ( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0))))*rho2*val(u.y,0,0,0);
}
#line 88
static double boundary_q2_z (Point neighbor, Point point, scalar q2, bool * data)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 90 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
return (1. - ( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0))))*rho2*val(u.z,0,0,0);
}
#line 115 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
static scalar * interfaces1 = NULL;

static int vof_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int vof_1(const int i,const double t,Event *_ev){tracing("vof_1","/home/pwachara/basilisk/src/navier-stokes/conserving.h",117); {







  vector  q1=new_vector("q1"),  q2=new_vector("q2");
  {scalar*_i=(scalar*)(((vector[]) {q1,q2,{{-1},{-1},{-1}}}));if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
    _attribute[s.i].depends = list_add (_attribute[s.i].depends, f);
    
      _attribute[s.i].v.x.i = -1;      _attribute[s.i].v.y.i = -1;      _attribute[s.i].v.z.i = -1;
  }}}
  for (int i = 0; i < nboundary; i++)
    { {
      _attribute[q1.x.i].boundary[i] = boundary_q1_x;
      _attribute[q2.x.i].boundary[i] = boundary_q2_x;
    } 
#line 132
{
      _attribute[q1.y.i].boundary[i] = boundary_q1_y;
      _attribute[q2.y.i].boundary[i] = boundary_q2_y;
    } 
#line 132
{
      _attribute[q1.z.i].boundary[i] = boundary_q1_z;
      _attribute[q2.z.i].boundary[i] = boundary_q2_z;
    }}
  
#line 147 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/conserving.h", .line = 147, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 148 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
{ {                
      _stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);
_stencil_val(u.x,0,0,0);      _stencil_val_a(q1.x,0,0,0);
_stencil_val(u.x,0,0,0);      _stencil_val_a(q2.x,0,0,0);    
    } 
#line 148
{                
      _stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);
_stencil_val(u.y,0,0,0);      _stencil_val_a(q1.y,0,0,0);
_stencil_val(u.y,0,0,0);      _stencil_val_a(q2.y,0,0,0);    
    } 
#line 148
{                
      _stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);
_stencil_val(u.z,0,0,0);      _stencil_val_a(q1.z,0,0,0);
_stencil_val(u.z,0,0,0);      _stencil_val_a(q2.z,0,0,0);    
    }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 148 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 148 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
{ {
      double fc = ( (val(f,0,0,0)) < 0 ? 0 : (val(f,0,0,0)) > 1 ? 1 : (val(f,0,0,0)));
      val(q1.x,0,0,0) = fc*rho1*val(u.x,0,0,0);
      val(q2.x,0,0,0) = (1. - fc)*rho2*val(u.x,0,0,0);
    } 
#line 148
{
      double fc = ( (val(f,0,0,0)) < 0 ? 0 : (val(f,0,0,0)) > 1 ? 1 : (val(f,0,0,0)));
      val(q1.y,0,0,0) = fc*rho1*val(u.y,0,0,0);
      val(q2.y,0,0,0) = (1. - fc)*rho2*val(u.y,0,0,0);
    } 
#line 148
{
      double fc = ( (val(f,0,0,0)) < 0 ? 0 : (val(f,0,0,0)) > 1 ? 1 : (val(f,0,0,0)));
      val(q1.z,0,0,0) = fc*rho1*val(u.z,0,0,0);
      val(q2.z,0,0,0) = (1. - fc)*rho2*val(u.z,0,0,0);
    }}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}   
#line 159 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
{
    _attribute[q2.x.i].inverse = true;
    _attribute[q1.x.i].gradient = _attribute[q2.x.i].gradient = _attribute[u.x.i].gradient;
  } 
#line 159
{
    _attribute[q2.y.i].inverse = true;
    _attribute[q1.y.i].gradient = _attribute[q2.y.i].gradient = _attribute[u.y.i].gradient;
  } 
#line 159
{
    _attribute[q2.z.i].inverse = true;
    _attribute[q1.z.i].gradient = _attribute[q2.z.i].gradient = _attribute[u.z.i].gradient;
  }





  scalar * tracers = _attribute[f.i].tracers;
  _attribute[f.i].tracers = list_concat (tracers, (scalar *)((vector[]){q1, q2,{{-1},{-1},{-1}}}));
  vof_advection (((scalar[]){f,{-1}}), i);
  pfree (_attribute[f.i].tracers,__func__,__FILE__,__LINE__);
  _attribute[f.i].tracers = tracers;
  





  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/navier-stokes/conserving.h", .line = 178, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 179 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
{
      {_stencil_val(q1.x,0,0,0); _stencil_val(q2.x,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val_a(u.x,0,0,0);                    }      {_stencil_val(q1.y,0,0,0); _stencil_val(q2.y,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val_a(u.y,0,0,0);                    }      {_stencil_val(q1.z,0,0,0); _stencil_val(q2.z,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val_a(u.z,0,0,0);                    }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 179 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 179 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
{
      val(u.x,0,0,0) = (val(q1.x,0,0,0) + val(q2.x,0,0,0))/(( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)))*(rho1 - rho2) + rho2);      val(u.y,0,0,0) = (val(q1.y,0,0,0) + val(q2.y,0,0,0))/(( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)))*(rho1 - rho2) + rho2);      val(u.z,0,0,0) = (val(q1.z,0,0,0) + val(q2.z,0,0,0))/(( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)))*(rho1 - rho2) + rho2);}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 186 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
interfaces1 = interfaces, interfaces = NULL;delete((scalar*)((vector[]){q2,q1,{{-1},{-1},{-1}}}));
}{end_tracing("vof_1","/home/pwachara/basilisk/src/navier-stokes/conserving.h",187);return 0;}end_tracing("vof_1","/home/pwachara/basilisk/src/navier-stokes/conserving.h",187);}




static int tracer_advection_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int tracer_advection_1(const int i,const double t,Event *_ev){tracing("tracer_advection_1","/home/pwachara/basilisk/src/navier-stokes/conserving.h",192); {
  interfaces = interfaces1;
}{end_tracing("tracer_advection_1","/home/pwachara/basilisk/src/navier-stokes/conserving.h",194);return 0;}end_tracing("tracer_advection_1","/home/pwachara/basilisk/src/navier-stokes/conserving.h",194);}
#line 30 "/home/pwachara/basilisk/src/iforce.h"
static int defaults_5_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 0)!=0;*ip=i;*tp=t;return ret;}
#line 6 "CubicTest.c"

#line 1 "tension.h"
#line 1 "/home/pwachara/basilisk/src/tension.h"
#line 15 "/home/pwachara/basilisk/src/tension.h"
#line 1 "iforce.h"
#line 1 "/home/pwachara/basilisk/src/iforce.h"
#line 20 "/home/pwachara/basilisk/src/iforce.h"










      static int defaults_5(const int i,const double t,Event *_ev){tracing("defaults_5","/home/pwachara/basilisk/src/iforce.h",30); {
  if (is_constant(a.x)) {
    a = new_face_vector("a");
if(!is_constant(a.x)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/iforce.h", .line = 33, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      _stencil_val_a(a.x,0,0,0);
_stencil_val(a.x,0,0,0);    
} 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      _stencil_val_a(a.y,0,0,0);
_stencil_val(a.y,0,0,0);    
} 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      _stencil_val_a(a.z,0,0,0);
_stencil_val(a.z,0,0,0);    
}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      val(a.x,0,0,0) = 0.;
      dimensional (val(a.x,0,0,0) == Delta/( DT*DT));
    }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      val(a.y,0,0,0) = 0.;
      dimensional (val(a.y,0,0,0) == Delta/( DT*DT));
    }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      val(a.z,0,0,0) = 0.;
      dimensional (val(a.z,0,0,0) == Delta/( DT*DT));
    }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 36 "/home/pwachara/basilisk/src/iforce.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 36 "/home/pwachara/basilisk/src/iforce.h"
}else {_coord _const_a={_constant[a.x.i-_NVARMAX],_constant[a.y.i-_NVARMAX],_constant[a.z.i-_NVARMAX]};NOT_UNUSED(_const_a);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/iforce.h", .line = 33, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      _stencil_val_a(a.x,0,0,0);
;    
} 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      _stencil_val_a(a.y,0,0,0);
;    
} 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      _stencil_val_a(a.z,0,0,0);
;    
}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      _const_a.x = 0.;
      dimensional (_const_a.x == Delta/( DT*DT));
    }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      _const_a.y = 0.;
      dimensional (_const_a.y == Delta/( DT*DT));
    }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg); 
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 33 "/home/pwachara/basilisk/src/iforce.h"
{
      _const_a.z = 0.;
      dimensional (_const_a.z == Delta/( DT*DT));
    }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 36 "/home/pwachara/basilisk/src/iforce.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 36 "/home/pwachara/basilisk/src/iforce.h"
}
  }
}{end_tracing("defaults_5","/home/pwachara/basilisk/src/iforce.h",38);return 0;}end_tracing("defaults_5","/home/pwachara/basilisk/src/iforce.h",38);}






static int acceleration_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int acceleration_0(const int i,const double t,Event *_ev){tracing("acceleration_0","/home/pwachara/basilisk/src/iforce.h",45);
{





  scalar * list = NULL;
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
    if (_attribute[f.i].phi.i) {
      list = list_add (list, f);
  






      
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/iforce.h", .line = 62, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 63 "/home/pwachara/basilisk/src/iforce.h"
{_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);_stencil_val_a(f,0,0,0);               }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 63 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 63 "/home/pwachara/basilisk/src/iforce.h"
val(f,0,0,0) = ( (val(f,0,0,0)) < 0. ? 0. : (val(f,0,0,0)) > 1. ? 1. : (val(f,0,0,0)));}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}    
#line 64 "/home/pwachara/basilisk/src/iforce.h"
}}}
#line 88 "/home/pwachara/basilisk/src/iforce.h"
  vector ia = a;
if(!is_constant(fm.x) && !is_constant(alpha.x)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/iforce.h", .line = 89, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 89 "/home/pwachara/basilisk/src/iforce.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val(fm.x,0,0,0); {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,-1,0,0);   _stencil_val(phi,-1,0,0); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 





_stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val_r(ia.x,0,0,0);    
      }     }}} 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val(fm.y,0,0,0); {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,-1,0);   _stencil_val(phi,0,-1,0); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 





_stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val_r(ia.y,0,0,0);    
      }     }}} 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,0,-1); _stencil_val(fm.z,0,0,0); {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,0,-1);   _stencil_val(phi,0,0,-1); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,0,0,-1);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,0,0,-1);_stencil_val(phi,0,0,0); 





_stencil_val(alpha.z,0,0,0);_stencil_val(fm.z,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,0,-1); _stencil_val_r(ia.z,0,0,0);    
      }     }}}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 89 "/home/pwachara/basilisk/src/iforce.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && val(fm.x,0,0,0) > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,-1,0,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,-1,0,0) < 1e30f ? val(phi,-1,0,0) :
   0.;

 val(ia.x,0,0,0) += val(alpha.x,0,0,0)/(val(fm.x,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;
      }}}}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && val(fm.y,0,0,0) > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,-1,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,-1,0) < 1e30f ? val(phi,0,-1,0) :
   0.;

 val(ia.y,0,0,0) += val(alpha.y,0,0,0)/(val(fm.y,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;
      }}}}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,0,-1) && val(fm.z,0,0,0) > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,0,-1) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,0,-1))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,0,-1) < 1e30f ? val(phi,0,0,-1) :
   0.;

 val(ia.z,0,0,0) += val(alpha.z,0,0,0)/(val(fm.z,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,0,-1))/Delta;
      }}}}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 110 "/home/pwachara/basilisk/src/iforce.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 110 "/home/pwachara/basilisk/src/iforce.h"
}else if(is_constant(fm.x) && !is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/iforce.h", .line = 89, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 89 "/home/pwachara/basilisk/src/iforce.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0);; {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,-1,0,0);   _stencil_val(phi,-1,0,0); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 





_stencil_val(alpha.x,0,0,0);;_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val_r(ia.x,0,0,0);    
      }     }}} 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0);; {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,-1,0);   _stencil_val(phi,0,-1,0); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 





_stencil_val(alpha.y,0,0,0);;_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val_r(ia.y,0,0,0);    
      }     }}} 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,0,-1);; {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,0,-1);   _stencil_val(phi,0,0,-1); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,0,0,-1);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,0,0,-1);_stencil_val(phi,0,0,0); 





_stencil_val(alpha.z,0,0,0);;_stencil_val(f,0,0,0); _stencil_val(f,0,0,-1); _stencil_val_r(ia.z,0,0,0);    
      }     }}}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 89 "/home/pwachara/basilisk/src/iforce.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && _const_fm.x > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,-1,0,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,-1,0,0) < 1e30f ? val(phi,-1,0,0) :
   0.;

 val(ia.x,0,0,0) += val(alpha.x,0,0,0)/(_const_fm.x + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;
      }}}}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && _const_fm.y > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,-1,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,-1,0) < 1e30f ? val(phi,0,-1,0) :
   0.;

 val(ia.y,0,0,0) += val(alpha.y,0,0,0)/(_const_fm.y + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;
      }}}}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,0,-1) && _const_fm.z > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,0,-1) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,0,-1))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,0,-1) < 1e30f ? val(phi,0,0,-1) :
   0.;

 val(ia.z,0,0,0) += val(alpha.z,0,0,0)/(_const_fm.z + 1e-30)*phif*(val(f,0,0,0) - val(f,0,0,-1))/Delta;
      }}}}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 110 "/home/pwachara/basilisk/src/iforce.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 110 "/home/pwachara/basilisk/src/iforce.h"
}else if(!is_constant(fm.x) && is_constant(alpha.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/iforce.h", .line = 89, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 89 "/home/pwachara/basilisk/src/iforce.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val(fm.x,0,0,0); {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,-1,0,0);   _stencil_val(phi,-1,0,0); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0);





;_stencil_val(fm.x,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val_r(ia.x,0,0,0);    
      }     }}} 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val(fm.y,0,0,0); {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,-1,0);   _stencil_val(phi,0,-1,0); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0);





;_stencil_val(fm.y,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val_r(ia.y,0,0,0);    
      }     }}} 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,0,-1); _stencil_val(fm.z,0,0,0); {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,0,-1);   _stencil_val(phi,0,0,-1); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,0,0,-1);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,0,0,-1);_stencil_val(phi,0,0,0);





;_stencil_val(fm.z,0,0,0);_stencil_val(f,0,0,0); _stencil_val(f,0,0,-1); _stencil_val_r(ia.z,0,0,0);    
      }     }}}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 89 "/home/pwachara/basilisk/src/iforce.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && val(fm.x,0,0,0) > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,-1,0,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,-1,0,0) < 1e30f ? val(phi,-1,0,0) :
   0.;

 val(ia.x,0,0,0) += _const_alpha.x/(val(fm.x,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;
      }}}}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && val(fm.y,0,0,0) > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,-1,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,-1,0) < 1e30f ? val(phi,0,-1,0) :
   0.;

 val(ia.y,0,0,0) += _const_alpha.y/(val(fm.y,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;
      }}}}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,0,-1) && val(fm.z,0,0,0) > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,0,-1) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,0,-1))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,0,-1) < 1e30f ? val(phi,0,0,-1) :
   0.;

 val(ia.z,0,0,0) += _const_alpha.z/(val(fm.z,0,0,0) + 1e-30)*phif*(val(f,0,0,0) - val(f,0,0,-1))/Delta;
      }}}}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 110 "/home/pwachara/basilisk/src/iforce.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 110 "/home/pwachara/basilisk/src/iforce.h"
}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/iforce.h", .line = 89, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 89 "/home/pwachara/basilisk/src/iforce.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0);; {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,-1,0,0);   _stencil_val(phi,-1,0,0); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,-1,0,0);_stencil_val(phi,0,0,0);





;;_stencil_val(f,0,0,0); _stencil_val(f,-1,0,0); _stencil_val_r(ia.x,0,0,0);    
      }     }}} 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0);; {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,-1,0);   _stencil_val(phi,0,-1,0); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,0,-1,0);_stencil_val(phi,0,0,0);





;;_stencil_val(f,0,0,0); _stencil_val(f,0,-1,0); _stencil_val_r(ia.y,0,0,0);    
      }     }}} 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      {_stencil_val(f,0,0,0); _stencil_val(f,0,0,-1);; {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;   
         
        
       
  
_stencil_val(phi,0,0,-1);   _stencil_val(phi,0,0,-1); 
#line 105
_stencil_val(phi,0,0,0);   _stencil_val(phi,0,0,0); 
#line 104
_stencil_val(phi,0,0,-1);_stencil_val(phi,0,0,0); 
#line 103
_stencil_val(phi,0,0,-1);_stencil_val(phi,0,0,0);





;;_stencil_val(f,0,0,0); _stencil_val(f,0,0,-1); _stencil_val_r(ia.z,0,0,0);    
      }     }}}}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 89 "/home/pwachara/basilisk/src/iforce.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,-1,0,0) && _const_fm.x > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,-1,0,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,-1,0,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,-1,0,0) < 1e30f ? val(phi,-1,0,0) :
   0.;

 val(ia.x,0,0,0) += _const_alpha.x/(_const_fm.x + 1e-30)*phif*(val(f,0,0,0) - val(f,-1,0,0))/Delta;
      }}}}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,-1,0) && _const_fm.y > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,-1,0) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,-1,0))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,-1,0) < 1e30f ? val(phi,0,-1,0) :
   0.;

 val(ia.y,0,0,0) += _const_alpha.y/(_const_fm.y + 1e-30)*phif*(val(f,0,0,0) - val(f,0,-1,0))/Delta;
      }}}}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 90 "/home/pwachara/basilisk/src/iforce.h"
{scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
      if (val(f,0,0,0) != val(f,0,0,-1) && _const_fm.z > 0.) {
#line 101 "/home/pwachara/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (val(phi,0,0,0) < 1e30f && val(phi,0,0,-1) < 1e30f) ?
   (val(phi,0,0,0) + val(phi,0,0,-1))/2. :
   val(phi,0,0,0) < 1e30f ? val(phi,0,0,0) :
   val(phi,0,0,-1) < 1e30f ? val(phi,0,0,-1) :
   0.;

 val(ia.z,0,0,0) += _const_alpha.z/(_const_fm.z + 1e-30)*phif*(val(f,0,0,0) - val(f,0,0,-1))/Delta;
      }}}}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 110 "/home/pwachara/basilisk/src/iforce.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 110 "/home/pwachara/basilisk/src/iforce.h"
}
#line 127 "/home/pwachara/basilisk/src/iforce.h"
  {scalar*_i=(scalar*)( list);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){ {
    scalar phi = _attribute[f.i].phi;
    delete (((scalar[]){phi,{-1}}));
    _attribute[f.i].phi.i = 0;
  }}}
  pfree (list,__func__,__FILE__,__LINE__);
}{end_tracing("acceleration_0","/home/pwachara/basilisk/src/iforce.h",133);return 0;}end_tracing("acceleration_0","/home/pwachara/basilisk/src/iforce.h",133);}
#line 16 "/home/pwachara/basilisk/src/tension.h"
#line 1 "curvature.h"
#line 1 "/home/pwachara/basilisk/src/curvature.h"
#line 68 "/home/pwachara/basilisk/src/curvature.h"
#line 1 "heights.h"
#line 1 "/home/pwachara/basilisk/src/heights.h"
#line 29 "/home/pwachara/basilisk/src/heights.h"
static inline double height (double H) {
  return H > 20./2. ? H - 20. : H < -20./2. ? H + 20. : H;
}

static inline int orientation (double H) {
  return fabs(H) > 20./2.;
}
#line 49 "/home/pwachara/basilisk/src/heights.h"
static void half_column (Point point, scalar c, vector h, vector cs, int j)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 57 "/home/pwachara/basilisk/src/heights.h"
const int complete = -1;

   {







    double S = val(c,0,0,0), H = S, ci;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (val(h.x,0,0,0) == 300.)
 state.s = complete, state.h = 1e30f;




      else {
 int s = (val(h.x,0,0,0) + 20./2.)/100.;
 state.h = val(h.x,0,0,0) - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
#line 109 "/home/pwachara/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? val(c,i*j,0,0) : val(cs.x,(i - 2)*j,0,0);
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
#line 138 "/home/pwachara/basilisk/src/heights.h"
      else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
#line 156 "/home/pwachara/basilisk/src/heights.h"
      else if (S == ci && trunc(H) != H)
 break;
    }





    if (j == -1) {







      if (S != complete && ((val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) ||
       (S > 0. && S < 1.)))
 val(h.x,0,0,0) = 300.;
      else if (S == complete)
 val(h.x,0,0,0) = H;
      else





 val(h.x,0,0,0) = H + 100.*(1. + (S >= 1.));
    }
    else {
#line 195 "/home/pwachara/basilisk/src/heights.h"
      if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 val(h.x,0,0,0) = 1e30f;
      else
 val(h.x,0,0,0) = (state.h > 1e10 ? 1e30f : state.h);
    }
  } 
#line 59
{







    double S = val(c,0,0,0), H = S, ci;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (val(h.y,0,0,0) == 300.)
 state.s = complete, state.h = 1e30f;




      else {
 int s = (val(h.y,0,0,0) + 20./2.)/100.;
 state.h = val(h.y,0,0,0) - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
#line 109 "/home/pwachara/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? val(c,0,i*j,0) : val(cs.y,0,(i - 2)*j,0);
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
#line 138 "/home/pwachara/basilisk/src/heights.h"
      else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
#line 156 "/home/pwachara/basilisk/src/heights.h"
      else if (S == ci && trunc(H) != H)
 break;
    }





    if (j == -1) {







      if (S != complete && ((val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) ||
       (S > 0. && S < 1.)))
 val(h.y,0,0,0) = 300.;
      else if (S == complete)
 val(h.y,0,0,0) = H;
      else





 val(h.y,0,0,0) = H + 100.*(1. + (S >= 1.));
    }
    else {
#line 195 "/home/pwachara/basilisk/src/heights.h"
      if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 val(h.y,0,0,0) = 1e30f;
      else
 val(h.y,0,0,0) = (state.h > 1e10 ? 1e30f : state.h);
    }
  } 
#line 59
{







    double S = val(c,0,0,0), H = S, ci;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (val(h.z,0,0,0) == 300.)
 state.s = complete, state.h = 1e30f;




      else {
 int s = (val(h.z,0,0,0) + 20./2.)/100.;
 state.h = val(h.z,0,0,0) - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
#line 109 "/home/pwachara/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? val(c,0,0,i*j) : val(cs.z,0,0,(i - 2)*j);
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
#line 138 "/home/pwachara/basilisk/src/heights.h"
      else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
#line 156 "/home/pwachara/basilisk/src/heights.h"
      else if (S == ci && trunc(H) != H)
 break;
    }





    if (j == -1) {







      if (S != complete && ((val(c,0,0,0) <= 0. || val(c,0,0,0) >= 1.) ||
       (S > 0. && S < 1.)))
 val(h.z,0,0,0) = 300.;
      else if (S == complete)
 val(h.z,0,0,0) = H;
      else





 val(h.z,0,0,0) = H + 100.*(1. + (S >= 1.));
    }
    else {
#line 195 "/home/pwachara/basilisk/src/heights.h"
      if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 val(h.z,0,0,0) = 1e30f;
      else
 val(h.z,0,0,0) = (state.h > 1e10 ? 1e30f : state.h);
    }
  }
}
#line 49 "/home/pwachara/basilisk/src/heights.h"
static void _stencil_half_column (Point point, scalar c, vector h, vector cs, int j)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
#line 59 "/home/pwachara/basilisk/src/heights.h"
{      







     _stencil_val_o(c,0,0,0);            







    
    
    if (j == 1) {




_stencil_val_o(h.x,0,0,0);{ 
      




{     
 _stencil_val_o(h.x,0,0,0); 
_stencil_val_o(h.x,0,0,0);      

}}    







}
#line 109 "/home/pwachara/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) { 
_stencil_val_o(c,i*j,0,0); _stencil_val_o(cs.x,(i - 2)*j,0,0); 
           
  
 
       
         
  
 
        







     
   
  
   
        
        
           
        




             
#line 138 "/home/pwachara/basilisk/src/heights.h"
              
              
#line 156 "/home/pwachara/basilisk/src/heights.h"
      
         
    }





    if (j == -1) {







_stencil_val_o(c,0,0,0); _stencil_val_o(c,0,0,0);{
 
{_stencil_val_a(h.x,0,0,0);  }
{
 {_stencil_val_a(h.x,0,0,0);  }





 
{_stencil_val_a(h.x,0,0,0);        }}      }    
}
    else {
#line 203
{
 {_stencil_val_a(h.x,0,0,0);  }
 
{_stencil_val_a(h.x,0,0,0);        }}
      
#line 195 "/home/pwachara/basilisk/src/heights.h"
                
   





         
      
    


}
  } 
#line 59
{      







     _stencil_val_o(c,0,0,0);            







    
    
    if (j == 1) {




_stencil_val_o(h.y,0,0,0);{ 
      




{     
 _stencil_val_o(h.y,0,0,0); 
_stencil_val_o(h.y,0,0,0);      

}}    







}
#line 109 "/home/pwachara/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) { 
_stencil_val_o(c,0,i*j,0); _stencil_val_o(cs.y,0,(i - 2)*j,0); 
           
  
 
       
         
  
 
        







     
   
  
   
        
        
           
        




             
#line 138 "/home/pwachara/basilisk/src/heights.h"
              
              
#line 156 "/home/pwachara/basilisk/src/heights.h"
      
         
    }





    if (j == -1) {







_stencil_val_o(c,0,0,0); _stencil_val_o(c,0,0,0);{
 
{_stencil_val_a(h.y,0,0,0);  }
{
 {_stencil_val_a(h.y,0,0,0);  }





 
{_stencil_val_a(h.y,0,0,0);        }}      }    
}
    else {
#line 203
{
 {_stencil_val_a(h.y,0,0,0);  }
 
{_stencil_val_a(h.y,0,0,0);        }}
      
#line 195 "/home/pwachara/basilisk/src/heights.h"
                
   





         
      
    


}
  } 
#line 59
{      







     _stencil_val_o(c,0,0,0);            







    
    
    if (j == 1) {




_stencil_val_o(h.z,0,0,0);{ 
      




{     
 _stencil_val_o(h.z,0,0,0); 
_stencil_val_o(h.z,0,0,0);      

}}    







}
#line 109 "/home/pwachara/basilisk/src/heights.h"
    for (int i = 1; i <= 4; i++) { 
_stencil_val_o(c,0,0,i*j); _stencil_val_o(cs.z,0,0,(i - 2)*j); 
           
  
 
       
         
  
 
        







     
   
  
   
        
        
           
        




             
#line 138 "/home/pwachara/basilisk/src/heights.h"
              
              
#line 156 "/home/pwachara/basilisk/src/heights.h"
      
         
    }





    if (j == -1) {







_stencil_val_o(c,0,0,0); _stencil_val_o(c,0,0,0);{
 
{_stencil_val_a(h.z,0,0,0);  }
{
 {_stencil_val_a(h.z,0,0,0);  }





 
{_stencil_val_a(h.z,0,0,0);        }}      }    
}
    else {
#line 203
{
 {_stencil_val_a(h.z,0,0,0);  }
 
{_stencil_val_a(h.z,0,0,0);        }}
      
#line 195 "/home/pwachara/basilisk/src/heights.h"
                
   





         
      
    


}
  }
}
#line 222 "/home/pwachara/basilisk/src/heights.h"
static void column_propagation (vector h)
{
  



  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/heights.h", .line = 227, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 229 "/home/pwachara/basilisk/src/heights.h"
for (int i = -2; i <= 2; i++)
      {
 {_stencil_val(h.x,i,0,0);
_stencil_val(h.x,i,0,0);_stencil_val(h.x,0,0,0);
   { _stencil_val(h.x,i,0,0);_stencil_val_a(h.x,0,0,0);   }       } 
#line 231
{_stencil_val(h.y,0,i,0);
_stencil_val(h.y,0,i,0);_stencil_val(h.y,0,0,0);
   { _stencil_val(h.y,0,i,0);_stencil_val_a(h.y,0,0,0);   }       } 
#line 231
{_stencil_val(h.z,0,0,i);
_stencil_val(h.z,0,0,i);_stencil_val(h.z,0,0,0);
   { _stencil_val(h.z,0,0,i);_stencil_val_a(h.z,0,0,0);   }       }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 229 "/home/pwachara/basilisk/src/heights.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 229 "/home/pwachara/basilisk/src/heights.h"
for (int i = -2; i <= 2; i++)
      {
 if (fabs(height(val(h.x,i,0,0))) <= 3.5 &&
     fabs(height(val(h.x,i,0,0)) + i) < fabs(height(val(h.x,0,0,0))))
   val(h.x,0,0,0) = val(h.x,i,0,0) + i; 
#line 231
if (fabs(height(val(h.y,0,i,0))) <= 3.5 &&
     fabs(height(val(h.y,0,i,0)) + i) < fabs(height(val(h.y,0,0,0))))
   val(h.y,0,0,0) = val(h.y,0,i,0) + i; 
#line 231
if (fabs(height(val(h.z,0,0,i))) <= 3.5 &&
     fabs(height(val(h.z,0,0,i)) + i) < fabs(height(val(h.z,0,0,0))))
   val(h.z,0,0,0) = val(h.z,0,0,i) + i;}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 234 "/home/pwachara/basilisk/src/heights.h"
}
#line 243 "/home/pwachara/basilisk/src/heights.h"
     
void heights (scalar c, vector h)
{tracing("heights","/home/pwachara/basilisk/src/heights.h",244);







  vector  s=new_vector("s");
  
    for (int i = 0; i < nboundary; i++)
      _attribute[s.x.i].boundary[i] = _attribute[c.i].boundary[i];    
#line 255
for (int i = 0; i < nboundary; i++)
      _attribute[s.y.i].boundary[i] = _attribute[c.i].boundary[i];    
#line 255
for (int i = 0; i < nboundary; i++)
      _attribute[s.z.i].boundary[i] = _attribute[c.i].boundary[i];






  for (int j = -1; j <= 1; j += 2) {
  





    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/heights.h", .line = 269, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);      
#line 270 "/home/pwachara/basilisk/src/heights.h"
{
        { _stencil_val(c,2*j,0,0);_stencil_val_a(s.x,0,0,0); }        { _stencil_val(c,0,2*j,0);_stencil_val_a(s.y,0,0,0); }        { _stencil_val(c,0,0,2*j);_stencil_val_a(s.z,0,0,0); }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)      
#line 270 "/home/pwachara/basilisk/src/heights.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 270 "/home/pwachara/basilisk/src/heights.h"
{
        val(s.x,0,0,0) = val(c,2*j,0,0);        val(s.y,0,0,0) = val(c,0,2*j,0);        val(s.z,0,0,0) = val(c,0,0,2*j);}}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
  





    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/heights.h", .line = 277, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);      
#line 278 "/home/pwachara/basilisk/src/heights.h"
_stencil_half_column (point, c, h, s, j);

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)      
#line 278 "/home/pwachara/basilisk/src/heights.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 278 "/home/pwachara/basilisk/src/heights.h"
half_column (point, c, h, s, j);}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 279 "/home/pwachara/basilisk/src/heights.h"
}




  column_propagation (h);delete((scalar*)((vector[]){s,{{-1},{-1},{-1}}}));
end_tracing("heights","/home/pwachara/basilisk/src/heights.h",285);}
#line 459 "/home/pwachara/basilisk/src/heights.h"

#line 69 "/home/pwachara/basilisk/src/curvature.h"
#line 106 "/home/pwachara/basilisk/src/curvature.h"

static double kappa_z (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 109 "/home/pwachara/basilisk/src/curvature.h"
int ori = orientation(val(h.z,0,0,0));
  for (int i = -1; i <= 1; i++)
    for (int j = -1; j <= 1; j++)
      if (val(h.z,i,j,0) == 1e30f || orientation(val(h.z,i,j,0)) != ori)
 return 1e30f;
  double hx = (val(h.z,1,0,0) - val(h.z,-1,0,0))/2.;
  double hy = (val(h.z,0,1,0) - val(h.z,0,-1,0))/2.;







  double filter = 0.2;
  double hxx = (filter*(val(h.z,1,1,0) + val(h.z,-1,1,0) - 2.*val(h.z,0,1,0)) +
  (val(h.z,1,0,0) + val(h.z,-1,0,0) - 2.*val(h.z,0,0,0)) +
  filter*(val(h.z,1,-1,0) + val(h.z,-1,-1,0) - 2.*val(h.z,0,-1,0)))/
    ((1. + 2.*filter)*Delta);
  double hyy = (filter*(val(h.z,1,1,0) + val(h.z,1,-1,0) - 2.*val(h.z,1,0,0)) +
  (val(h.z,0,1,0) + val(h.z,0,-1,0) - 2.*val(h.z,0,0,0)) +
  filter*(val(h.z,-1,1,0) + val(h.z,-1,-1,0) - 2.*val(h.z,-1,0,0)))/
    ((1. + 2.*filter)*Delta);
  double hxy = (val(h.z,1,1,0) + val(h.z,-1,-1,0) - val(h.z,1,-1,0) - val(h.z,-1,1,0))/(4.*Delta);
  return (hxx*(1. + ( hy*hy)) + hyy*(1. + ( hx*hx)) - 2.*hxy*hx*hy)/
    pow(1. + ( hx*hx) + ( hy*hy), 3/2.);
}
#line 107
static double kappa_x (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 109 "/home/pwachara/basilisk/src/curvature.h"
int ori = orientation(val(h.x,0,0,0));
  for (int i = -1; i <= 1; i++)
    for (int j = -1; j <= 1; j++)
      if (val(h.x,0,i,j) == 1e30f || orientation(val(h.x,0,i,j)) != ori)
 return 1e30f;
  double hx = (val(h.x,0,1,0) - val(h.x,0,-1,0))/2.;
  double hy = (val(h.x,0,0,1) - val(h.x,0,0,-1))/2.;







  double filter = 0.2;
  double hxx = (filter*(val(h.x,0,1,1) + val(h.x,0,-1,1) - 2.*val(h.x,0,0,1)) +
  (val(h.x,0,1,0) + val(h.x,0,-1,0) - 2.*val(h.x,0,0,0)) +
  filter*(val(h.x,0,1,-1) + val(h.x,0,-1,-1) - 2.*val(h.x,0,0,-1)))/
    ((1. + 2.*filter)*Delta);
  double hyy = (filter*(val(h.x,0,1,1) + val(h.x,0,1,-1) - 2.*val(h.x,0,1,0)) +
  (val(h.x,0,0,1) + val(h.x,0,0,-1) - 2.*val(h.x,0,0,0)) +
  filter*(val(h.x,0,-1,1) + val(h.x,0,-1,-1) - 2.*val(h.x,0,-1,0)))/
    ((1. + 2.*filter)*Delta);
  double hxy = (val(h.x,0,1,1) + val(h.x,0,-1,-1) - val(h.x,0,1,-1) - val(h.x,0,-1,1))/(4.*Delta);
  return (hxx*(1. + ( hy*hy)) + hyy*(1. + ( hx*hx)) - 2.*hxy*hx*hy)/
    pow(1. + ( hx*hx) + ( hy*hy), 3/2.);
}
#line 107
static double kappa_y (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 109 "/home/pwachara/basilisk/src/curvature.h"
int ori = orientation(val(h.y,0,0,0));
  for (int i = -1; i <= 1; i++)
    for (int j = -1; j <= 1; j++)
      if (val(h.y,j,0,i) == 1e30f || orientation(val(h.y,j,0,i)) != ori)
 return 1e30f;
  double hx = (val(h.y,0,0,1) - val(h.y,0,0,-1))/2.;
  double hy = (val(h.y,1,0,0) - val(h.y,-1,0,0))/2.;







  double filter = 0.2;
  double hxx = (filter*(val(h.y,1,0,1) + val(h.y,1,0,-1) - 2.*val(h.y,1,0,0)) +
  (val(h.y,0,0,1) + val(h.y,0,0,-1) - 2.*val(h.y,0,0,0)) +
  filter*(val(h.y,-1,0,1) + val(h.y,-1,0,-1) - 2.*val(h.y,-1,0,0)))/
    ((1. + 2.*filter)*Delta);
  double hyy = (filter*(val(h.y,1,0,1) + val(h.y,-1,0,1) - 2.*val(h.y,0,0,1)) +
  (val(h.y,1,0,0) + val(h.y,-1,0,0) - 2.*val(h.y,0,0,0)) +
  filter*(val(h.y,1,0,-1) + val(h.y,-1,0,-1) - 2.*val(h.y,0,0,-1)))/
    ((1. + 2.*filter)*Delta);
  double hxy = (val(h.y,1,0,1) + val(h.y,-1,0,-1) - val(h.y,-1,0,1) - val(h.y,1,0,-1))/(4.*Delta);
  return (hxx*(1. + ( hy*hy)) + hyy*(1. + ( hx*hx)) - 2.*hxy*hx*hy)/
    pow(1. + ( hx*hx) + ( hy*hy), 3/2.);
}


static coord normal2_z (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 140 "/home/pwachara/basilisk/src/curvature.h"
scalar hz = h.z;
  if (val(hz,0,0,0) == 1e30f)
    return (coord){1e30f, 1e30f, 1e30f};
  int ori = orientation(val(hz,0,0,0));
  double a = ori ? -1. : 1.;
  coord n;
  n.z = a;
   {
    if (allocated(-1,0,0) && val(hz,-1,0,0) != 1e30f && orientation(val(hz,-1,0,0)) == ori) {
      if (allocated(1,0,0) && val(hz,1,0,0) != 1e30f && orientation(val(hz,1,0,0)) == ori)
 n.x = a*(val(hz,-1,0,0) - val(hz,1,0,0))/2.;
      else
 n.x = a*(val(hz,-1,0,0) - val(hz,0,0,0));
    }
    else if (allocated(1,0,0) && val(hz,1,0,0) != 1e30f && orientation(val(hz,1,0,0)) == ori)
      n.x = a*(val(hz,0,0,0) - val(hz,1,0,0));
    else
      n.x = 1e30f;
  } 
#line 147
{
    if (allocated(0,-1,0) && val(hz,0,-1,0) != 1e30f && orientation(val(hz,0,-1,0)) == ori) {
      if (allocated(0,1,0) && val(hz,0,1,0) != 1e30f && orientation(val(hz,0,1,0)) == ori)
 n.y = a*(val(hz,0,-1,0) - val(hz,0,1,0))/2.;
      else
 n.y = a*(val(hz,0,-1,0) - val(hz,0,0,0));
    }
    else if (allocated(0,1,0) && val(hz,0,1,0) != 1e30f && orientation(val(hz,0,1,0)) == ori)
      n.y = a*(val(hz,0,0,0) - val(hz,0,1,0));
    else
      n.y = 1e30f;
  }
  return n;
}
#line 138
static coord normal2_x (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 140 "/home/pwachara/basilisk/src/curvature.h"
scalar hz = h.x;
  if (val(hz,0,0,0) == 1e30f)
    return (coord){1e30f, 1e30f, 1e30f};
  int ori = orientation(val(hz,0,0,0));
  double a = ori ? -1. : 1.;
  coord n;
  n.x = a;
   {
    if (allocated(0,-1,0) && val(hz,0,-1,0) != 1e30f && orientation(val(hz,0,-1,0)) == ori) {
      if (allocated(0,1,0) && val(hz,0,1,0) != 1e30f && orientation(val(hz,0,1,0)) == ori)
 n.y = a*(val(hz,0,-1,0) - val(hz,0,1,0))/2.;
      else
 n.y = a*(val(hz,0,-1,0) - val(hz,0,0,0));
    }
    else if (allocated(0,1,0) && val(hz,0,1,0) != 1e30f && orientation(val(hz,0,1,0)) == ori)
      n.y = a*(val(hz,0,0,0) - val(hz,0,1,0));
    else
      n.y = 1e30f;
  } 
#line 147
{
    if (allocated(0,0,-1) && val(hz,0,0,-1) != 1e30f && orientation(val(hz,0,0,-1)) == ori) {
      if (allocated(0,0,1) && val(hz,0,0,1) != 1e30f && orientation(val(hz,0,0,1)) == ori)
 n.z = a*(val(hz,0,0,-1) - val(hz,0,0,1))/2.;
      else
 n.z = a*(val(hz,0,0,-1) - val(hz,0,0,0));
    }
    else if (allocated(0,0,1) && val(hz,0,0,1) != 1e30f && orientation(val(hz,0,0,1)) == ori)
      n.z = a*(val(hz,0,0,0) - val(hz,0,0,1));
    else
      n.z = 1e30f;
  }
  return n;
}
#line 138
static coord normal2_y (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 140 "/home/pwachara/basilisk/src/curvature.h"
scalar hz = h.y;
  if (val(hz,0,0,0) == 1e30f)
    return (coord){1e30f, 1e30f, 1e30f};
  int ori = orientation(val(hz,0,0,0));
  double a = ori ? -1. : 1.;
  coord n;
  n.y = a;
   {
    if (allocated(0,0,-1) && val(hz,0,0,-1) != 1e30f && orientation(val(hz,0,0,-1)) == ori) {
      if (allocated(0,0,1) && val(hz,0,0,1) != 1e30f && orientation(val(hz,0,0,1)) == ori)
 n.z = a*(val(hz,0,0,-1) - val(hz,0,0,1))/2.;
      else
 n.z = a*(val(hz,0,0,-1) - val(hz,0,0,0));
    }
    else if (allocated(0,0,1) && val(hz,0,0,1) != 1e30f && orientation(val(hz,0,0,1)) == ori)
      n.z = a*(val(hz,0,0,0) - val(hz,0,0,1));
    else
      n.z = 1e30f;
  } 
#line 147
{
    if (allocated(-1,0,0) && val(hz,-1,0,0) != 1e30f && orientation(val(hz,-1,0,0)) == ori) {
      if (allocated(1,0,0) && val(hz,1,0,0) != 1e30f && orientation(val(hz,1,0,0)) == ori)
 n.x = a*(val(hz,-1,0,0) - val(hz,1,0,0))/2.;
      else
 n.x = a*(val(hz,-1,0,0) - val(hz,0,0,0));
    }
    else if (allocated(1,0,0) && val(hz,1,0,0) != 1e30f && orientation(val(hz,1,0,0)) == ori)
      n.x = a*(val(hz,0,0,0) - val(hz,1,0,0));
    else
      n.x = 1e30f;
  }
  return n;
}


static coord normal_z (Point point, vector h) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 164 "/home/pwachara/basilisk/src/curvature.h"
coord n = normal2_z (point, h);
  double nn = fabs(n.x) + fabs(n.y) + fabs(n.z);
  if (nn < 1e30f) {
    
      n.x /= nn;      n.y /= nn;      n.z /= nn;
    return n;
  }
  return (coord){1e30f, 1e30f, 1e30f};
}
#line 163
static coord normal_x (Point point, vector h) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 164 "/home/pwachara/basilisk/src/curvature.h"
coord n = normal2_x (point, h);
  double nn = fabs(n.y) + fabs(n.z) + fabs(n.x);
  if (nn < 1e30f) {
    
      n.y /= nn;      n.z /= nn;      n.x /= nn;
    return n;
  }
  return (coord){1e30f, 1e30f, 1e30f};
}
#line 163
static coord normal_y (Point point, vector h) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 164 "/home/pwachara/basilisk/src/curvature.h"
coord n = normal2_y (point, h);
  double nn = fabs(n.z) + fabs(n.x) + fabs(n.y);
  if (nn < 1e30f) {
    
      n.z /= nn;      n.x /= nn;      n.y /= nn;
    return n;
  }
  return (coord){1e30f, 1e30f, 1e30f};
}
#line 181 "/home/pwachara/basilisk/src/curvature.h"
static double height_curvature (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;  
#line 189 "/home/pwachara/basilisk/src/curvature.h"
typedef struct {
    double n;
    double (* kappa) (Point, vector);
  } NormKappa;
  struct { NormKappa x, y, z; } n;
  
    n.x.n = val(c,1,0,0) - val(c,-1,0,0), n.x.kappa = kappa_x;    n.y.n = val(c,0,1,0) - val(c,0,-1,0), n.y.kappa = kappa_y;    n.z.n = val(c,0,0,1) - val(c,0,0,-1), n.z.kappa = kappa_z;
  double (* kappaf) (Point, vector) = NULL; NOT_UNUSED (kappaf);




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormKappa _tmp_ = n.x; n.x = n.y; n.y = _tmp_; } while(false);

  if (fabs(n.x.n) < fabs(n.z.n))
    do { NormKappa _tmp_ = n.x; n.x = n.z; n.z = _tmp_; } while(false);
  if (fabs(n.y.n) < fabs(n.z.n))
    do { NormKappa _tmp_ = n.y; n.y = n.z; n.z = _tmp_; } while(false);





  double kappa = 1e30f;
  
    if (kappa == 1e30f) {
      kappa = n.x.kappa (point, h);
      if (kappa != 1e30f) {
 kappaf = n.x.kappa;
 if (n.x.n < 0.)
   kappa = - kappa;
      }
    }    
#line 215
if (kappa == 1e30f) {
      kappa = n.y.kappa (point, h);
      if (kappa != 1e30f) {
 kappaf = n.y.kappa;
 if (n.y.n < 0.)
   kappa = - kappa;
      }
    }    
#line 215
if (kappa == 1e30f) {
      kappa = n.z.kappa (point, h);
      if (kappa != 1e30f) {
 kappaf = n.z.kappa;
 if (n.z.n < 0.)
   kappa = - kappa;
      }
    }

  if (kappa != 1e30f) {




    if (fabs(kappa) > 1./Delta)
      kappa = ( (int)(kappa > 0 ? 1 : -1))/Delta;
#line 249 "/home/pwachara/basilisk/src/curvature.h"
  }

  return kappa;
}
#line 181 "/home/pwachara/basilisk/src/curvature.h"
static void _stencil_height_curvature (Point point, scalar c,_stencil_undefined * h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;    
#line 195 "/home/pwachara/basilisk/src/curvature.h"
{ _stencil_val(c,1,0,0); _stencil_val(c,-1,0,0);     }    { _stencil_val(c,0,1,0); _stencil_val(c,0,-1,0);     }    { _stencil_val(c,0,0,1); _stencil_val(c,0,0,-1);     }                                                
  
    
    
      




     

     
     





     
     
           
      
          
  
 
      
       
     

  
               




       
#line 249 "/home/pwachara/basilisk/src/curvature.h"
   

  return ;
}






coord height_normal (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;






  
#line 267 "/home/pwachara/basilisk/src/curvature.h"
typedef struct {
    double n;
    coord (* normal) (Point, vector);
  } NormNormal;
  struct { NormNormal x, y, z; } n;
  
    n.x.n = val(c,1,0,0) - val(c,-1,0,0), n.x.normal = normal_x;    n.y.n = val(c,0,1,0) - val(c,0,-1,0), n.y.normal = normal_y;    n.z.n = val(c,0,0,1) - val(c,0,0,-1), n.z.normal = normal_z;




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormNormal _tmp_ = n.x; n.x = n.y; n.y = _tmp_; } while(false);

  if (fabs(n.x.n) < fabs(n.z.n))
    do { NormNormal _tmp_ = n.x; n.x = n.z; n.z = _tmp_; } while(false);
  if (fabs(n.y.n) < fabs(n.z.n))
    do { NormNormal _tmp_ = n.y; n.y = n.z; n.z = _tmp_; } while(false);





  coord normal = {1e30f, 1e30f, 1e30f};
  
    if (normal.x == 1e30f)
      normal = n.x.normal (point, h);    
#line 292
if (normal.y == 1e30f)
      normal = n.y.normal (point, h);    
#line 292
if (normal.z == 1e30f)
      normal = n.z.normal (point, h);

  return normal;
}







coord height_normal_z (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 306 "/home/pwachara/basilisk/src/curvature.h"
coord nx = normal2_x (point, h);
  coord ny = normal2_y (point, h);
  if (fabs(nx.y) < fabs(ny.x)) {
    normalize (&nx);
    return nx;
  }
  else if (ny.x != 1e30f) {
    normalize (&ny);
    return ny;
  }
  return (coord){1e30f, 1e30f, 1e30f};
}
#line 304
coord height_normal_x (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 306 "/home/pwachara/basilisk/src/curvature.h"
coord nx = normal2_y (point, h);
  coord ny = normal2_z (point, h);
  if (fabs(nx.z) < fabs(ny.y)) {
    normalize (&nx);
    return nx;
  }
  else if (ny.y != 1e30f) {
    normalize (&ny);
    return ny;
  }
  return (coord){1e30f, 1e30f, 1e30f};
}
#line 304
coord height_normal_y (Point point, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 306 "/home/pwachara/basilisk/src/curvature.h"
coord nx = normal2_z (point, h);
  coord ny = normal2_x (point, h);
  if (fabs(nx.x) < fabs(ny.z)) {
    normalize (&nx);
    return nx;
  }
  else if (ny.z != 1e30f) {
    normalize (&ny);
    return ny;
  }
  return (coord){1e30f, 1e30f, 1e30f};
}
#line 332 "/home/pwachara/basilisk/src/curvature.h"
#line 1 "parabola.h"
#line 1 "/home/pwachara/basilisk/src/parabola.h"
#line 1 "utils.h"
#line 2 "/home/pwachara/basilisk/src/parabola.h"






typedef struct {
  coord o;




  double t[3][3];



  double ** M, rhs[6], a[6];


} ParabolaFit;

static void parabola_fit_init (ParabolaFit * p, coord o, coord m)
{
  
    p->o.x = o.x;    p->o.y = o.y;    p->o.z = o.z;






  double max;
  coord nx = {0., 0., 0.}, ny, nz;
  int d = 0;

  
    nz.x = m.x;    nz.y = m.y;    nz.z = m.z;
  normalize (&nz);
  max = ( (nz.x)*(nz.x));

  if (( (nz.y)*(nz.y)) > max) { max = ( (nz.y)*(nz.y)); d = 1; }
  if (( (nz.z)*(nz.z)) > max) d = 2;
  switch (d) {
  case 0: nx.x = - nz.z/nz.x; nx.z = 1.0; break;
  case 1: nx.y = - nz.z/nz.y; nx.z = 1.0; break;
  case 2: nx.z = - nz.x/nz.z; nx.x = 1.0; break;
  }
  normalize (&nx);


  
    ny.x = nz.y*nx.z - nz.z*nx.y;    ny.y = nz.z*nx.x - nz.x*nx.z;    ny.z = nz.x*nx.y - nz.y*nx.x;


  p->t[0][0] = nx.x; p->t[0][1] = nx.y; p->t[0][2] = nx.z;
  p->t[1][0] = ny.x; p->t[1][1] = ny.y; p->t[1][2] = ny.z;
  p->t[2][0] = nz.x; p->t[2][1] = nz.y; p->t[2][2] = nz.z;



  int n = 6;


  p->M = (double **) matrix_new (n, n, sizeof(double));
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++)
      p->M[i][j] = 0.;
    p->rhs[i] = 0.;
  }
}

static void parabola_fit_add (ParabolaFit * p, coord m, double w)
{
#line 85 "/home/pwachara/basilisk/src/parabola.h"
  double x1 = m.x - p->o.x, y1 = m.y - p->o.y, z1 = m.z - p->o.z;
  double x = p->t[0][0]*x1 + p->t[0][1]*y1 + p->t[0][2]*z1;
  double y = p->t[1][0]*x1 + p->t[1][1]*y1 + p->t[1][2]*z1;
  double z = p->t[2][0]*x1 + p->t[2][1]*y1 + p->t[2][2]*z1;
#line 98 "/home/pwachara/basilisk/src/parabola.h"
  double x2 = x*x, x3 = x2*x, x4 = x3*x;
  double y2 = y*y, y3 = y2*y, y4 = y3*y;
  p->M[0][0] += w*x4; p->M[1][1] += w*y4; p->M[2][2] += w*x2*y2;
  p->M[3][3] += w*x2; p->M[4][4] += w*y2; p->M[5][5] += w;
  p->M[0][2] += w*x3*y; p->M[0][3] += w*x3; p->M[0][4] += w*x2*y;
  p->M[1][2] += w*x*y3; p->M[1][3] += w*x*y2; p->M[1][4] += w*y3;
  p->M[2][5] += w*x*y;
  p->M[3][5] += w*x;
  p->M[4][5] += w*y;
  p->rhs[0] += w*x2*z; p->rhs[1] += w*y2*z; p->rhs[2] += w*x*y*z;
  p->rhs[3] += w*x*z; p->rhs[4] += w*y*z; p->rhs[5] += w*z;


}

static double parabola_fit_solve (ParabolaFit * p)
{
#line 139 "/home/pwachara/basilisk/src/parabola.h"
  p->M[0][1] = p->M[2][2]; p->M[0][5] = p->M[3][3];
  p->M[1][5] = p->M[4][4];
  p->M[2][3] = p->M[0][4]; p->M[2][4] = p->M[1][3];
  p->M[3][4] = p->M[2][5];
  for (int i = 1; i < 6; i++)
    for (int j = 0; j < i; j++)
      p->M[i][j] = p->M[j][i];
  double pivmin = matrix_inverse (p->M, 6, 1e-10);
  if (pivmin)
    for (int i = 0; i < 6; i++) {
      p->a[i] = 0.;
      for (int j = 0; j < 6; j++)
 p->a[i] += p->M[i][j]*p->rhs[j];
    }
  else
    for (int i = 0; i < 6; i++)
      p->a[i] = 0.;


  matrix_free (p->M);
  return pivmin;
}

static double parabola_fit_curvature (ParabolaFit * p,
          double kappamax, double * kmax)
{
  double kappa;
#line 176 "/home/pwachara/basilisk/src/parabola.h"
  double hxx = 2.*p->a[0], hyy = 2.*p->a[1], hxy = p->a[2];
  double hx = p->a[3], hy = p->a[4];

  double dnm = 1. + ( hx*hx) + ( hy*hy);
  kappa = - (hxx*(1. + ( hy*hy)) + hyy*(1. + ( hx*hx)) - 2.*hxy*hx*hy)
    /sqrt (dnm*dnm*dnm);
  if (kmax) {
    double kg = (hxx*hyy - hxy*hxy)/(dnm*dnm);
    double a = kappa*kappa/4. - kg;
    *kmax = fabs (kappa/2.);
    if (a >= 0.)
      *kmax += sqrt (a);
  }

  if (fabs (kappa) > kappamax) {
    if (kmax)
      *kmax = kappamax;
    return kappa > 0. ? kappamax : - kappamax;
  }
  return kappa;
}
#line 333 "/home/pwachara/basilisk/src/curvature.h"






static int independents (coord * p, int n)
{
  if (n < 2)
    return n;
  int ni = 1;
  for (int j = 1; j < n; j++) {
    bool depends = false;
    for (int i = 0; i < j && !depends; i++) {
      double d2 = 0.;
      
 d2 += ( (p[i].x - p[j].x)*(p[i].x - p[j].x)); d2 += ( (p[i].y - p[j].y)*(p[i].y - p[j].y)); d2 += ( (p[i].z - p[j].z)*(p[i].z - p[j].z));
      depends = (d2 < ( 0.5*0.5));
    }
    ni += !depends;
  }
  return ni;
}






static double height_curvature_fit (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;





  
#line 369 "/home/pwachara/basilisk/src/curvature.h"
coord ip[3 == 2 ? 6 : 27];
  int n = 0;




   {





    int n1 = 0, n2 = 0;






    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (val(h.z,i,j,0) != 1e30f) {
   if (orientation(val(h.z,i,j,0))) n1++; else n2++;
 }

    int ori = (n1 > n2);
#line 406 "/home/pwachara/basilisk/src/curvature.h"
    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (val(h.z,i,j,0) != 1e30f && orientation(val(h.z,i,j,0)) == ori)
   ip[n].x = i, ip[n].y = j, ip[n++].z = height(val(h.z,i,j,0));

  } 
#line 375
{





    int n1 = 0, n2 = 0;






    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (val(h.x,0,i,j) != 1e30f) {
   if (orientation(val(h.x,0,i,j))) n1++; else n2++;
 }

    int ori = (n1 > n2);
#line 406 "/home/pwachara/basilisk/src/curvature.h"
    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (val(h.x,0,i,j) != 1e30f && orientation(val(h.x,0,i,j)) == ori)
   ip[n].y = i, ip[n].z = j, ip[n++].x = height(val(h.x,0,i,j));

  } 
#line 375
{





    int n1 = 0, n2 = 0;






    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (val(h.y,j,0,i) != 1e30f) {
   if (orientation(val(h.y,j,0,i))) n1++; else n2++;
 }

    int ori = (n1 > n2);
#line 406 "/home/pwachara/basilisk/src/curvature.h"
    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (val(h.y,j,0,i) != 1e30f && orientation(val(h.y,j,0,i)) == ori)
   ip[n].z = i, ip[n].x = j, ip[n++].y = height(val(h.y,j,0,i));

  }





  if (independents (ip, n) < (3 == 2 ? 3 : 9))
    return 1e30f;





  coord m = mycs (point, c), fc;
  double alpha = plane_alpha (val(c,0,0,0), m);
  double area = plane_area_center (m, alpha, &fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);




  parabola_fit_add (&fit, fc, area*100.);






  for (int i = 0; i < n; i++)
    parabola_fit_add (&fit, ip[i], 1.);
  parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., NULL)/Delta;



  return kappa;
}
#line 362
static void _stencil_height_curvature_fit (Point point, scalar c, vector h)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;          





  
  




   
#line 375 "/home/pwachara/basilisk/src/curvature.h"
{      





    






    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 {_stencil_val(h.z,i,j,0); {
_stencil_val(h.z,i,j,0); 
}   }     

    
#line 406 "/home/pwachara/basilisk/src/curvature.h"
    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 {_stencil_val(h.z,i,j,0);_stencil_val(h.z,i,j,0);
   {_stencil_val(h.z,i,j,0);        }       }

  } 
#line 375
{      





    






    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 {_stencil_val(h.x,0,i,j); {
_stencil_val(h.x,0,i,j); 
}   }     

    
#line 406 "/home/pwachara/basilisk/src/curvature.h"
    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 {_stencil_val(h.x,0,i,j);_stencil_val(h.x,0,i,j);
   {_stencil_val(h.x,0,i,j);        }       }

  } 
#line 375
{      





    






    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 {_stencil_val(h.y,j,0,i); {
_stencil_val(h.y,j,0,i); 
}   }     

    
#line 406 "/home/pwachara/basilisk/src/curvature.h"
    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 {_stencil_val(h.y,j,0,i);_stencil_val(h.y,j,0,i);
   {_stencil_val(h.y,j,0,i);        }       }

  }    
    





             





   _stencil_mycs (point, c);     
  _stencil_val(c,0,0,0);             
  
                 
  




  






     
    
  
  



  return ;
}






static double centroids_curvature_fit (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;





  
#line 462 "/home/pwachara/basilisk/src/curvature.h"
coord m = mycs (point, c), fc;
  double alpha = plane_alpha (val(c,0,0,0), m);
  plane_area_center (m, alpha, &fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);





  coord r = {x,y,z};  
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
    
#line 474 "/home/pwachara/basilisk/src/curvature.h"
if (val(c,0,0,0) > 0. && val(c,0,0,0) < 1.) {
      coord m = mycs (point, c), fc;
      double alpha = plane_alpha (val(c,0,0,0), m);
      double area = plane_area_center (m, alpha, &fc);
      coord rn = {x,y,z};
      
 fc.x += (rn.x - r.x)/Delta; fc.y += (rn.y - r.y)/Delta; fc.z += (rn.z - r.z)/Delta;
      parabola_fit_add (&fit, fc, area);
    } 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
  
#line 483 "/home/pwachara/basilisk/src/curvature.h"
parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., NULL)/Delta;



  return kappa;
}
#line 455
static void _stencil_centroids_curvature_fit (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   





   
#line 462 "/home/pwachara/basilisk/src/curvature.h"
_stencil_mycs (point, c);     
  _stencil_val(c,0,0,0);  
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
    
#line 474 "/home/pwachara/basilisk/src/curvature.h"
{_stencil_val(c,0,0,0); _stencil_val(c,0,0,0); {   
       _stencil_mycs (point, c);     
      _stencil_val(c,0,0,0);         
      
      
       
       
      
    }      } 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }       
  
  



  
#line 488 "/home/pwachara/basilisk/src/curvature.h"
return ;
}
#line 504 "/home/pwachara/basilisk/src/curvature.h"
static inline bool interfacial (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 506 "/home/pwachara/basilisk/src/curvature.h"
if (val(c,0,0,0) >= 1.) {
    for (int i = -1; i <= 1; i += 2)
      {
 if (val(c,i,0,0) <= 0.)
   return true; 
#line 509
if (val(c,0,i,0) <= 0.)
   return true; 
#line 509
if (val(c,0,0,i) <= 0.)
   return true;}
  }
  else if (val(c,0,0,0) <= 0.) {
    for (int i = -1; i <= 1; i += 2)
      {
 if (val(c,i,0,0) >= 1.)
   return true; 
#line 515
if (val(c,0,i,0) >= 1.)
   return true; 
#line 515
if (val(c,0,0,i) >= 1.)
   return true;}
  }
  else
    return true;
  return false;
}
#line 504 "/home/pwachara/basilisk/src/curvature.h"
static void _stencil_interfacial (Point point, scalar c)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 506 "/home/pwachara/basilisk/src/curvature.h"
_stencil_val(c,0,0,0);{ {
    for (int i = -1; i <= 1; i += 2)
      {
 {_stencil_val(c,i,0,0); 
      } 
#line 509
{_stencil_val(c,0,i,0); 
      } 
#line 509
{_stencil_val(c,0,0,i); 
      }}
  } 
{_stencil_val(c,0,0,0);{ {
    for (int i = -1; i <= 1; i += 2)
      {
 {_stencil_val(c,i,0,0); 
      } 
#line 515
{_stencil_val(c,0,i,0); 
      } 
#line 515
{_stencil_val(c,0,0,i); 
      }}
  } 
    
}  }}  
return ;
}
#line 533 "/home/pwachara/basilisk/src/curvature.h"
typedef struct {
  int h;
  int f;
  int a;
  int c;
} cstats;

     
cstats curvature (scalar c, scalar kappa,
    double sigma, bool add)
{tracing("curvature","/home/pwachara/basilisk/src/curvature.h",541);
  int sh = 0, f = 0, sa = 0, sc = 0;
#line 557 "/home/pwachara/basilisk/src/curvature.h"
  vector ch = _attribute[c.i].height,   h=(ch).x.i>0?(ch):new_vector("h");
  if (!ch.x.i)
    heights (c, h);





  scalar  k=new_scalar("k");
  scalar_clone (k, kappa);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/curvature.h", .line = 568, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 568 "/home/pwachara/basilisk/src/curvature.h"
{




_stencil_interfacial (point, c);{
      {_stencil_val_a(k,0,0,0);  } 





{ _stencil_height_curvature (point, c, NULL);_stencil_val_a(k,0,0,0);{
       
{ _stencil_height_curvature_fit (point, c, h);_stencil_val_a(k,0,0,0);
          }}    }}  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:sh) reduction(+:f)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 568 "/home/pwachara/basilisk/src/curvature.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 568 "/home/pwachara/basilisk/src/curvature.h"
{




    if (!interfacial (point, c))
      val(k,0,0,0) = 1e30f;





    else if ((val(k,0,0,0) = height_curvature (point, c, h)) != 1e30f)
      sh++;
    else if ((val(k,0,0,0) = height_curvature_fit (point, c, h)) != 1e30f)
      f++;
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 584 "/home/pwachara/basilisk/src/curvature.h"
{mpi_all_reduce_array(&f,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&sh,MPI_INT,MPI_SUM,1);}  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/curvature.h", .line = 586, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 586 "/home/pwachara/basilisk/src/curvature.h"
{ 





    
_stencil_val(k,0,0,0);{
      { _stencil_val(k,0,0,0); } 
{_stencil_interfacial (point, c);{ {      
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
 
#line 603 "/home/pwachara/basilisk/src/curvature.h"
{_stencil_val(k,0,0,0);
   { _stencil_val(k,0,0,0);  }   } 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }




 
#line 612 "/home/pwachara/basilisk/src/curvature.h"
{ _stencil_centroids_curvature_fit (point, c);  }    
}
        
}    }}




{
      {_stencil_val_a(kappa,0,0,0);  } 
if (add)
      {_stencil_val_r(kappa,0,0,0);  }
    else
      {_stencil_val_a(kappa,0,0,0);  }}  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(+:sa) reduction(+:sc)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 586 "/home/pwachara/basilisk/src/curvature.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 586 "/home/pwachara/basilisk/src/curvature.h"
{





    double kf;
    if (val(k,0,0,0) < 1e30f)
      kf = val(k,0,0,0);
    else if (interfacial (point, c)) {





      double sk = 0., a = 0.;      
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
 
#line 603 "/home/pwachara/basilisk/src/curvature.h"
if (val(k,0,0,0) < 1e30f)
   sk += val(k,0,0,0), a++; 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
      
#line 605 "/home/pwachara/basilisk/src/curvature.h"
if (a > 0.)
 kf = sk/a, sa++;
      else




 kf = centroids_curvature_fit (point, c), sc++;
    }
    else
      kf = 1e30f;




    if (kf == 1e30f)
      val(kappa,0,0,0) = 1e30f;
    else if (add)
      val(kappa,0,0,0) += sigma*kf;
    else
      val(kappa,0,0,0) = sigma*kf;
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 626 "/home/pwachara/basilisk/src/curvature.h"
{mpi_all_reduce_array(&sc,MPI_INT,MPI_SUM,1);mpi_all_reduce_array(&sa,MPI_INT,MPI_SUM,1);}
#line 643 "/home/pwachara/basilisk/src/curvature.h"
  { cstats _ret= (cstats){sh, f, sa, sc};delete((scalar*)((scalar[]){k,{-1}}));if((ch).x.i<=0)delete((scalar*)((vector[]){h,{{-1},{-1},{-1}}}));{end_tracing("curvature","/home/pwachara/basilisk/src/curvature.h",643);return _ret;}}delete((scalar*)((scalar[]){k,{-1}}));
end_tracing("curvature","/home/pwachara/basilisk/src/curvature.h",644);}
#line 665 "/home/pwachara/basilisk/src/curvature.h"

static double pos_x (Point point, vector h, coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 668 "/home/pwachara/basilisk/src/curvature.h"
if (fabs(height(val(h.x,0,0,0))) > 1.)
    return 1e30f;
  coord o = {x, y, z};
  o.x += height(val(h.x,0,0,0))*Delta;
  double pos = 0.;
  
    pos += (o.x - Z->x)*G->x;    pos += (o.y - Z->y)*G->y;    pos += (o.z - Z->z)*G->z;
  return pos;
}
#line 666
static double pos_y (Point point, vector h, coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 668 "/home/pwachara/basilisk/src/curvature.h"
if (fabs(height(val(h.y,0,0,0))) > 1.)
    return 1e30f;
  coord o = {x, y, z};
  o.y += height(val(h.y,0,0,0))*Delta;
  double pos = 0.;
  
    pos += (o.y - Z->y)*G->y;    pos += (o.z - Z->z)*G->z;    pos += (o.x - Z->x)*G->x;
  return pos;
}
#line 666
static double pos_z (Point point, vector h, coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 668 "/home/pwachara/basilisk/src/curvature.h"
if (fabs(height(val(h.z,0,0,0))) > 1.)
    return 1e30f;
  coord o = {x, y, z};
  o.z += height(val(h.z,0,0,0))*Delta;
  double pos = 0.;
  
    pos += (o.z - Z->z)*G->z;    pos += (o.x - Z->x)*G->x;    pos += (o.y - Z->y)*G->y;
  return pos;
}







static double height_position (Point point, scalar f, vector h,
          coord * G, coord * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;






  
#line 693 "/home/pwachara/basilisk/src/curvature.h"
typedef struct {
    double n;
    double (* pos) (Point, vector, coord *, coord *);
  } NormPos;
  struct { NormPos x, y, z; } n;
  
    n.x.n = val(f,1,0,0) - val(f,-1,0,0), n.x.pos = pos_x;    n.y.n = val(f,0,1,0) - val(f,0,-1,0), n.y.pos = pos_y;    n.z.n = val(f,0,0,1) - val(f,0,0,-1), n.z.pos = pos_z;




  if (fabs(n.x.n) < fabs(n.y.n))
    do { NormPos _tmp_ = n.x; n.x = n.y; n.y = _tmp_; } while(false);

  if (fabs(n.x.n) < fabs(n.z.n))
    do { NormPos _tmp_ = n.x; n.x = n.z; n.z = _tmp_; } while(false);
  if (fabs(n.y.n) < fabs(n.z.n))
    do { NormPos _tmp_ = n.y; n.y = n.z; n.z = _tmp_; } while(false);





  double pos = 1e30f;
  
    if (pos == 1e30f)
      pos = n.x.pos (point, h, G, Z);    
#line 718
if (pos == 1e30f)
      pos = n.y.pos (point, h, G, Z);    
#line 718
if (pos == 1e30f)
      pos = n.z.pos (point, h, G, Z);

  return pos;
}
#line 684
static void _stencil_height_position (Point point, scalar f,_stencil_undefined * h,
_stencil_undefined * G,_stencil_undefined * Z)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;        
          
     
      






  
  
  
    
#line 699 "/home/pwachara/basilisk/src/curvature.h"
{ _stencil_val(f,1,0,0); _stencil_val(f,-1,0,0);     }    { _stencil_val(f,0,1,0); _stencil_val(f,0,-1,0);     }    { _stencil_val(f,0,0,1); _stencil_val(f,0,0,-1);     }                                          
    
    
    




     

     
     





  
     
          
      

  return ;
}
#line 735 "/home/pwachara/basilisk/src/curvature.h"
void position (scalar f, scalar pos,
        coord G, coord Z, bool add)
{
#line 749 "/home/pwachara/basilisk/src/curvature.h"
  vector fh = _attribute[f.i].height,   h=(fh).x.i>0?(fh):new_vector("h");
  if (!fh.x.i)
    heights (f, h);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/curvature.h", .line = 752, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 752 "/home/pwachara/basilisk/src/curvature.h"
{
_stencil_interfacial (point, f);{ {  
       _stencil_height_position (point, f, NULL,NULL ,NULL ); 
{      





  _stencil_mycs (point, f);     
 _stencil_val(f,0,0,0);    
 
  
 
         
      }      
if (add)
 {_stencil_val_r(pos,0,0,0);  }
      else
 {_stencil_val_a(pos,0,0,0);  }
    }
      
{_stencil_val_a(pos,0,0,0);  }}  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 752 "/home/pwachara/basilisk/src/curvature.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 752 "/home/pwachara/basilisk/src/curvature.h"
{
    if (interfacial (point, f)) {
      double hp = height_position (point, f, h, &G, &Z);
      if (hp == 1e30f) {





 coord n = mycs (point, f), o = {x,y,z}, c;
 double alpha = plane_alpha (val(f,0,0,0), n);
 plane_area_center (n, alpha, &c);
 hp = 0.;
 
   hp += (o.x + Delta*c.x - Z.x)*G.x;   hp += (o.y + Delta*c.y - Z.y)*G.y;   hp += (o.z + Delta*c.z - Z.z)*G.z;
      }
      if (add)
 val(pos,0,0,0) += hp;
      else
 val(pos,0,0,0) = hp;
    }
    else
      val(pos,0,0,0) = 1e30f;
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 775 "/home/pwachara/basilisk/src/curvature.h"
if((fh).x.i<=0)delete((scalar*)((vector[]){h,{{-1},{-1},{-1}}}));
#line 790 "/home/pwachara/basilisk/src/curvature.h"
}
#line 36 "/home/pwachara/basilisk/src/tension.h"
static int stability_2_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}
#line 17 "/home/pwachara/basilisk/src/tension.h"





#line 36 "/home/pwachara/basilisk/src/tension.h"
      static int stability_2(const int i,const double t,Event *_ev){tracing("stability_2","/home/pwachara/basilisk/src/tension.h",36);
{





  double amin = 1e30f, amax = -1e30f, dmin = 1e30f;
if(!is_constant(fm.x) && !is_constant(alpha.x)){
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/tension.h", .line = 44, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 44 "/home/pwachara/basilisk/src/tension.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{_stencil_val(fm.x,0,0,0); {
_stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0); { _stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0); }
_stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0); { _stencil_val(alpha.x,0,0,0);_stencil_val(fm.x,0,0,0); }    

}   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{_stencil_val(fm.y,0,0,0); {
_stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0); { _stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0); }
_stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0); { _stencil_val(alpha.y,0,0,0);_stencil_val(fm.y,0,0,0); }    

}   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{_stencil_val(fm.z,0,0,0); {
_stencil_val(alpha.z,0,0,0);_stencil_val(fm.z,0,0,0); { _stencil_val(alpha.z,0,0,0);_stencil_val(fm.z,0,0,0); }
_stencil_val(alpha.z,0,0,0);_stencil_val(fm.z,0,0,0); { _stencil_val(alpha.z,0,0,0);_stencil_val(fm.z,0,0,0); }    

}   }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(min:amin) reduction(max:amax) reduction(min:dmin)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 44 "/home/pwachara/basilisk/src/tension.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (val(fm.x,0,0,0) > 0.) {
      if (val(alpha.x,0,0,0)/val(fm.x,0,0,0) > amax) amax = val(alpha.x,0,0,0)/val(fm.x,0,0,0);
      if (val(alpha.x,0,0,0)/val(fm.x,0,0,0) < amin) amin = val(alpha.x,0,0,0)/val(fm.x,0,0,0);
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (val(fm.y,0,0,0) > 0.) {
      if (val(alpha.y,0,0,0)/val(fm.y,0,0,0) > amax) amax = val(alpha.y,0,0,0)/val(fm.y,0,0,0);
      if (val(alpha.y,0,0,0)/val(fm.y,0,0,0) < amin) amin = val(alpha.y,0,0,0)/val(fm.y,0,0,0);
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (val(fm.z,0,0,0) > 0.) {
      if (val(alpha.z,0,0,0)/val(fm.z,0,0,0) > amax) amax = val(alpha.z,0,0,0)/val(fm.z,0,0,0);
      if (val(alpha.z,0,0,0)/val(fm.z,0,0,0) < amin) amin = val(alpha.z,0,0,0)/val(fm.z,0,0,0);
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 49 "/home/pwachara/basilisk/src/tension.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 49 "/home/pwachara/basilisk/src/tension.h"
{mpi_all_reduce_array(&dmin,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&amax,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&amin,MPI_DOUBLE,MPI_MIN,1);}}else if(is_constant(fm.x) && !is_constant(alpha.x)){_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/tension.h", .line = 44, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 44 "/home/pwachara/basilisk/src/tension.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{; {
_stencil_val(alpha.x,0,0,0);; { _stencil_val(alpha.x,0,0,0);; }
_stencil_val(alpha.x,0,0,0);; { _stencil_val(alpha.x,0,0,0);; }    

}   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{; {
_stencil_val(alpha.y,0,0,0);; { _stencil_val(alpha.y,0,0,0);; }
_stencil_val(alpha.y,0,0,0);; { _stencil_val(alpha.y,0,0,0);; }    

}   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{; {
_stencil_val(alpha.z,0,0,0);; { _stencil_val(alpha.z,0,0,0);; }
_stencil_val(alpha.z,0,0,0);; { _stencil_val(alpha.z,0,0,0);; }    

}   }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(min:amin) reduction(max:amax) reduction(min:dmin)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 44 "/home/pwachara/basilisk/src/tension.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (_const_fm.x > 0.) {
      if (val(alpha.x,0,0,0)/_const_fm.x > amax) amax = val(alpha.x,0,0,0)/_const_fm.x;
      if (val(alpha.x,0,0,0)/_const_fm.x < amin) amin = val(alpha.x,0,0,0)/_const_fm.x;
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (_const_fm.y > 0.) {
      if (val(alpha.y,0,0,0)/_const_fm.y > amax) amax = val(alpha.y,0,0,0)/_const_fm.y;
      if (val(alpha.y,0,0,0)/_const_fm.y < amin) amin = val(alpha.y,0,0,0)/_const_fm.y;
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (_const_fm.z > 0.) {
      if (val(alpha.z,0,0,0)/_const_fm.z > amax) amax = val(alpha.z,0,0,0)/_const_fm.z;
      if (val(alpha.z,0,0,0)/_const_fm.z < amin) amin = val(alpha.z,0,0,0)/_const_fm.z;
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 49 "/home/pwachara/basilisk/src/tension.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 49 "/home/pwachara/basilisk/src/tension.h"
{mpi_all_reduce_array(&dmin,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&amax,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&amin,MPI_DOUBLE,MPI_MIN,1);}}else if(!is_constant(fm.x) && is_constant(alpha.x)){_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/tension.h", .line = 44, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 44 "/home/pwachara/basilisk/src/tension.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{_stencil_val(fm.x,0,0,0); {
;_stencil_val(fm.x,0,0,0); {;_stencil_val(fm.x,0,0,0); }
;_stencil_val(fm.x,0,0,0); {;_stencil_val(fm.x,0,0,0); }    

}   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{_stencil_val(fm.y,0,0,0); {
;_stencil_val(fm.y,0,0,0); {;_stencil_val(fm.y,0,0,0); }
;_stencil_val(fm.y,0,0,0); {;_stencil_val(fm.y,0,0,0); }    

}   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{_stencil_val(fm.z,0,0,0); {
;_stencil_val(fm.z,0,0,0); {;_stencil_val(fm.z,0,0,0); }
;_stencil_val(fm.z,0,0,0); {;_stencil_val(fm.z,0,0,0); }    

}   }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(min:amin) reduction(max:amax) reduction(min:dmin)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 44 "/home/pwachara/basilisk/src/tension.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (val(fm.x,0,0,0) > 0.) {
      if (_const_alpha.x/val(fm.x,0,0,0) > amax) amax = _const_alpha.x/val(fm.x,0,0,0);
      if (_const_alpha.x/val(fm.x,0,0,0) < amin) amin = _const_alpha.x/val(fm.x,0,0,0);
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (val(fm.y,0,0,0) > 0.) {
      if (_const_alpha.y/val(fm.y,0,0,0) > amax) amax = _const_alpha.y/val(fm.y,0,0,0);
      if (_const_alpha.y/val(fm.y,0,0,0) < amin) amin = _const_alpha.y/val(fm.y,0,0,0);
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (val(fm.z,0,0,0) > 0.) {
      if (_const_alpha.z/val(fm.z,0,0,0) > amax) amax = _const_alpha.z/val(fm.z,0,0,0);
      if (_const_alpha.z/val(fm.z,0,0,0) < amin) amin = _const_alpha.z/val(fm.z,0,0,0);
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 49 "/home/pwachara/basilisk/src/tension.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 49 "/home/pwachara/basilisk/src/tension.h"
{mpi_all_reduce_array(&dmin,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&amax,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&amin,MPI_DOUBLE,MPI_MIN,1);}}else {_coord _const_fm={_constant[fm.x.i-_NVARMAX],_constant[fm.y.i-_NVARMAX],_constant[fm.z.i-_NVARMAX]};NOT_UNUSED(_const_fm);_coord _const_alpha={_constant[alpha.x.i-_NVARMAX],_constant[alpha.y.i-_NVARMAX],_constant[alpha.z.i-_NVARMAX]};NOT_UNUSED(_const_alpha);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/tension.h", .line = 44, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
#line 44 "/home/pwachara/basilisk/src/tension.h"
{ 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 0);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{; {
;; {;; }
;; {;; }    

}   } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 1);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{; {
;; {;; }
;; {;; }    

}   } 
#line 379 "/home/pwachara/basilisk/src/grid/stencils.h"
_loop.face |= (1 << 2);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{; {
;; {;; }
;; {;; }    

}   }}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL (reduction(min:amin) reduction(max:amax) reduction(min:dmin)) {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++)
#line 44 "/home/pwachara/basilisk/src/tension.h"
{
  
#line 386 "/home/pwachara/basilisk/src/grid/multigrid.h"
if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (_const_fm.x > 0.) {
      if (_const_alpha.x/_const_fm.x > amax) amax = _const_alpha.x/_const_fm.x;
      if (_const_alpha.x/_const_fm.x < amin) amin = _const_alpha.x/_const_fm.x;
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_y = Delta;

  double Delta_z = Delta;


  double Delta_x = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_y);

  NOT_UNUSED(Delta_z);


  NOT_UNUSED(Delta_x);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (_const_fm.y > 0.) {
      if (_const_alpha.y/_const_fm.y > amax) amax = _const_alpha.y/_const_fm.y;
      if (_const_alpha.y/_const_fm.y < amin) amin = _const_alpha.y/_const_fm.y;
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  


if (point.i < point.n.x + 2 && point.j < point.n.y + 2) {
    int kg = -1; NOT_UNUSED(kg);    
#line 45 "/home/pwachara/basilisk/src/tension.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_z = Delta;

  double Delta_x = Delta;


  double Delta_y = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_z);

  NOT_UNUSED(Delta_x);


  NOT_UNUSED(Delta_y);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 45 "/home/pwachara/basilisk/src/tension.h"
if (_const_fm.z > 0.) {
      if (_const_alpha.z/_const_fm.z > amax) amax = _const_alpha.z/_const_fm.z;
      if (_const_alpha.z/_const_fm.z < amin) amin = _const_alpha.z/_const_fm.z;
      if (Delta < dmin) dmin = Delta;
    }}
  
#line 403 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 49 "/home/pwachara/basilisk/src/tension.h"
}
      
#line 317 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 49 "/home/pwachara/basilisk/src/tension.h"
{mpi_all_reduce_array(&dmin,MPI_DOUBLE,MPI_MIN,1);mpi_all_reduce_array(&amax,MPI_DOUBLE,MPI_MAX,1);mpi_all_reduce_array(&amin,MPI_DOUBLE,MPI_MIN,1);}}
  double rhom = (1./amin + 1./amax)/2.;





  double sigma = 0.;
  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar c=*_i;(&c)->i>=0;c=*++_i){
    sigma += _attribute[c.i].sigma;}}
  if (sigma) {
    double dt = sqrt (rhom*( dmin*dmin*dmin)/(3.14159265358979*sigma));
    if (dt < dtmax)
      dtmax = dt;
  }
}{end_tracing("stability_2","/home/pwachara/basilisk/src/tension.h",64);return 0;}end_tracing("stability_2","/home/pwachara/basilisk/src/tension.h",64);}







static int acceleration_1_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int acceleration_1(const int i,const double t,Event *_ev){tracing("acceleration_1","/home/pwachara/basilisk/src/tension.h",72);
{




  {scalar*_i=(scalar*)( interfaces);if(_i)for(scalar f=*_i;(&f)->i>=0;f=*++_i){
    if (_attribute[f.i].sigma) {





      scalar phi = _attribute[f.i].phi;
      if (phi.i)
 curvature (f, phi, _attribute[f.i].sigma, true);
      else {
 phi = new_scalar("phi");
 curvature (f, phi, _attribute[f.i].sigma, false);
 _attribute[f.i].phi = phi;
      }
    }}}
}{end_tracing("acceleration_1","/home/pwachara/basilisk/src/tension.h",94);return 0;}end_tracing("acceleration_1","/home/pwachara/basilisk/src/tension.h",94);}
#line 8 "CubicTest.c"
#line 1 "view.h"
#line 1 "/home/pwachara/basilisk/src/view.h"
#line 56 "/home/pwachara/basilisk/src/view.h"
#line 1 "/home/pwachara/basilisk/src/gl/framebuffer.h"
typedef struct _framebuffer framebuffer;

framebuffer * framebuffer_new (unsigned width, unsigned height);
void framebuffer_destroy (framebuffer * p);
unsigned char * framebuffer_image (framebuffer * p);
float * framebuffer_depth (framebuffer * p);
#line 57 "/home/pwachara/basilisk/src/view.h"
#line 1 "/home/pwachara/basilisk/src/gl/trackball.h"
#line 50 "/home/pwachara/basilisk/src/gl/trackball.h"
void
gl_trackball(float q[4], float p1x, float p1y, float p2x, float p2y);
#line 61 "/home/pwachara/basilisk/src/gl/trackball.h"
void
gl_add_quats(float q1[4], float q2[4], float dest[4]);





void
gl_build_rotmatrix(float m[4][4], float q[4]);






void
gl_axis_to_quat(float a[3], float phi, float q[4]);
#line 58 "/home/pwachara/basilisk/src/view.h"
#line 1 "/home/pwachara/basilisk/src/gl/utils.h"
#line 1 "./gl/tinygl.h"
#line 1 "/home/pwachara/basilisk/src/gl/tinygl.h"
#line 122 "/home/pwachara/basilisk/src/gl/tinygl.h"
typedef unsigned int GLenum;
typedef int GLint;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef double GLdouble;
typedef int GLsizei;
typedef unsigned int GLbitfield;
typedef unsigned char GLubyte;

void glBegin (GLenum mode);
void glEnd (void);
void glClear (GLbitfield mask);
void glClearColor (float red, float green, float blue, float alpha);
void glBindTexture (GLenum target, GLuint texture);
void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
void glColorMaterial (GLenum face, GLenum mode);
void glDisable (GLenum cap);
void glEnable (GLenum cap);
void glFinish (void);
void glGetDoublev (GLenum pname, GLdouble * params);
void glGetIntegerv (GLenum pname, GLint * params);
void glHint (GLenum target, GLenum mode);
void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
void glGetLightfv (GLenum light, GLenum pname, GLfloat * params);
void glLightModeli (GLenum pname, GLint param);
void glLineWidth (GLfloat width);
void glPointSize (GLfloat size);
void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top,
       GLdouble nearVal, GLdouble farVal);
void glShadeModel (GLenum mode);
void glTexCoord1d (GLdouble s);
void glTexCoord2f (GLfloat s, GLfloat t);
void glTexImage1D (GLenum target, GLint level, GLint internalFormat,
     GLsizei width, GLint border, GLenum format, GLenum type,
     const void * data);
void glTexParameteri (GLenum target, GLenum pname, GLint param);
void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
void glVertex3f (GLfloat x, GLfloat y, GLfloat z);

GLenum glGetError (void);
void glGetFloatv (GLenum pname, GLfloat * params);
void glMultMatrixf (const GLfloat * m);
void glLoadIdentity (void);
void glScalef (GLfloat x, GLfloat y, GLfloat z);
void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
void glMatrixMode (GLenum mode);
void glPopMatrix (void);
void glPushMatrix (void);
void glLoadMatrixd (const GLdouble * m);
#line 2 "/home/pwachara/basilisk/src/gl/utils.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/stdio.h"
#include <stdio.h>
#line 3 "/home/pwachara/basilisk/src/gl/utils.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/stdbool.h"
#include <stdbool.h>
#line 4 "/home/pwachara/basilisk/src/gl/utils.h"

void gl_write_image (FILE * fp, const GLubyte * buffer,
       unsigned width, unsigned height, unsigned samples);
void gl_write_image_png (FILE * fp, const GLubyte * buffer,
    unsigned width, unsigned height, unsigned samples);
void init_gl();

void matrix_multiply (float * m, const float * n);
void vector_multiply (float * v, const float * m);

typedef struct {
  float m[16], p[16];
  float n[6][3];
  float d[6];
  unsigned width;
} Frustum;

void gl_get_frustum (Frustum * f);
int sphere_in_frustum (double x, double y, double z, double r, Frustum * f);
float sphere_diameter (double x, double y, double z, double r, Frustum * f);
void gl_check_error();

int polygonize (const double val[8], double isolevel, double triangles[5][3][3]);
void gl_perspective (double fovy, double aspect, double zNear, double zFar);
int gl_project (float objx, float objy, float objz,
  const float modelMatrix[16],
  const float projMatrix[16],
  const GLint viewport[4],
  float *winx, float *winy, float *winz);

#line 1 "/home/pwachara/basilisk/src/gl/parser.h"
typedef struct _Node Node;

struct _Node {
  char type;
  union {
    char * id;
    double (* func) (double);
    double value;
  } d;
  int s;
  Node * e[3];
};

Node * parse_node (char * code);
void free_node (Node * n);
void print_node (Node * n, FILE * fp);
void reset_node_type (Node * n, char type);
#line 35 "/home/pwachara/basilisk/src/gl/utils.h"
#line 59 "/home/pwachara/basilisk/src/view.h"



#line 1 "input.h"
#line 1 "/home/pwachara/basilisk/src/input.h"
#line 16 "/home/pwachara/basilisk/src/input.h"
void input_pgm (scalar s, FILE * fp,
  double ox, double oy, double width)
{
  char line[81];
  if (!fgets (line, 81, fp)) {
    fprintf (ferr, "input_pgm: could not read magic number\n");
    exit (1);
  }
  if (strcmp (line, "P2\n") && strcmp (line, "P5\n")) {
    fprintf (ferr, "input_pgm: magic number '%s' does not match PGM\n",
      line);
    exit (1);
  }
  int binary = !strcmp (line, "P5\n");
  if (!fgets (line, 81, fp)) {
    fprintf (ferr, "input_pgm: could not read width and height\n");
    exit (1);
  }
  int W, H;
  while (line[0] == '#' && fgets (line, 81, fp));
  if (line[0] == '#' || sscanf (line, "%d %d", &W, &H) != 2) {
    fprintf (ferr, "input_pgm: could not read width and height\n");
    exit (1);
  }
  if (!fgets (line, 81, fp)) {
    fprintf (ferr, "input_pgm: could not read maxval\n");
    exit (1);
  }
  int maxval;
  if (sscanf (line, "%d", &maxval) != 1) {
    fprintf (ferr, "input_pgm: could not read maxval\n");
    exit (1);
  }
  if (maxval < 256) {
    unsigned char * a = ((unsigned char *) pmalloc ((W*H)*sizeof(unsigned char),__func__,__FILE__,__LINE__));
    size_t n = 0;
    if (binary)
      n = fread (a, 1, W*H, fp);
    else {
      int v;
      while (n < W*H && fscanf (fp, "%d ", &v) == 1)
 a[n++] = v;
    }
    if (n != W*H) {
      fprintf (ferr, "input_pgm: read only %ld values\n", n);
      exit (1);
    }
  
    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/input.h", .line = 63, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 63 "/home/pwachara/basilisk/src/input.h"
{          
      
{
 {_stencil_val_a(s,0,0,0);          }
 
{_stencil_val_a(s,0,0,0);  }}    
}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 63 "/home/pwachara/basilisk/src/input.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 63 "/home/pwachara/basilisk/src/input.h"
{
      int i = (x - ox)*W/width, j = (y - oy)*W/width;
      if (i >= 0 && i < W && j >= 0 && j < H)
 val(s,0,0,0) = 1. - a[(H - 1 - j)*W + i]/(double)maxval;
      else
 val(s,0,0,0) = 0.;
    }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}    
#line 70 "/home/pwachara/basilisk/src/input.h"
pfree (a,__func__,__FILE__,__LINE__);
  }
  else {
    unsigned short * a = ((unsigned short *) pmalloc ((W*H)*sizeof(unsigned short),__func__,__FILE__,__LINE__));
    size_t n = 0;
    if (binary)
      n = fread (a, 2, W*H, fp);
    else {
      int v;
      while (n < W*H && fscanf (fp, "%d ", &v) == 1)
 a[n++] = v;
    }
    if (n != W*H) {
      fprintf (ferr, "input_pgm: read only %ld values\n", n);
      exit (1);
    }
  
    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/input.h", .line = 86, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 86 "/home/pwachara/basilisk/src/input.h"
{          
      
{
 {_stencil_val_a(s,0,0,0);          }
 
{_stencil_val_a(s,0,0,0);  }}    
}

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 86 "/home/pwachara/basilisk/src/input.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 86 "/home/pwachara/basilisk/src/input.h"
{
      int i = (x - ox)*W/width, j = (y - oy)*W/width;
      if (i >= 0 && i < W && j >= 0 && j < H)
 val(s,0,0,0) = 1. - a[(H - 1 - j)*W + i]/(double)maxval;
      else
 val(s,0,0,0) = 0.;
    }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}    
#line 93 "/home/pwachara/basilisk/src/input.h"
pfree (a,__func__,__FILE__,__LINE__);
  }
}

static void next_char (FILE * fp, int target)
{
  int c = fgetc(fp), para = 0;
  while (c != EOF && (c != target || para > 0)) {
    if (c == '{') para++;
    if (c == '}') para--;
    c = fgetc(fp);
  }
  if (c != target) {
    fprintf (ferr, "input_gfs(): error: expecting '%c'\n", target);
    exit (1);
  }
}

static int next_string (FILE * fp, const char * target)
{
  int slen = strlen (target), para = 0;
  char s[slen + 1];
  s[slen] = '\0';
  int len = 0, c = fgetc (fp);
  while (c != EOF && len < slen) {
    if (c == '{') para++;
    if (c == '}') para--;
    s[len++] = c;
    c = fgetc (fp);
  }
  while (c != EOF && para >= 0) {
    if (!strcmp (s, target) && para == 0)
      break;
    if (c == '{') para++;
    if (c == '}') para--;
    for (int i = 0; i < slen - 1; i++)
      s[i] = s[i+1];
    s[slen - 1] = c;
    c = fgetc (fp);
  }
  if (strcmp (s, target))
    c = -1;
  return c;
}
#line 156 "/home/pwachara/basilisk/src/input.h"
     
void input_gfs (FILE * fp,
  scalar * list,
  char * file)
{tracing("input_gfs","/home/pwachara/basilisk/src/input.h",157);
  not_mpi_compatible();

  if (file && !(fp = fopen (file, "r"))) {
    perror (file);
    exit (1);
  }

  bool input_all = (list == all);
  if (!list) list = all;





  next_char (fp, '{');

  char * s = ((char *) pmalloc ((1)*sizeof(char),__func__,__FILE__,__LINE__));
  int len = 0;
  int c = fgetc(fp);
  while (c != EOF && c != '}') {
    s[len++] = c;
    s = (char *) prealloc (s, (len + 1)*sizeof(char),__func__,__FILE__,__LINE__);
    s[len] = '\0';
    c = fgetc(fp);
  }
  if (c != '}') {
    fprintf (ferr, "input_gfs(): error: expecting '}'\n");
    exit (1);
  }

  char * s1 = strstr (s, "variables");
  if (!s1) {
    fprintf (ferr, "input_gfs(): error: expecting 'variables'\n");
    exit (1);
  }

  s1 = strstr (s1, "=");
  if (!s1) {
    fprintf (ferr, "input_gfs(): error: expecting '='\n");
    exit (1);
  }
  s1++;

  while (strchr (" \t", *s1))
    s1++;

  scalar * input = NULL;
  s1 = strtok (s1, ", \t");
  while (s1) {
    char * name = replace (s1, '_', '.', false);
    bool found = false;
    {scalar*_i=(scalar*)( list);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
      if (!is_constant(s) && _attribute[s.i].name && !strcmp (_attribute[s.i].name, name)) {
 input = list_append (input, s);
 found = true; break;
      }}}
    if (!found) {
      if (input_all) {
 scalar s = new_scalar("s");
 pfree (_attribute[s.i].name,__func__,__FILE__,__LINE__);
 _attribute[s.i].name = pstrdup (name,__func__,__FILE__,__LINE__);
 input = list_append (input, s);
      }
      else
 input = list_append (input, (scalar){INT_MAX});
    }
    pfree (name,__func__,__FILE__,__LINE__);
    s1 = strtok (NULL, ", \t");
  }
  pfree (s,__func__,__FILE__,__LINE__);

  next_char (fp, '{');
  double t1 = 0.;
  if (next_string (fp, "Time") >= 0) {
    next_char (fp, '{');
    next_char (fp, 't');
    next_char (fp, '=');
    if (fscanf (fp, "%lf", &t1) != 1) {
      fprintf (ferr, "input_gfs(): error: expecting 't'\n");
      exit (1);
    }
    next_char (fp, '}');
    next_char (fp, '}');
  }

  if (next_string (fp, "Box") < 0) {
    fprintf (ferr, "input_gfs(): error: expecting 'GfsBox'\n");
    exit (1);
  }

  next_char (fp, '{');
  next_char (fp, '{');
  next_char (fp, '\n');

  scalar * listm =((scalar[]) {cm,fm.x,fm.y,fm.z,{-1}});
  scalar * listr = !is_constant(cm) ? listm : NULL;
  NOT_UNUSED (listr);
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 259 "/home/pwachara/basilisk/src/input.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 259 "/home/pwachara/basilisk/src/input.h"
{
    unsigned flags;
    if (fread (&flags, sizeof (unsigned), 1, fp) != 1) {
      fprintf (ferr, "input_gfs(): error: expecting 'flags'\n");
      exit (1);
    }
    if (!(flags & (1 << 4)) && is_leaf(cell))
      refine_cell (point, listr, 0, NULL);
    double a;
    if (fread (&a, sizeof (double), 1, fp) != 1 || a != -1) {
      fprintf (ferr, "input_gfs(): error: expecting '-1'\n");
      exit (1);
    }
    {scalar*_i=(scalar*)( input);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){ {
      if (fread (&a, sizeof (double), 1, fp) != 1) {
 fprintf (ferr, "input_gfs(): error: expecting a scalar\n");
 exit (1);
      }
      if (s.i != INT_MAX) {
 if (_attribute[s.i].v.x.i >= 0) {



   if (_attribute[s.i].v.x.i == s.i) {
     s = _attribute[s.i].v.y;
     val(s,0,0,0) = a;
   }
   else if (_attribute[s.i].v.y.i == s.i) {
     s = _attribute[s.i].v.x;
     val(s,0,0,0) = - a;
   }


   else
     val(s,0,0,0) = a;

 }
 else
   val(s,0,0,0) = a;
      }
    }}}
    if (is_leaf(cell))
      continue;
  }} 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}
  
#line 303 "/home/pwachara/basilisk/src/input.h"
{scalar*_i=(scalar*)( listm);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s))
      _attribute[s.i].dirty = true;}}
  {scalar*_i=(scalar*)( input);if(_i)for(scalar s=*_i;(&s)->i>=0;s=*++_i){
    if (!is_constant(s))
      _attribute[s.i].dirty = true;}}

  pfree (input,__func__,__FILE__,__LINE__);
  if (file)
    fclose (fp);


  while (t < t1 && events (false))
    t = tnext;
  events (false);
end_tracing("input_gfs","/home/pwachara/basilisk/src/input.h",318);}



static void bc_grd (double * v, int nx, int ny, bool periodic[2])
{
  if (periodic[0])
    for (int i = 0; i < ny; i++) {
      ((v)[(-1) + 1 + ((i) + 1)*(nx + 2)]) = ((v)[(nx - 1) + 1 + ((i) + 1)*(nx + 2)]);
      ((v)[(nx) + 1 + ((i) + 1)*(nx + 2)]) = ((v)[(0) + 1 + ((i) + 1)*(nx + 2)]);
    }
  else
    for (int i = 0; i < ny; i++) {
      ((v)[(-1) + 1 + ((i) + 1)*(nx + 2)]) = ((v)[(0) + 1 + ((i) + 1)*(nx + 2)]);
      ((v)[(nx) + 1 + ((i) + 1)*(nx + 2)]) = ((v)[(nx - 1) + 1 + ((i) + 1)*(nx + 2)]);
    }
  if (periodic[1])
    for (int j = -1; j <= nx; j++) {
      ((v)[(j) + 1 + ((-1) + 1)*(nx + 2)]) = ((v)[(j) + 1 + ((ny - 1) + 1)*(nx + 2)]);
      ((v)[(j) + 1 + ((ny) + 1)*(nx + 2)]) = ((v)[(j) + 1 + ((0) + 1)*(nx + 2)]);
    }
  else
    for (int j = -1; j <= nx; j++) {
      ((v)[(j) + 1 + ((-1) + 1)*(nx + 2)]) = ((v)[(j) + 1 + ((0) + 1)*(nx + 2)]);
      ((v)[(j) + 1 + ((ny) + 1)*(nx + 2)]) = ((v)[(j) + 1 + ((ny - 1) + 1)*(nx + 2)]);
    }
}
#line 381 "/home/pwachara/basilisk/src/input.h"
void input_grd (scalar s,
  FILE * fp, const char * file,
  double nodatavalue,
  bool linear,
  bool periodic[2],
  int smooth)
{
  scalar input = s;

  if (file && !(fp = fopen (file, "r"))) {
    perror (file);
    exit (1);
  }


  double DeltaGRD;
  int nx, ny;
  double XG0, YG0, ndv;


  char waste[100];
  if (fscanf (fp, "%s %d", waste, &nx) != 2) {
    fprintf (ferr, "input_grd(): error reading 'nx'\n");
    if (file) fclose (fp);
    return;
  }
  if (fscanf (fp, "%s %d", waste, &ny) != 2) {
    fprintf (ferr, "input_grd(): error reading 'ny'\n");
    if (file) fclose (fp);
    return;
  }
  if (fscanf (fp, "%s %lf", waste, &XG0) != 2) {
    fprintf (ferr, "input_grd(): error reading 'XG0'\n");
    if (file) fclose (fp);
    return;
  }
  if (fscanf (fp, "%s %lf", waste, &YG0) != 2) {
    fprintf (ferr, "input_grd(): error reading 'YG0'\n");
    if (file) fclose (fp);
    return;
  }
  if (fscanf (fp, "%s %lf", waste, &DeltaGRD) != 2) {
    fprintf (ferr, "input_grd(): error reading 'DeltaGRD'\n");
    if (file) fclose (fp);
    return;
  }
  if (fscanf (fp, "%s %lf", waste, &ndv) != 2) {
    fprintf (ferr, "input_grd(): error reading 'ndv'\n");
    if (file) fclose (fp);
    return;
  }


  if (nodatavalue == 0.12345678)
    nodatavalue = ndv;


  double * value = ((double *) pmalloc (((nx + 2)*(ny + 2))*sizeof(double),__func__,__FILE__,__LINE__));
  for (int i = ny - 1; i >= 0; i--)
    for (int j = 0 ; j < nx; j++) {
      if (fscanf (fp, "%lf ", &((value)[(j) + 1 + ((i) + 1)*(nx + 2)])) != 1) {
 fprintf (ferr, "input_grd(): error reading value %d,%d\n", i, j);
 if (file) fclose (fp);
 pfree (value,__func__,__FILE__,__LINE__);
 return;
      }
    }
  bc_grd (value, nx, ny, periodic);


  if (smooth > 0) {
    double * smoothed = ((double *) pmalloc (((nx + 2)*(ny + 2))*sizeof(double),__func__,__FILE__,__LINE__));
    for (int s = 0; s < smooth; s++) {
      for (int i = 0; i < ny; i++)
 for (int j = 0 ; j < nx; j++) {
   int n = 0;
   ((smoothed)[(j) + 1 + ((i) + 1)*(nx + 2)]) = 0.;
   for (int k = -1; k <= 1; k++)
     for (int l = -1; l <= 1; l++)
       if ((l != 0 || k != 0) &&
    ((value)[(j + l) + 1 + ((i + k) + 1)*(nx + 2)]) != ndv)
  ((smoothed)[(j) + 1 + ((i) + 1)*(nx + 2)]) += ((value)[(j + l) + 1 + ((i + k) + 1)*(nx + 2)]), n++;
   if (n == 0)
     ((smoothed)[(j) + 1 + ((i) + 1)*(nx + 2)]) = ndv;
   else
     ((smoothed)[(j) + 1 + ((i) + 1)*(nx + 2)]) /= n;
 }
      do { double * _tmp_ = value; value = smoothed; smoothed = _tmp_; } while(false);
      bc_grd (value, nx, ny, periodic);
    }
    pfree (smoothed,__func__,__FILE__,__LINE__);
  }

  bool warning = false;
{  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/input.h", .line = 475, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 475 "/home/pwachara/basilisk/src/input.h"
{            
    
            
              
     
    
            
              
     

    
    
{ {
{ 

{              

 
 
 _stencil_val_a(input,0,0,0); 
                           
                            
                          
                          
                
      }
 
{_stencil_val_a(input,0,0,0);          }}    
} 
{
      _stencil_val_a(input,0,0,0);    
      
    }}  
}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 475 "/home/pwachara/basilisk/src/input.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 475 "/home/pwachara/basilisk/src/input.h"
{
    if (periodic[0]) {
      while (x < XG0) x += nx*DeltaGRD;
      while (x > XG0 + nx*DeltaGRD) x -= nx*DeltaGRD;
    }
    if (periodic[1]) {
      while (y < YG0) y += ny*DeltaGRD;
      while (y > YG0 + ny*DeltaGRD) y -= ny*DeltaGRD;
    }

    int j1 = (x - XG0)/DeltaGRD;
    int i1 = (y - YG0)/DeltaGRD;
    if (i1 >= -1 && i1 < ny && j1 >= -1 && j1 < nx) {
      if (linear &&
   ((value)[(j1) + 1 + ((i1) + 1)*(nx + 2)]) != ndv && ((value)[(j1 + 1) + 1 + ((i1) + 1)*(nx + 2)]) != ndv &&
   ((value)[(j1) + 1 + ((i1 + 1) + 1)*(nx + 2)]) != ndv && ((value)[(j1 + 1) + 1 + ((i1 + 1) + 1)*(nx + 2)]) != ndv) {

 double dx = x - (j1*DeltaGRD + XG0);
 double dy = y - (i1*DeltaGRD + YG0);
 val(input,0,0,0) = (((value)[(j1) + 1 + ((i1) + 1)*(nx + 2)]) +
     dx*(((value)[(j1 + 1) + 1 + ((i1) + 1)*(nx + 2)]) - ((value)[(j1) + 1 + ((i1) + 1)*(nx + 2)]))/DeltaGRD +
     dy*(((value)[(j1) + 1 + ((i1 + 1) + 1)*(nx + 2)]) - ((value)[(j1) + 1 + ((i1) + 1)*(nx + 2)]))/DeltaGRD +
     dx*dy*(((value)[(j1) + 1 + ((i1) + 1)*(nx + 2)]) + ((value)[(j1 + 1) + 1 + ((i1 + 1) + 1)*(nx + 2)]) -
     ((value)[(j1) + 1 + ((i1 + 1) + 1)*(nx + 2)]) - ((value)[(j1 + 1) + 1 + ((i1) + 1)*(nx + 2)]))
     /( DeltaGRD*DeltaGRD));
      }
      else
 val(input,0,0,0) = ((value)[(j1) + 1 + ((i1) + 1)*(nx + 2)]);
    }
    else {
      val(input,0,0,0) = nodatavalue;
      warning = true;
    }
  }}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 508 "/home/pwachara/basilisk/src/input.h"
}
  pfree (value,__func__,__FILE__,__LINE__);

  if (warning)
    fprintf (ferr,
      "%s:%d: warning: raster data is not covering all the simulation area\n",
      "/home/pwachara/basilisk/src/input.h", 514);

  if (file)
    fclose (fp);
}
#line 63 "/home/pwachara/basilisk/src/view.h"







typedef struct {
  char * expr;
  scalar s;
} cexpr;

static scalar get_cexpr (cexpr * cache, const char * expr)
{
  cexpr * c = cache;
  while (c->expr) {
    if (!strcmp (c->expr, expr)) {


      cexpr tmp = *c;
      while ((c + 1)->expr)
 *c = *(c + 1), c++;
      *c = tmp;
      return c->s;
    }
    c++;
  }
  return (scalar){-1};
}

static cexpr * add_cexpr (cexpr * cache, int maxlen,
     const char * expr, scalar s)
{
  cexpr * c = cache;
  while (c->expr) c++;
  int len = c - cache;
  if (len < maxlen) {
    cache = prealloc (cache, sizeof(cexpr)*(len + 2),__func__,__FILE__,__LINE__);
    c = &cache[len];
  }
  else {

    c = cache;
    pfree (c->expr,__func__,__FILE__,__LINE__);
    scalar s = c->s;
    delete (((scalar[]){s,{-1}}));

    while ((c + 1)->expr)
      *c = *(c + 1), c++;
  }
  c->expr = pstrdup (expr,__func__,__FILE__,__LINE__);
  c->s = s;
  (c + 1)->expr = NULL;
  return cache;
}

static void free_cexpr (cexpr * cache)
{
  cexpr * c = cache;
  while (c->expr) {
    pfree (c->expr,__func__,__FILE__,__LINE__);
    scalar s = c->s;
    delete (((scalar[]){s,{-1}}));
    c++;
  }
  pfree (cache,__func__,__FILE__,__LINE__);
}






typedef void (* MapFunc) (coord *);

struct _bview {
  float tx, ty, sx, sy, sz;
  float quat[4];
  float fov;
  float tz, near, far;

  bool gfsview;
  bool reversed;

  float bg[3];
  float lc;
  float res;

  unsigned width, height, samples;

  int maxlevel;

  framebuffer * fb;
  Frustum frustum;

  MapFunc map;

  int ni;

  bool active;

  cexpr * cache;
  int maxlen;
};

typedef struct _bview bview;




bview * bview_new()
{
  bview * p = ((bview *) pcalloc (1, sizeof(bview),__func__,__FILE__,__LINE__));

  p->tx = p->ty = 0;
  p->sx = p->sy = p->sz = 1.;
  p->quat[0] = p->quat[1] = p->quat[2] = 0; p->quat[3] = 1;
  p->fov = 24.;
  gl_trackball (p->quat, 0.0, 0.0, 0.0, 0.0);




  p->bg[0] = 0.3; p->bg[1] = 0.4; p->bg[2] = 0.6;

  p->res = 1.;
  p->lc = 0.004;

  p->samples = 4;
  p->width = 600*p->samples, p->height = 600*p->samples;
  p->maxlevel = -1;


  disable_fpe (FE_DIVBYZERO|FE_INVALID);

  p->fb = framebuffer_new (p->width, p->height);

  init_gl();
  p->active = false;

  enable_fpe (FE_DIVBYZERO|FE_INVALID);

  return p;
}




void bview_destroy (bview * p)
{
  framebuffer_destroy (p->fb);
  if (p->cache)
    free_cexpr (p->cache);
  pfree (p,__func__,__FILE__,__LINE__);
}




static bview * _view = NULL;






static void destroy_view()
{
  if (!(_view)) qassert ("/home/pwachara/basilisk/src/view.h", 231, "_view");
  bview_destroy (_view);
}

bview * get_view() {
  if (!_view) {
    _view = bview_new();
    free_solver_func_add (destroy_view);
  }
  return _view;
}




static void redraw (bool clear) {
  bview * view = get_view();


  disable_fpe (FE_DIVBYZERO|FE_INVALID);

  glMatrixMode (0x1701);
  glLoadIdentity ();

  if (view->far <= view->near) {
    double max = 2.;
    gl_perspective (view->fov, view->width/(float)view->height, 1., 1. + 2.*max);

    glMatrixMode (0x1700);
    glLoadIdentity ();
    glTranslatef (view->tx, view->ty, - (1. + max));
  }
  else {
    gl_perspective (view->fov, view->width/(float)view->height,
      view->near, view->far);

    glMatrixMode (0x1700);
    glLoadIdentity ();
    glTranslatef (view->tx, view->ty, view->tz);
  }

  GLfloat m[4][4];
  gl_build_rotmatrix (m, view->quat);
  glMultMatrixf (&m[0][0]);

  if (view->gfsview) {
    m[0][0] = 0., m[0][1] = 0., m[0][2] = -1.;
    m[1][0] = 0., m[1][1] = -1., m[1][2] = 0.;
    m[2][0] = 1., m[2][1] = 0., m[2][2] = 0.;
    glMultMatrixf (&m[0][0]);
  }

  glScalef (view->sx/L0, view->sy/L0, view->sz/L0);

  if (clear) {
    glClearColor (view->bg[0], view->bg[1], view->bg[2], 0.);
    glClear (0x00004000|0x00000100);
  }

  gl_get_frustum (&view->frustum);

  view->active = true;
  view->ni = 0;
}




bview * draw() {
  bview * view = get_view();
  if (!view->active)
    redraw( 
#line 246
true
#line 302
);
  else


    disable_fpe (FE_DIVBYZERO|FE_INVALID);
  glMatrixMode (0x1701);
  glTranslatef (0, 0, - 1e-4);
  return view;
}







typedef void * pointer;
#line 362 "/home/pwachara/basilisk/src/view.h"
typedef struct {
  GLubyte a[4];
  float depth;
} RGBA;

static void compose_image_op (void * pin, void * pout, int * len,
         MPI_Datatype * dptr)
{
  RGBA * rin = pin, * out = pout;
  for (int i = 0; i < *len; i++,rin++,out++)
    if (out->depth > rin->depth)
      *out = *rin;
}

     
static pointer compose_image (bview * view)
{tracing("compose_image","/home/pwachara/basilisk/src/view.h",377);
  unsigned char * image = framebuffer_image (view->fb);
  if (!(image)) qassert ("/home/pwachara/basilisk/src/view.h", 380, "image");
  if (npe() > 1) {
    MPI_Op op;
    MPI_Op_create (compose_image_op, true, &op);
    MPI_Datatype rgba;
    MPI_Type_create_struct (2,
       (int[]){4,1},
       (MPI_Aint[]){0,4},
       (MPI_Datatype[]){MPI_BYTE, MPI_FLOAT},
       &rgba);
    MPI_Type_commit (&rgba);
    float * depth = framebuffer_depth (view->fb);
    int size = view->width*view->height;
    RGBA * buf = pmalloc (size*sizeof(RGBA),__func__,__FILE__,__LINE__);
    unsigned char * ptr = image;
    float * dptr = depth;
    for (int i = 0; i < size; i++) {
      for (int j = 0; j < 4; j++)
 buf[i].a[j] = *ptr++;
      buf[i].depth = *dptr++;
    }
    if (pid() == 0) {
      MPI_Reduce (MPI_IN_PLACE, buf, size, rgba, op, 0, MPI_COMM_WORLD);
      unsigned char * ptr = image;
      for (int i = 0; i < size; i++)
 for (int j = 0; j < 4; j++)
   *ptr++ = buf[i].a[j];
    }
    else
      MPI_Reduce (buf, buf, size, rgba, op, 0, MPI_COMM_WORLD);
    pfree (buf,__func__,__FILE__,__LINE__);
    MPI_Op_free (&op);
    MPI_Type_free (&rgba);
  }
  {end_tracing("compose_image","/home/pwachara/basilisk/src/view.h",414);return image;}
end_tracing("compose_image","/home/pwachara/basilisk/src/view.h",415);}



#line 1 "vertexbuffer.h"
#line 1 "/home/pwachara/basilisk/src/vertexbuffer.h"
#line 14 "/home/pwachara/basilisk/src/vertexbuffer.h"
struct {

  Array * position, * normal, * color, * index;
  float modelview[16];
  int type;
  int dim;
  int vertex, nvertex;
  bool visible;


  int line_loop, lines, line_strip ;
  int quads, polygon, fan;
  int state;
} VertexBuffer = {
  .visible = false,
  .modelview = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 }
};

static void vertex_buffer_push_index (unsigned int i)
{
  i -= VertexBuffer.vertex;
  array_append (VertexBuffer.index, &i, sizeof(unsigned int));
}

void vertex_buffer_setup()
{
  VertexBuffer.nvertex = 0;
  VertexBuffer.type = -1;
  VertexBuffer.dim = -1;
  VertexBuffer.position = array_new();
  VertexBuffer.normal = array_new();
  VertexBuffer.color = array_new();
  VertexBuffer.index = array_new();
}

void vertex_buffer_free()
{
  array_free (VertexBuffer.position);
  VertexBuffer.position = NULL;
  array_free (VertexBuffer.normal);
  VertexBuffer.normal = NULL;
  array_free (VertexBuffer.color);
  VertexBuffer.color = NULL;
  array_free (VertexBuffer.index);
  VertexBuffer.index = NULL;
}

static void vertex_buffer_glBegin (unsigned int state)
{
  if (VertexBuffer.index) {

    glGetFloatv (0x0BA6, VertexBuffer.modelview);

    bview * view = get_view();

    float q[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0,
      - view->tx, - view->ty, 3, 1 };
    matrix_multiply (q, VertexBuffer.modelview);
    for (int i = 0; i < 16; i++)
      VertexBuffer.modelview[i] = q[i];

    gl_build_rotmatrix ((float (*)[4])q, view->quat);
    do { float _tmp_ = q[1]; q[1] = q[4]; q[4] = _tmp_; } while(false);
    do { float _tmp_ = q[2]; q[2] = q[8]; q[8] = _tmp_; } while(false);
    do { float _tmp_ = q[6]; q[6] = q[9]; q[9] = _tmp_; } while(false);
    matrix_multiply (q, VertexBuffer.modelview);
    for (int i = 0; i < 16; i++)
      VertexBuffer.modelview[i] = q[i];

    VertexBuffer.state = state;
    switch (state) {
    case 0x0002:
      VertexBuffer.line_loop = VertexBuffer.nvertex;
      break;
    case 0x0001:
      VertexBuffer.lines = VertexBuffer.nvertex;
      break;
    case 0x0003:
      VertexBuffer.line_strip = VertexBuffer.nvertex;
      break;
    case 0x0007:
      VertexBuffer.quads = VertexBuffer.nvertex;
      break;
    case 0x0009:
      VertexBuffer.polygon = VertexBuffer.nvertex;
      break;
    case 0x0006:
      VertexBuffer.fan = VertexBuffer.nvertex;
      break;
    default:
      fprintf (ferr, "glBegin (%d) not implemented yet\n", state);
      break;
    }
  }
  else
    glBegin (state);
}

static void vertex_buffer_glEnd()
{
  if (VertexBuffer.index) {
    int type = -1;
    switch (VertexBuffer.state) {

    case 0x0002:
      for (int i = VertexBuffer.line_loop; i < VertexBuffer.nvertex - 1; i++) {
 vertex_buffer_push_index (i);
 vertex_buffer_push_index (i + 1);
      }
      vertex_buffer_push_index (VertexBuffer.nvertex - 1);
      vertex_buffer_push_index (VertexBuffer.line_loop);
      type = 0;
      break;

    case 0x0001:
      for (int i = VertexBuffer.lines; i < VertexBuffer.nvertex; i += 2) {
 vertex_buffer_push_index (i);
 vertex_buffer_push_index (i + 1);
      }
      type = 0;
      break;

    case 0x0003:
      for (int i = VertexBuffer.line_strip; i < VertexBuffer.nvertex - 1; i++) {
 vertex_buffer_push_index (i);
 vertex_buffer_push_index (i + 1);
      }
      type = 0;
      break;

    case 0x0007:
      for (int i = VertexBuffer.quads; i < VertexBuffer.nvertex; i += 4)
 for (int j = 1; j <= 2; j++) {
   vertex_buffer_push_index (i);
   vertex_buffer_push_index (i + j);
   vertex_buffer_push_index (i + j + 1);
 }
      type = 1;
      break;

    case 0x0009:
      for (int j = 1; j <= VertexBuffer.nvertex - VertexBuffer.polygon - 2;
    j++) {
 vertex_buffer_push_index (VertexBuffer.polygon);
 vertex_buffer_push_index (VertexBuffer.polygon + j);
 vertex_buffer_push_index (VertexBuffer.polygon + j + 1);
      }
      type = 1;
      break;

    case 0x0006:
      for (int i = VertexBuffer.fan + 1; i < VertexBuffer.nvertex - 1; i++) {
 vertex_buffer_push_index (VertexBuffer.fan);
 vertex_buffer_push_index (i);
 vertex_buffer_push_index (i + 1);
      }
      type = 1;
      break;

    default:
      break;
    }
    VertexBuffer.state = 0;
    if (VertexBuffer.type >= 0 && type >= 0) {

      if (!(VertexBuffer.type == type)) qassert ("/home/pwachara/basilisk/src/vertexbuffer.h", 179, "VertexBuffer.type == type");
    }
    else
      VertexBuffer.type = type;
  }
  else
    glEnd();
}

static void vertex_buffer_glColor3f (float r, float g, float b)
{
  if (VertexBuffer.color) {
    struct { float x, y, z; } color = {r, g, b};
    array_append (VertexBuffer.color, &color, 3*sizeof(float));
  }
  else
    glColor3f (r, g, b);
}

static void vertex_buffer_glNormal3d (double nx, double ny, double nz)
{
  if (VertexBuffer.normal) {
    struct { float x, y, z; } normal = {nx, ny, nz};
    array_append (VertexBuffer.normal, &normal, 3*sizeof(float));
  }
  else
    glNormal3d (nx, ny, nz);
}

static void vertex_buffer_glVertex3d (double x, double y, double z)
{
  if (VertexBuffer.position) {
    if (VertexBuffer.dim < 3)
      VertexBuffer.dim = 3;
    float v[4] = {x, y, z, 1.};
    vector_multiply (v, VertexBuffer.modelview);
    array_append (VertexBuffer.position, v, 3*sizeof(float));
    VertexBuffer.nvertex++;
  }
  else
    glVertex3d (x, y, z);
}

static void vertex_buffer_glVertex2d (double x, double y)
{
  if (VertexBuffer.position) {
    if (VertexBuffer.dim < 2)
      VertexBuffer.dim = 2;
    float v[4] = {x, y, 0, 1.};
    vector_multiply (v, VertexBuffer.modelview);
    array_append (VertexBuffer.position, v, 3*sizeof(float));
    VertexBuffer.nvertex++;
  }
  else
    glVertex3d (x, y, 0.);
}
#line 420 "/home/pwachara/basilisk/src/view.h"






#line 1 "draw.h"
#line 1 "/home/pwachara/basilisk/src/draw.h"




#line 1 "/home/pwachara/basilisk/src/ast/std/ctype.h"
#include <ctype.h>
#line 6 "/home/pwachara/basilisk/src/draw.h"

#line 1 "gl/font.h"
#line 1 "/home/pwachara/basilisk/src/gl/font.h"
#line 27 "/home/pwachara/basilisk/src/gl/font.h"
#line 1 "/home/pwachara/basilisk/src/ast/std/stdio.h"
#include <stdio.h>
#line 28 "/home/pwachara/basilisk/src/gl/font.h"
#line 1 "gl/og_font.h"
#line 1 "/home/pwachara/basilisk/src/gl/og_font.h"




#line 1 "gl/tinygl.h"
#line 6 "/home/pwachara/basilisk/src/gl/og_font.h"

typedef struct tagSOG_StrokeVertex SOG_StrokeVertex;
struct tagSOG_StrokeVertex
{
    GLfloat X, Y;
};

typedef struct tagSOG_StrokeStrip SOG_StrokeStrip;
struct tagSOG_StrokeStrip
{
    int Number;
    const SOG_StrokeVertex *Vertices;
};

typedef struct tagSOG_StrokeChar SOG_StrokeChar;
struct tagSOG_StrokeChar
{
    GLfloat Right;
    int Number;
    const SOG_StrokeStrip* Strips;
};

typedef struct tagSOG_StrokeFont SOG_StrokeFont;
struct tagSOG_StrokeFont
{
    char *Name;
    int Quantity;
    GLfloat Height;
    const SOG_StrokeChar **Characters;
};
#line 29 "/home/pwachara/basilisk/src/gl/font.h"
#line 39 "/home/pwachara/basilisk/src/gl/font.h"
extern SOG_StrokeFont ogStrokeMonoRoman;
#line 48 "/home/pwachara/basilisk/src/gl/font.h"
static SOG_StrokeFont *oghStrokeByID( void *font )
{


    if( font == ((void *)0x0001) )
        return &ogStrokeMonoRoman;

    fprintf (ferr, "stroke font %p not found", font );
    return 0;
}
#line 83 "/home/pwachara/basilisk/src/gl/font.h"
void gl_StrokeCharacter( int character )
{
    void *fontID = ((void *)0x0001);
    const SOG_StrokeChar *schar;
    const SOG_StrokeStrip *strip;
    int i, j;
    SOG_StrokeFont *font = oghStrokeByID( fontID );

    if( !font ||
        ( 1 > character ) ||
        ( font->Quantity < character ) )
        return;

    schar = font->Characters[ character ];
    if( schar )
    {
        strip = schar->Strips;

        for( i = 0; i < schar->Number; i++, strip++ )
        {
            vertex_buffer_glBegin( 0x0003 );
            for( j = 0; j < strip->Number; j++ )
                vertex_buffer_glVertex2d( strip->Vertices[ j ].X, strip->Vertices[ j ].Y );
            vertex_buffer_glEnd( );
        }
        glTranslatef( schar->Right, 0.0, 0.0 );
    }
}
#line 147 "/home/pwachara/basilisk/src/gl/font.h"
void gl_StrokeString( const char *string )
{
    void *fontID = ((void *)0x0001);
    int i, j;
    float length = 0.0;
    SOG_StrokeFont *font = oghStrokeByID( fontID );
    unsigned char c;

    if( font && string )





        while(( c = *string++ ))
       if( c < font->Quantity ) {
                if( c == '\n' )
                {
                    glTranslatef ( -length, -( float )( font->Height ), 0.0 );
                    length = 0.0;
                }
                else
                {
                    const SOG_StrokeChar *schar =
                        font->Characters[ c ];
                    if( schar )
                    {
                        const SOG_StrokeStrip *strip = schar->Strips;

                        for( i = 0; i < schar->Number; i++, strip++ )
                        {
                            vertex_buffer_glBegin( 0x0003 );

                            for( j = 0; j < strip->Number; j++ )
                                vertex_buffer_glVertex2d( strip->Vertices[ j ].X,
                                            strip->Vertices[ j ].Y);

                            vertex_buffer_glEnd( );
                        }

                        length += schar->Right;
                        glTranslatef( schar->Right, 0.0, 0.0 );
                    }
                }
     }
}
#line 226 "/home/pwachara/basilisk/src/gl/font.h"
float gl_StrokeWidth( int character )
{
    void *fontID = ((void *)0x0001);
    float ret = 0;
    SOG_StrokeFont *font = oghStrokeByID( fontID );

    if( font &&
        ( 0 < character ) &&
        ( font->Quantity > character ) )
    {
        const SOG_StrokeChar *schar = font->Characters[ character ];
        if( schar )
            ret = schar->Right;
    }

    return ret;
}
#line 269 "/home/pwachara/basilisk/src/gl/font.h"
float gl_StrokeLength( const char *string )
{
    void *fontID = ((void *)0x0001);
    unsigned char c;
    float length = 0.0;
    float this_line_length = 0.0;
    SOG_StrokeFont *font = oghStrokeByID( fontID );

    if( font && string )
        while(( c = *string++ ))
            if( c < font->Quantity )
            {
                if( c == '\n' )
                {
                    if( length < this_line_length )
                        length = this_line_length;
                    this_line_length = 0.0;
                }
                else
                {
                    const SOG_StrokeChar *schar =
                        font->Characters[ c ];
                    if( schar )
                        this_line_length += schar->Right;
                }
            }

    if( length < this_line_length )
        length = this_line_length;
    return length;
}
#line 321 "/home/pwachara/basilisk/src/gl/font.h"
GLfloat gl_StrokeHeight()
{
    void *fontID = ((void *)0x0001);
    GLfloat ret = 0;
    SOG_StrokeFont *font = oghStrokeByID( fontID );

    if( font )
        ret = font->Height;

    return ret;
}
#line 8 "/home/pwachara/basilisk/src/draw.h"




void clear()
{
  bview * view = get_view();
  if (view->active)
    view->active = false;
  draw();
}
#line 50 "/home/pwachara/basilisk/src/draw.h"
void view (float tx, float ty,
    float fov,
    float quat[4],
    float sx, float sy, float sz,
    unsigned width, unsigned height, unsigned samples,
    float bg[3],
    float theta, float phi, float psi,
    bool relative,
    float tz, float near, float far,
    float res,
    char * camera,
    MapFunc map,
    int cache,
    float p1x, float p1y, float p2x, float p2y,
    bview * view1)
{
  bview * v = view1 ? view1 : get_view();
  if (fov) {
    if (relative)
      v->fov += (0.1 + 3.*v->fov)*fov;
    else
      v->fov = fov;
    v->fov = ( (v->fov) < 0.01 ? 0.01 : (v->fov) > 100. ? 100. : (v->fov));
  }
  for (int i = 0; i < 4; i++)
    if (quat[i]) {
      for (int j = 0; j < 4; j++)
 v->quat[j] = quat[j];
      break;
    }
  v->tx = relative ? v->tx + tx*0.02*(0.01 + 3.*v->fov) : tx;
  v->ty = relative ? v->ty + ty*0.02*(0.01 + 3.*v->fov) : ty;
  v->sx = sx;
  v->sy = sy;
  v->sz = sz;
  if (bg[0] || bg[1] || bg[2])
    for (int i = 0; i < 3; i++)
      v->bg[i] = bg[i];

  if (camera) {
    v->gfsview = false;
    if (strlen(camera) >= 4 &&
 !strcmp (&camera[strlen(camera) - 4], ".gfv")) {
      FILE * fp = fopen (camera, "r");
      if (!fp) {
 perror (camera);
 exit (1);
      }
      char s[81];
      float q[4], fov;
      int nq = 0, nf = 0;
      while (fgets (s, 81, fp) && (!nq || !nf)) {
 if (!nq)
   nq = sscanf (s, "  q0 = %f q1 = %f q2 = %f q3 = %f",
         &q[0], &q[1], &q[2], &q[3]);
 if (!nf)
   nf = sscanf (s, "  fov = %f", &fov);
      }
      if (nq != 4 || nf != 1) {
 fprintf (ferr, "%s: not a valid gfv file\n", camera);
 exit (1);
      }
      for (int j = 0; j < 4; j++)
 v->quat[j] = q[j];
      v->fov = fov;
      v->gfsview = true;
    }
    else if (!strcmp (camera, "left"))
      gl_axis_to_quat ((float[]){0,1,0}, - 3.14159265358979/2., v->quat);
    else if (!strcmp (camera, "right"))
      gl_axis_to_quat ((float[]){0,1,0}, 3.14159265358979/2., v->quat);
    else if (!strcmp (camera, "top"))
      gl_axis_to_quat ((float[]){1,0,0}, - 3.14159265358979/2., v->quat);
    else if (!strcmp (camera, "bottom"))
      gl_axis_to_quat ((float[]){1,0,0}, 3.14159265358979/2., v->quat);
    else if (!strcmp (camera, "front"))
      gl_axis_to_quat ((float[]){0,0,1}, 0., v->quat);
    else if (!strcmp (camera, "back"))
      gl_axis_to_quat ((float[]){0,1,0}, 3.14159265358979, v->quat);
    else if (!strcmp (camera, "iso")) {
      gl_axis_to_quat ((float[]){0,1,0}, 3.14159265358979/4., v->quat);
      float q[4];
      gl_axis_to_quat ((float[]){1,0,0}, - 3.14159265358979/4., q);
      gl_add_quats(q, v->quat, v->quat);
    }
    else {
      fprintf (ferr, "view(): unknown camera '%s'\n", camera);
      exit (1);
    }
  }
  else if (theta || phi || psi) {
    v->gfsview = false;
    float q[4];
    gl_axis_to_quat ((float[]){1,0,0}, - phi, q);
    if (relative) {
      float q1[4];
      gl_axis_to_quat ((float[]){0,1,0}, theta, q1);
      gl_add_quats(q, q1, q1);
      float q2[4];
      gl_axis_to_quat ((float[]){0,0,1}, psi, q2);
      gl_add_quats(q1, q2, q2);
      gl_add_quats(q2, v->quat, v->quat);
    }
    else {
      gl_axis_to_quat ((float[]){0,1,0}, theta, v->quat);
      gl_add_quats(q, v->quat, v->quat);
      gl_axis_to_quat ((float[]){0,0,1}, psi, q);
      gl_add_quats(q, v->quat, v->quat);
    }
  }

  if (map)
    v->map = map;

  if (p1x || p1y || p2x || p2y) {
    float q[4];
    gl_trackball(q, p1x, p1y, p2x, p2y);
    gl_add_quats (q, v->quat, v->quat);
  }

  if (far > near) {
    v->tz = tz;
    v->far = far;
    v->near = near;
  }

  if (res)
    v->res = res;

  if ((width && width != v->width) ||
      (height && height != v->height) ||
      (samples && samples != v->samples)) {
    v->width = v->width/v->samples;
    v->height = v->height/v->samples;
    if (width) v->width = width;
    if (height) v->height = height;
    if (samples) v->samples = samples;
    v->width *= v->samples;
    v->height *= v->samples;
    framebuffer_destroy (v->fb);


    disable_fpe (FE_DIVBYZERO|FE_INVALID);

    v->fb = framebuffer_new (v->width, v->height);
    init_gl();

    enable_fpe (FE_DIVBYZERO|FE_INVALID);
  }

  if (cache > 0) {
    v->cache = pcalloc (1, sizeof (cexpr),__func__,__FILE__,__LINE__);
    v->maxlen = cache;
  }

  clear();
}







void macro_translate (float x, float y, float z)
{
  {
    redraw ( false);
    bview * _view = draw();
    glMatrixMode (0x1700);
    glPushMatrix();
    glTranslatef (x, y, z);
    gl_get_frustum (&_view->frustum);

    ;

    glMatrixMode (0x1700);
    glPopMatrix();
    gl_get_frustum (&_view->frustum);
  }
}
#line 240 "/home/pwachara/basilisk/src/draw.h"
void macro_mirror (coord n, double alpha)
{
  {
    redraw ( false);
    bview * _view = draw();
    {
      glMatrixMode (0x1700);
      glPushMatrix();
      normalize (&n);
      GLfloat s[16], t[16];
      s[0] = 1. - 2.*n.x*n.x;
      s[1] = - 2.*n.x*n.y; s[2] = - 2.*n.x*n.z;
      s[3] = 0.;
      s[4] = s[1];
      s[5] = 1. - 2.*n.y*n.y; s[6] = - 2.*n.y*n.z;
      s[7] = 0.;
      s[8] = s[2]; s[9] = s[6]; s[10] = 1. - 2.*n.z*n.z;
      s[11] = 0.;
      s[12] = 0.; s[13] = 0.; s[14] = 0.;
      s[15] = 1.;

      t[0] = 1.; t[1] = 0.; t[2] = 0.; t[3] = 0.;
      t[4] = 0.; t[5] = 1.; t[6] = 0.; t[7] = 0.;
      t[8] = 0.; t[9] = 0.; t[10] = 1.; t[11] = 0.;
      t[12] = - 2.*n.x*alpha;
      t[13] = - 2.*n.y*alpha;
      t[14] = - 2.*n.z*alpha;
      t[15] = 1.;
      matrix_multiply (s, t);
      glMultMatrixf (s);
      gl_get_frustum (&_view->frustum);
      _view->reversed = !_view->reversed;
    }

    ;

    {
      glMatrixMode (0x1700);
      glPopMatrix();
      gl_get_frustum (&_view->frustum);
      _view->reversed = !_view->reversed;
    }
  }
}







static void mapped_position (bview * view, coord * p, double * r)
{
  double x = p->x, y = p->y, z = p->z, rm = 0.;
  view->map (p);
  for (int i = -1; i <= 1; i += 2)
    for (int j = -1; j <= 1; j += 2)
      for (int k = -1; k <= 1; k += 2) {
 coord q = {x + i**r, y + j**r, z + k**r};
 view->map (&q);
 double pq = ( (p->x - q.x)*(p->x - q.x)) + ( (p->y - q.y)*(p->y - q.y)) + ( (p->z - q.z)*(p->z - q.z));
 if (pq > rm)
   rm = pq;
      }
  *r = sqrt (rm);
}

void macro_foreach_visible (bview * view, char flags, Reduce reductions)
{
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 309 "/home/pwachara/basilisk/src/draw.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 309 "/home/pwachara/basilisk/src/draw.h"
{    
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;



    
#line 314 "/home/pwachara/basilisk/src/draw.h"
double _r = Delta*0.87;

    coord _p = {x, y, z};
    if ((view)->map)
      mapped_position (view, &_p, &_r);
    if (VertexBuffer.visible &&
 !sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum))
      continue;
    if (is_leaf(cell) || point.level == (view)->maxlevel ||
 (VertexBuffer.visible &&
  sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res)) {
      if (is_active(cell) && is_local(cell))
 ;
      continue;
    }
  }} 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}

#line 330 "/home/pwachara/basilisk/src/draw.h"
}

void macro_foreach_visible_stencil (bview * view, char flags, Reduce reductions) {  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/draw.h", .line = 333, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 334 "/home/pwachara/basilisk/src/draw.h"
;    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }

#line 335 "/home/pwachara/basilisk/src/draw.h"
}
#line 346 "/home/pwachara/basilisk/src/draw.h"
static void glnormal3d (bview * view, double x, double y, double z) {

  if (view->gfsview || view->reversed)
    vertex_buffer_glNormal3d (- x, - y, - z);
  else
    vertex_buffer_glNormal3d (x, y, z);
}

void macro_foreach_visible_plane (bview * view, coord n1, double alpha1)
{
  {
    coord _n = {(n1).x, (n1).y, (n1).z};
    double _alpha = 0.9999999*(alpha1);
    {
      double norm = sqrt(( (_n.x)*(_n.x)) + ( (_n.y)*(_n.y)) + ( (_n.z)*(_n.z)));
      if (!norm)
 _n.z = 1.;
      else
 _n.x /= norm, _n.y /= norm, _n.z /= norm, _alpha /= norm;
    }
    glnormal3d (view, _n.x, _n.y, _n.z);
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 367 "/home/pwachara/basilisk/src/draw.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 367 "/home/pwachara/basilisk/src/draw.h"
{      
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;

      
#line 370 "/home/pwachara/basilisk/src/draw.h"
double _r = Delta*0.87, alpha = (_alpha - _n.x*x - _n.y*y - _n.z*z)/Delta;
      if (fabs(alpha) > 0.87 ||
   (VertexBuffer.visible &&
    !sphere_in_frustum (x, y, z, _r, &(view)->frustum)))
 continue;
      if (is_leaf(cell) ||
   (VertexBuffer.visible &&
    sphere_diameter (x, y, z, _r/L0, &(view)->frustum) < (view)->res)) {
 if (is_active(cell) && is_local(cell))
   ;
 continue;
      }
    }} 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}
  
#line 383 "/home/pwachara/basilisk/src/draw.h"
}
}


void macro_draw_lines (bview * view, float color[3], float lw)
{
  {
    glMatrixMode (0x1701);
    glPushMatrix();
    glTranslatef (0., 0., view->lc*view->fov/24.);
    vertex_buffer_glColor3f (color[0], color[1], color[2]);
    glLineWidth (view->samples*(lw > 0. ? lw : 1.));
    bool _reversed = view->reversed;
    view->reversed = false;
    ;
    glMatrixMode (0x1701);
    glPopMatrix();
    view->reversed = _reversed;
  }
}

static inline double interp (Point point, coord p, scalar col) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 405 "/home/pwachara/basilisk/src/draw.h"
return interpolate_linear (point, col
,        x + p.x*Delta, y + p.y*Delta, z + p.z*Delta);
}
#line 404
static void _stencil_interp (Point point,_stencil_undefined * p, scalar col) {int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
#line 405 "/home/pwachara/basilisk/src/draw.h"
_stencil_interpolate_linear (point, col
,NULL,NULL,NULL   );  
#line 405
return
;
}

static double evaluate_expression (Point point, Node * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 411 "/home/pwachara/basilisk/src/draw.h"
if (!(n)) qassert ("/home/pwachara/basilisk/src/draw.h", 411, "n");
  switch (n->type) {
  case '1': return n->d.value;
  case '+': return (evaluate_expression (point, n->e[0]) +
      evaluate_expression(point, n->e[1]));
  case '-': return (evaluate_expression (point, n->e[0]) -
      evaluate_expression(point, n->e[1]));
  case '*': return (evaluate_expression (point, n->e[0]) *
      evaluate_expression(point, n->e[1]));
  case '/': return (evaluate_expression (point, n->e[0]) /
      evaluate_expression(point, n->e[1]));
  case '^': return pow (evaluate_expression (point, n->e[0]),
   evaluate_expression(point, n->e[1]));
  case '>': return (evaluate_expression (point, n->e[0]) >
      evaluate_expression(point, n->e[1]));
  case '<': return (evaluate_expression (point, n->e[0]) <
      evaluate_expression(point, n->e[1]));
  case 'L': return (evaluate_expression (point, n->e[0]) <=
      evaluate_expression(point, n->e[1]));
  case 'G': return (evaluate_expression (point, n->e[0]) >=
      evaluate_expression(point, n->e[1]));
  case '=': return (evaluate_expression (point, n->e[0]) ==
      evaluate_expression(point, n->e[1]));
  case 'i': return (evaluate_expression (point, n->e[0]) !=
      evaluate_expression(point, n->e[1]));
  case 'O': return (evaluate_expression (point, n->e[0]) ||
      evaluate_expression(point, n->e[1]));
  case 'A': return (evaluate_expression (point, n->e[0]) &&
      evaluate_expression(point, n->e[1]));
  case '?': return (evaluate_expression (point, n->e[0]) ?
      evaluate_expression(point, n->e[1]) :
      evaluate_expression(point, n->e[2]));
  case 'm': return - evaluate_expression (point, n->e[0]);
  case 'f': return n->d.func (evaluate_expression (point, n->e[0]));
  case 'v': {
    scalar s = {n->s};
    int k[3] = {0,0,0};
    for (int i = 0; i < 3; i++)
      if (n->e[i])
 k[i] = evaluate_expression (point, n->e[i]);
    return val(s,k[0],k[1],k[2]);
  }
  case 'D': return Delta;
  case 'x': return x;
  case 'y': return y;
  case 'z': return z;
  default:
    fprintf (ferr, "unknown operation type '%c'\n", n->type);
    if (!(false)) qassert ("/home/pwachara/basilisk/src/draw.h", 459, "false");
  }
  return undefined;
}
#line 409
static void _stencil_evaluate_expression (Point point, Node * n)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
      
  
#line 412 "/home/pwachara/basilisk/src/draw.h"
switch (n->type) {
  case '1': return ;
  case '+': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 414
return  
;}
  case '-': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 416
return  
;}
  case '*': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 418
return  
;}
  case '/': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 420
return  
;}
  case '^': {_stencil_evaluate_expression (point, n->e[0]);
   _stencil_evaluate_expression(point, n->e[1]);
#line 422
return  
;}
  case '>': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 424
return  
;}
  case '<': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 426
return  
;}
  case 'L': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 428
return  
;}
  case 'G': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 430
return  
;}
  case '=': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 432
return  
;}
  case 'i': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 434
return  
;}
  case 'O': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 436
return  
;}
  case 'A': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
#line 438
return  
;}
  case '?': {_stencil_evaluate_expression (point, n->e[0]);
      _stencil_evaluate_expression(point, n->e[1]);
      _stencil_evaluate_expression(point, n->e[2]);
#line 440
return   

;}
  case 'm': { _stencil_evaluate_expression (point, n->e[0]);return ;}
  case 'f': {_stencil_evaluate_expression (point, n->e[0]);return  ;}
  case 'v': {
    scalar s = {n->s};   
    
    for (int i = 0; i < 3; i++)
      if (n->e[i])
 { _stencil_evaluate_expression (point, n->e[i]); } 
_stencil_val(s,o_stencil,o_stencil,o_stencil);    return;
  }
  case 'D': return ;
  case 'x': return ;
  case 'y': return ;
  case 'z': return ; 
     
    
        
  }
  return ;
}

static bool assemble_node (Node * n)
{
  if (n->type == 'v') {
    char * id = n->d.id;
    scalar s = lookup_field (id);
    if (s.i >= 0)
      n->s = s.i;
    else {
      n->s = -1;
      if (!strcmp (id, "Delta"))
 reset_node_type (n, 'D');
      else if (!strcmp (id, "x"))
 reset_node_type (n, 'x');
      else if (!strcmp (id, "y"))
 reset_node_type (n, 'y');
      else if (!strcmp (id, "z"))
 reset_node_type (n, 'z');
      else {
 typedef struct { char * name; double val; } Constant;
 static Constant constants[] = {
   {"pi", 3.14159265358979 },
   {"nodata", 1e30f },
   {"HUGE", 1e30f },
   { NULL },
 };
 Constant * p = constants;
 while (p->name) {
   if (!strcmp (p->name, id)) {
     reset_node_type (n, '1');
     n->d.value = p->val;
     break;
   }
   p++;
 }
 if (n->type == 'v') {
   fprintf (ferr, "unknown identifier '%s'\n", id);
   return false;
 }
      }
    }
  }
  for (int i = 0; i < 3; i++)
    if (n->e[i] && !assemble_node (n->e[i]))
      return false;
  return true;
}

static scalar compile_expression (char * expr, bool * isexpr)
{
  *isexpr = false;
  if (!expr)
    return (scalar){-1};

  bview * view = get_view();
  scalar s;
  if (view->cache && (s = get_cexpr (view->cache, expr)).i >= 0)
    return s;

  Node * node = parse_node (expr);
  if (node == NULL) {
    fprintf (ferr, "'%s': syntax error\n", expr);
    return (scalar){-1};
  }
  if (!assemble_node (node)) {
    free_node (node);
    return (scalar){-1};
  }
  if (node->type == 'v' && node->e[0] == NULL) {
    scalar s = {node->s};
    if (_attribute[s.i].block > 0) {
      free_node (node);
      return s;
    }
  }
  s = new_scalar("s");
  pfree (_attribute[s.i].name,__func__,__FILE__,__LINE__);
  _attribute[s.i].name = pstrdup (expr,__func__,__FILE__,__LINE__);  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/draw.h", .line = 541, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 542 "/home/pwachara/basilisk/src/draw.h"
{ _stencil_evaluate_expression (point, node);_stencil_val_a(s,0,0,0); }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 542 "/home/pwachara/basilisk/src/draw.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 542 "/home/pwachara/basilisk/src/draw.h"
val(s,0,0,0) = evaluate_expression (point, node);}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
  
#line 543 "/home/pwachara/basilisk/src/draw.h"
restriction (((scalar[]){s,{-1}}));
  free_node (node);

  if (view->cache)
    view->cache = add_cexpr (view->cache, view->maxlen, expr, s);
  else
    *isexpr = true;
  return s;
}
#line 614 "/home/pwachara/basilisk/src/draw.h"
void macro_colorized (float fc[3], bool constant_color,
   double cmap[127][3], bool use_texture)
{

  if (use_texture) {
    GLfloat texture[3*256];
    for (int i = 0; i < 256; i++) {
      Color j = colormap_color (cmap, i/255., 0, 1);
      texture[3*i] = j.r/255.;
      texture[3*i + 1] = j.g/255.;
      texture[3*i + 2] = j.b/255.;
    }
    glTexImage1D (0x0DE0, 0, 0x1907, 256,0, 0x1907, 0x1406, texture);
    glTexParameteri (0x0DE0, 0x2801, 0x2601);
    glTexParameteri (0x0DE0, 0x2800, 0x2601);
    glTexParameteri (0x0DE0, 0x2802, 0x812F);
    glTexParameteri (0x0DE0, 0x2803, 0x812F);
    glEnable (0x0DE0);
  }
  if (constant_color)
    vertex_buffer_glColor3f (fc[0], fc[1], fc[2]);

  ;

  glDisable (0x0DE0);
}
#line 666 "/home/pwachara/basilisk/src/draw.h"
     
bool colorbar (Colormap map, float size, float pos[2],
        char * label, double lscale, double min,
        double max, bool horizontal, bool border,
        bool mid, float lc[3], float lw, float fsize,
        char * format, int levels)
{tracing("colorbar","/home/pwachara/basilisk/src/draw.h",667);
  bview * view = draw();
  glDisable (0x0B50);
  glMatrixMode (0x1701);
  glPushMatrix();
  glLoadIdentity();
  glMatrixMode (0x1700);
  glPushMatrix();
  glLoadIdentity();

  float fheight = gl_StrokeHeight();
  if (!size)
    size = 15;
  float width = 2./size;
  if (levels < 1) levels = 1;
  float h = 0, height = 4*width, dh = height/levels;
  glTranslatef (pos[0], pos[1], 0);


  double cmap [127][3];
  (* map) (cmap);
  vertex_buffer_glBegin(0x0007);
  for (int i = 0; i < levels; i++) {
    Color c = colormap_color (cmap, (float)i/(levels - 1), 0, 1);
    vertex_buffer_glColor3f (c.r/255., c.g/255., c.b/255.);
    if (horizontal) {
      vertex_buffer_glVertex2d (h + dh, 0);
      vertex_buffer_glVertex2d (h + dh, width);
      vertex_buffer_glVertex2d (h, width);
      vertex_buffer_glVertex2d (h, 0);
    } else {
      vertex_buffer_glVertex2d (0, h + dh);
      vertex_buffer_glVertex2d (width, h + dh);
      vertex_buffer_glVertex2d (width, h);
      vertex_buffer_glVertex2d (0, h);
    }
    h += dh;
    view->ni++;
  }
  vertex_buffer_glEnd();
  glLineWidth (view->samples*(lw > 0. ? lw : 1.));
  vertex_buffer_glColor3f (lc[0], lc[1], lc[2]);


  if (border) {
    vertex_buffer_glBegin (0x0002);
    vertex_buffer_glVertex2d (0, 0);
    if (horizontal) {
      vertex_buffer_glVertex2d (0, width);
      vertex_buffer_glVertex2d (height, width);
      vertex_buffer_glVertex2d (height, 0);
    } else {
      vertex_buffer_glVertex2d (width, 0);
      vertex_buffer_glVertex2d (width, height);
      vertex_buffer_glVertex2d (0, height);
    }
    vertex_buffer_glEnd();
  }


  float fwidth = gl_StrokeWidth ('1');
  if (!fsize)
    fsize = 20;
  float hscale = 2./(fsize*fwidth), vscale = hscale*view->width/view->height;
  char str[99];
  vertex_buffer_glColor3f (lc[0], lc[1], lc[2]);
  if (horizontal)
    glTranslatef (0, -(fheight/(view->height)), 0);
  else
    glTranslatef (width, -(fheight/(3*view->height)), 0);
  glScalef (hscale, vscale, 1.);
  sprintf (str, format, min);
  if (min > -1e30f) {
    glPushMatrix();
    if (horizontal)
      glTranslatef (-fwidth*(strlen(str) - 1)/2, 0, 0);
    glScalef (lscale, lscale, 1.);
    gl_StrokeString (str);
    glPopMatrix();
  }
  if (horizontal)
    glTranslatef (height/hscale,0, 0);
  else
    glTranslatef (0, height/vscale, 0);
  sprintf (str, format, max);
  if (max < 1e30f) {
    glPushMatrix();
    if (horizontal)
      glTranslatef (-fwidth*(strlen(str) - 1)/2, 0, 0);
    glScalef (lscale, lscale, 1.);
    gl_StrokeString (str);
    glPopMatrix();
  }

  if (mid) {
    sprintf (str, format, (min + max)/2);
    glPushMatrix();
    if (horizontal)
      glTranslatef (-height/(2*hscale) - fwidth*(strlen(str) - 1)/2,0, 0);
    else
      glTranslatef (0, -height/(2*vscale), 0);
    glScalef (lscale, lscale, 1.);
    gl_StrokeString (str);
    glPopMatrix();
  }

  if (horizontal)
    glTranslatef (-height/(2*hscale) - lscale*fwidth*(strlen(label) - 1)/2, width/vscale, 0);
  else
    glTranslatef (-width/hscale, 0, 0);

  glScalef (lscale, lscale, 1.);
  glTranslatef (0, fheight, 0);
  gl_StrokeString (label);

  glMatrixMode (0x1700);
  glPopMatrix();
  glMatrixMode (0x1701);
  glPopMatrix();
  {end_tracing("colorbar","/home/pwachara/basilisk/src/draw.h",791);return true;}
end_tracing("colorbar","/home/pwachara/basilisk/src/draw.h",792);}
#line 811 "/home/pwachara/basilisk/src/draw.h"
static bool cfilter (Point point, scalar c, double cmin)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
  
#line 813 "/home/pwachara/basilisk/src/draw.h"
double cmin1 = 4.*cmin;
  if (val(c,0,0,0) <= cmin) {
    
      if (val(c,1,0,0) >= 1. - cmin1 || val(c,-1,0,0) >= 1. - cmin1)
 return true;      
#line 816
if (val(c,0,1,0) >= 1. - cmin1 || val(c,0,-1,0) >= 1. - cmin1)
 return true;      
#line 816
if (val(c,0,0,1) >= 1. - cmin1 || val(c,0,0,-1) >= 1. - cmin1)
 return true;
    return false;
  }
  if (val(c,0,0,0) >= 1. - cmin) {
    
      if (val(c,1,0,0) <= cmin1 || val(c,-1,0,0) <= cmin1)
 return true;      
#line 822
if (val(c,0,1,0) <= cmin1 || val(c,0,-1,0) <= cmin1)
 return true;      
#line 822
if (val(c,0,0,1) <= cmin1 || val(c,0,0,-1) <= cmin1)
 return true;
    return false;
  }
  int n = 0;
  double min = 1e30f, max = - 1e30f;  
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
#line 828 "/home/pwachara/basilisk/src/draw.h"
{
    if (val(c,0,0,0) > cmin && val(c,0,0,0) < 1. - cmin && ++n >= (1 << 3))
      return true;
    if (val(c,0,0,0) > max) max = val(c,0,0,0);
    if (val(c,0,0,0) < min) min = val(c,0,0,0);
  } 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
  
#line 834 "/home/pwachara/basilisk/src/draw.h"
return max - min > 0.5;
}
#line 811 "/home/pwachara/basilisk/src/draw.h"
static void _stencil_cfilter (Point point, scalar c,_stencil_undefined * cmin)
{int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;   
  
#line 814 "/home/pwachara/basilisk/src/draw.h"
_stencil_val(c,0,0,0); {
    
      {_stencil_val(c,1,0,0); _stencil_val(c,-1,0,0); 
           }      
#line 816
{_stencil_val(c,0,1,0); _stencil_val(c,0,-1,0); 
           }      
#line 816
{_stencil_val(c,0,0,1); _stencil_val(c,0,0,-1); 
           } 
    
  }
_stencil_val(c,0,0,0); {
    
      {_stencil_val(c,1,0,0); _stencil_val(c,-1,0,0); 
       }      
#line 822
{_stencil_val(c,0,1,0); _stencil_val(c,0,-1,0); 
       }      
#line 822
{_stencil_val(c,0,0,1); _stencil_val(c,0,0,-1); 
       } 
    
  }  
#line 35 "/home/pwachara/basilisk/src/grid/neighbors.h"
{
    const int _nn = 1;
    const int _i = point.i, _j = point.j, _k = point.k;
    for (int _l = - _nn; _l <= _nn; _l++) {
      point.i = _i + _l;
      for (int _m = - _nn; _m <= _nn; _m++) {
 point.j = _j + _m;
 for (int _n = - _nn; _n <= _nn; _n++) {
   point.k = _k + _n;   
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2; 
#line 828 "/home/pwachara/basilisk/src/draw.h"
{
_stencil_val(c,0,0,0); _stencil_val(c,0,0,0);

_stencil_val(c,0,0,0); { _stencil_val(c,0,0,0); }
_stencil_val(c,0,0,0); { _stencil_val(c,0,0,0); }  
} 
#line 46 "/home/pwachara/basilisk/src/grid/neighbors.h"
}
      }
    }
    point.i = _i; point.j = _j; point.k = _k;
  }
  
#line 834 "/home/pwachara/basilisk/src/draw.h"
return     ;
}

static void glvertex3d (bview * view, double x, double y, double z) {
  if (view->map) {
    coord p = {x, y, z};
    view->map (&p);
    vertex_buffer_glVertex3d (p.x, p.y, p.z);
  }
  else
    vertex_buffer_glVertex3d (x, y, z);
}
#line 895 "/home/pwachara/basilisk/src/draw.h"
     
bool draw_vof (char * c, char * s, bool edges,
        double larger, int filled,
        char * color,
        double min, double max, double spread,
        bool linear,
        Colormap map,
        float fc[3], float lc[3], float lw,
        bool expr,
        bool cbar, float size, float pos[2], char * label, double lscale, bool horizontal, bool border, bool mid, float fsize, char * format, int levels)
{tracing("draw_vof","/home/pwachara/basilisk/src/draw.h",896);
  scalar d = lookup_field (c);
  if (d.i < 0) {
    fprintf (ferr, "draw_vof(): no field named '%s'\n", c);
    {end_tracing("draw_vof","/home/pwachara/basilisk/src/draw.h",909);return false;}
  }
  vector fs = lookup_vector (s);

  scalar col = {-1}; if (color && strcmp (color, "level")) { col = compile_expression (color, &expr); if (col.i < 0) {end_tracing("draw_vof","/home/pwachara/basilisk/src/draw.h",913);return false;} } double cmap[127][3]; if (color) { if (min == 0 && max == 0) { if (col.i < 0) min = 0, max = depth(); else { stats s = statsf (col); double avg = s.sum/s.volume; if (spread < 0.) min = s.min, max = s.max; else { if (!spread) spread = 5.; min = avg - spread*s.stddev; max = avg + spread*s.stddev; } } } if (!map) map = jet; (* map) (cmap); } if ((3 > 2 || linear) && !fc[0] && !fc[1] && !fc[2]) fc[0] = fc[1] = fc[2] = 1.; if (cbar) colorbar (map, size, pos, label, lscale, min, max, horizontal, border, mid, lc, lw, fsize, format, levels);;

  double cmin = 1e-3;
#line 926 "/home/pwachara/basilisk/src/draw.h"
  bview * view = draw();
#line 1004 "/home/pwachara/basilisk/src/draw.h"
  if (!larger)
    larger = edges || (color && !linear) ? 1. : 1.1;
  if (edges)
#line 388
{
  {
    glMatrixMode (0x1701);
    glPushMatrix();
    glTranslatef (0., 0., view->lc*view->fov/24.);
    vertex_buffer_glColor3f (lc[0], lc[1], lc[2]);
    glLineWidth (view->samples*(lw > 0. ? lw : 1.));
    bool _reversed = view->reversed;
    view->reversed = false; 
#line 1007
{      
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/draw.h", .line = 1008, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
 
#line 1009 "/home/pwachara/basilisk/src/draw.h"
{_stencil_cfilter (point, d, NULL); {  
    _stencil_facet_normal (point, d, fs);     
   _stencil_val(d,0,0,0);        
   
      
             
     
             
      
       
     
     
    
 } }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 308 "/home/pwachara/basilisk/src/draw.h"
{
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 309 "/home/pwachara/basilisk/src/draw.h"
{    
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;



    
#line 314 "/home/pwachara/basilisk/src/draw.h"
double _r = Delta*0.87;

    coord _p = {x, y, z};
    if ((view)->map)
      mapped_position (view, &_p, &_r);
    if (VertexBuffer.visible &&
 !sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum))
      continue;
    if (is_leaf(cell) || point.level == (view)->maxlevel ||
 (VertexBuffer.visible &&
  sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res)) {
      if (is_active(cell) && is_local(cell))
 
#line 1009
if (cfilter (point, d, cmin)) {
   coord n = facet_normal (point, d, fs);
   double alpha = plane_alpha (val(d,0,0,0), n);
   coord v[12];
   int m = facets (n, alpha, v, larger);
   if (m > 2) {
     vertex_buffer_glBegin (0x0002);
     for (int i = 0; i < m; i++)
       glvertex3d (view,
     x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
     vertex_buffer_glEnd ();
     view->ni++;
   }
 }      
#line 327
continue;
    }
  } 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}

#line 330 "/home/pwachara/basilisk/src/draw.h"
}
    
#line 1023
}    
#line 398
glMatrixMode (0x1701);
    glPopMatrix();
    view->reversed = _reversed;
  }
}
  
#line 1024
else
#line 616
{

  if ((
#line 1025
!VertexBuffer.color && color && linear && col.i >= 0
#line 618
)) {
    GLfloat texture[3*256];
    for (int i = 0; i < 256; i++) {
      Color j = colormap_color (cmap, i/255., 0, 1);
      texture[3*i] = j.r/255.;
      texture[3*i + 1] = j.g/255.;
      texture[3*i + 2] = j.b/255.;
    }
    glTexImage1D (0x0DE0, 0, 0x1907, 256,0, 0x1907, 0x1406, texture);
    glTexParameteri (0x0DE0, 0x2801, 0x2601);
    glTexParameteri (0x0DE0, 0x2800, 0x2601);
    glTexParameteri (0x0DE0, 0x2802, 0x812F);
    glTexParameteri (0x0DE0, 0x2803, 0x812F);
    glEnable (0x0DE0);
  }
  if ((
#line 1025
!VertexBuffer.color || !color
#line 633
))
    vertex_buffer_glColor3f (fc[0], fc[1], fc[2]); 
#line 1025
{      
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/draw.h", .line = 1026, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
 
#line 1027 "/home/pwachara/basilisk/src/draw.h"
{_stencil_cfilter (point, d, NULL); {  
    _stencil_facet_normal (point, d, fs);     
   _stencil_val(d,0,0,0);        
   
    
{    
     
           {
       if (linear) {
  if (color && linear && col.i >= 0) { if (VertexBuffer.color) {        _stencil_interp (point,NULL , col);     } else {    _stencil_interp (point,NULL , col);                                   } }
       }
       else {
  if (color && (!linear || col.i < 0)) {               _stencil_val(col,0,0,0);     }
       }        
          
       
       
     } 
     
     
   } 
} }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 308 "/home/pwachara/basilisk/src/draw.h"
{
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 309 "/home/pwachara/basilisk/src/draw.h"
{    
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;



    
#line 314 "/home/pwachara/basilisk/src/draw.h"
double _r = Delta*0.87;

    coord _p = {x, y, z};
    if ((view)->map)
      mapped_position (view, &_p, &_r);
    if (VertexBuffer.visible &&
 !sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum))
      continue;
    if (is_leaf(cell) || point.level == (view)->maxlevel ||
 (VertexBuffer.visible &&
  sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res)) {
      if (is_active(cell) && is_local(cell))
 
#line 1027
if (cfilter (point, d, cmin)) {
   coord n = facet_normal (point, d, fs);
   double alpha = plane_alpha (val(d,0,0,0), n);
   coord v[12];
   int m = facets (n, alpha, v, larger);
   if (m > 2) {
     vertex_buffer_glBegin (0x0009);
     for (int i = 0; i < m; i++) {
       if (linear) {
  if (color && linear && col.i >= 0) { if (VertexBuffer.color) { Color b = colormap_color (cmap, interp (point, v[i], col), min, max); vertex_buffer_glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = interp (point, v[i], col); if (max > min) glTexCoord1d (( (((_v) - min)/(max - min)) < 0. ? 0. : (((_v) - min)/(max - min)) > 1. ? 1. : (((_v) - min)/(max - min)))); else glTexCoord1d (0.); } };
       }
       else {
  if (color && (!linear || col.i < 0)) { Color b = colormap_color (cmap, col.i < 0 ? (double) level : val(col,0,0,0), min, max); vertex_buffer_glColor3f (b.r/255., b.g/255., b.b/255.); };
       }
       glnormal3d (view, n.x, n.y, n.z);
       glvertex3d (view,
     x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
     }
     vertex_buffer_glEnd ();
     view->ni++;
   }
 }      
#line 327
continue;
    }
  } 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}

#line 330 "/home/pwachara/basilisk/src/draw.h"
}
    
#line 1049
}  
#line 638
glDisable (0x0DE0);
}
#line 1060 "/home/pwachara/basilisk/src/draw.h"
  if (expr) delete(((scalar[]){col,{-1}}));
  {end_tracing("draw_vof","/home/pwachara/basilisk/src/draw.h",1061);return true;}
end_tracing("draw_vof","/home/pwachara/basilisk/src/draw.h",1062);}
#line 1073 "/home/pwachara/basilisk/src/draw.h"
     
bool isoline (char * phi,
       double val,
       int n,
       bool edges,
       double larger, int filled,
       char * color,
       double min, double max, double spread,
       bool linear,
       Colormap map,
       float fc[3], float lc[3], float lw,
       bool expr,
       bool cbar, float size, float pos[2], char * label, double lscale, bool horizontal, bool border, bool mid, float fsize, char * format, int levels)
{tracing("isoline","/home/pwachara/basilisk/src/draw.h",1074);
#line 1114 "/home/pwachara/basilisk/src/draw.h"
  if (!(false)) qassert ("/home/pwachara/basilisk/src/draw.h", 1114, "false");

  {end_tracing("isoline","/home/pwachara/basilisk/src/draw.h",1116);return true;}
end_tracing("isoline","/home/pwachara/basilisk/src/draw.h",1117);}
#line 1130 "/home/pwachara/basilisk/src/draw.h"
     
bool cells (coord n, double alpha,
     float lc[3], float lw)
{tracing("cells","/home/pwachara/basilisk/src/draw.h",1131);
  bview * view = draw();  
#line 389
{
    glMatrixMode (0x1701);
    glPushMatrix();
    glTranslatef (0., 0., view->lc*view->fov/24.);
    vertex_buffer_glColor3f (lc[0], lc[1], lc[2]);
    glLineWidth (view->samples*(lw > 0. ? lw : 1.));
    bool _reversed = view->reversed;
    view->reversed = false; 
#line 1135
{
#line 355
{
  {
    coord _n = {(n).x, (n).y, (n).z};
    double _alpha = 0.9999999*(alpha);
    {
      double norm = sqrt(( (_n.x)*(_n.x)) + ( (_n.y)*(_n.y)) + ( (_n.z)*(_n.z)));
      if (!norm)
 _n.z = 1.;
      else
 _n.x /= norm, _n.y /= norm, _n.z /= norm, _alpha /= norm;
    }
    glnormal3d (view, _n.x, _n.y, _n.z);
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 367 "/home/pwachara/basilisk/src/draw.h"
{      
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;

      
#line 370 "/home/pwachara/basilisk/src/draw.h"
double _r = Delta*0.87, alpha = (_alpha - _n.x*x - _n.y*y - _n.z*z)/Delta;
      if (fabs(alpha) > 0.87 ||
   (VertexBuffer.visible &&
    !sphere_in_frustum (x, y, z, _r, &(view)->frustum)))
 continue;
      if (is_leaf(cell) ||
   (VertexBuffer.visible &&
    sphere_diameter (x, y, z, _r/L0, &(view)->frustum) < (view)->res)) {
 if (is_active(cell) && is_local(cell)) 
#line 1147
{
      coord v[12];
      int m = facets (n, alpha, v, 1.);
      if (m > 2) {
 vertex_buffer_glBegin (0x0002);
 for (int i = 0; i < m; i++)
   glvertex3d (view, x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
 vertex_buffer_glEnd ();
 view->ni++;
      }
    } 
#line 380
continue;
      }
    } 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}
  
#line 383 "/home/pwachara/basilisk/src/draw.h"
}
}

  
#line 1159
}    
#line 398
glMatrixMode (0x1701);
    glPopMatrix();
    view->reversed = _reversed;
  }
  
#line 1160
{end_tracing("cells","/home/pwachara/basilisk/src/draw.h",1160);return true;}
end_tracing("cells","/home/pwachara/basilisk/src/draw.h",1161);}






     
bool vectors (char * u, double scale, float lc[3], float lw, int level)
{tracing("vectors","/home/pwachara/basilisk/src/draw.h",1169);
#line 1210 "/home/pwachara/basilisk/src/draw.h"
  fprintf (ferr, "vectors() is not implemented in 3D yet\n");

  {end_tracing("vectors","/home/pwachara/basilisk/src/draw.h",1212);return true;}
end_tracing("vectors","/home/pwachara/basilisk/src/draw.h",1213);}
#line 1233 "/home/pwachara/basilisk/src/draw.h"
     
bool squares (char * color,
       char * z,
       double min, double max, double spread,
       bool linear,
       Colormap map,
       float fc[3], float lc[3],
       bool expr,

       coord n,
       double alpha,
       float lw,
       bool cbar, float size, float pos[2], char * label, double lscale, bool horizontal, bool border, bool mid, float fsize, char * format, int levels)
{tracing("squares","/home/pwachara/basilisk/src/draw.h",1234);
#line 1261 "/home/pwachara/basilisk/src/draw.h"
  scalar col = {-1}; if (color && strcmp (color, "level")) { col = compile_expression (color, &expr); if (col.i < 0) {end_tracing("squares","/home/pwachara/basilisk/src/draw.h",1261);return false;} } double cmap[127][3]; if (color) { if (min == 0 && max == 0) { if (col.i < 0) min = 0, max = depth(); else { stats s = statsf (col); double avg = s.sum/s.volume; if (spread < 0.) min = s.min, max = s.max; else { if (!spread) spread = 5.; min = avg - spread*s.stddev; max = avg + spread*s.stddev; } } } if (!map) map = jet; (* map) (cmap); } if ((3 > 2 || linear) && !fc[0] && !fc[1] && !fc[2]) fc[0] = fc[1] = fc[2] = 1.; if (cbar) colorbar (map, size, pos, label, lscale, min, max, horizontal, border, mid, lc, lw, fsize, format, levels);;
  scalar f = col;
  bview * view = draw();
  glShadeModel (0x1D01);
  if (linear) {    
#line 618
if ((
#line 1266
!VertexBuffer.color && color && linear && col.i >= 0
#line 618
)) {
    GLfloat texture[3*256];
    for (int i = 0; i < 256; i++) {
      Color j = colormap_color (cmap, i/255., 0, 1);
      texture[3*i] = j.r/255.;
      texture[3*i + 1] = j.g/255.;
      texture[3*i + 2] = j.b/255.;
    }
    glTexImage1D (0x0DE0, 0, 0x1907, 256,0, 0x1907, 0x1406, texture);
    glTexParameteri (0x0DE0, 0x2801, 0x2601);
    glTexParameteri (0x0DE0, 0x2800, 0x2601);
    glTexParameteri (0x0DE0, 0x2802, 0x812F);
    glTexParameteri (0x0DE0, 0x2803, 0x812F);
    glEnable (0x0DE0);
  }
  if ((
#line 1266
!VertexBuffer.color || !color
#line 633
))
    vertex_buffer_glColor3f (fc[0], fc[1], fc[2]); 
#line 1266
{
#line 355
{
  {
    coord _n = {(n).x, (n).y, (n).z};
    double _alpha = 0.9999999*(alpha);
    {
      double norm = sqrt(( (_n.x)*(_n.x)) + ( (_n.y)*(_n.y)) + ( (_n.z)*(_n.z)));
      if (!norm)
 _n.z = 1.;
      else
 _n.x /= norm, _n.y /= norm, _n.z /= norm, _alpha /= norm;
    }
    glnormal3d (view, _n.x, _n.y, _n.z);
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 367 "/home/pwachara/basilisk/src/draw.h"
{      
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;

      
#line 370 "/home/pwachara/basilisk/src/draw.h"
double _r = Delta*0.87, alpha = (_alpha - _n.x*x - _n.y*y - _n.z*z)/Delta;
      if (fabs(alpha) > 0.87 ||
   (VertexBuffer.visible &&
    !sphere_in_frustum (x, y, z, _r, &(view)->frustum)))
 continue;
      if (is_leaf(cell) ||
   (VertexBuffer.visible &&
    sphere_diameter (x, y, z, _r/L0, &(view)->frustum) < (view)->res)) {
 if (is_active(cell) && is_local(cell))
 
#line 1319
if (f.i < 0 || val(f,0,0,0) != 1e30f) {
   coord v[12];
   int m = facets (n, alpha, v, 1.);
   if (m > 2) {
     coord c = {0,0,0};
     for (int i = 0; i < m; i++)
       {
  c.x += v[i].x/m;  c.y += v[i].y/m;  c.z += v[i].z/m;}
     vertex_buffer_glBegin (0x0006);
     if (color && linear && col.i >= 0) { if (VertexBuffer.color) { Color b = colormap_color (cmap, interp (point, c, f), min, max); vertex_buffer_glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = interp (point, c, f); if (max > min) glTexCoord1d (( (((_v) - min)/(max - min)) < 0. ? 0. : (((_v) - min)/(max - min)) > 1. ? 1. : (((_v) - min)/(max - min)))); else glTexCoord1d (0.); } };
     glvertex3d (view, x + c.x*Delta, y + c.y*Delta, z + c.z*Delta);
     for (int i = 0; i < m; i++) {
       if (color && linear && col.i >= 0) { if (VertexBuffer.color) { Color b = colormap_color (cmap, interp (point, v[i], f), min, max); vertex_buffer_glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = interp (point, v[i], f); if (max > min) glTexCoord1d (( (((_v) - min)/(max - min)) < 0. ? 0. : (((_v) - min)/(max - min)) > 1. ? 1. : (((_v) - min)/(max - min)))); else glTexCoord1d (0.); } };
       glvertex3d (view,
     x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
     }
     if (color && linear && col.i >= 0) { if (VertexBuffer.color) { Color b = colormap_color (cmap, interp (point, v[0], f), min, max); vertex_buffer_glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = interp (point, v[0], f); if (max > min) glTexCoord1d (( (((_v) - min)/(max - min)) < 0. ? 0. : (((_v) - min)/(max - min)) > 1. ? 1. : (((_v) - min)/(max - min)))); else glTexCoord1d (0.); } };
     glvertex3d (view,
   x + v[0].x*Delta, y + v[0].y*Delta, z + v[0].z*Delta);
     vertex_buffer_glEnd ();
     view->ni++;
   }
 } 
#line 380
continue;
      }
    } 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}
  
#line 383 "/home/pwachara/basilisk/src/draw.h"
}
}

    
#line 1343
}  
#line 638
glDisable (0x0DE0);
  
#line 1344
}
  else {
#line 355
{
  {
    coord _n = {(n).x, (n).y, (n).z};
    double _alpha = 0.9999999*(alpha);
    {
      double norm = sqrt(( (_n.x)*(_n.x)) + ( (_n.y)*(_n.y)) + ( (_n.z)*(_n.z)));
      if (!norm)
 _n.z = 1.;
      else
 _n.x /= norm, _n.y /= norm, _n.z /= norm, _alpha /= norm;
    }
    glnormal3d (view, _n.x, _n.y, _n.z);
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 367 "/home/pwachara/basilisk/src/draw.h"
{      
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;

      
#line 370 "/home/pwachara/basilisk/src/draw.h"
double _r = Delta*0.87, alpha = (_alpha - _n.x*x - _n.y*y - _n.z*z)/Delta;
      if (fabs(alpha) > 0.87 ||
   (VertexBuffer.visible &&
    !sphere_in_frustum (x, y, z, _r, &(view)->frustum)))
 continue;
      if (is_leaf(cell) ||
   (VertexBuffer.visible &&
    sphere_diameter (x, y, z, _r/L0, &(view)->frustum) < (view)->res)) {
 if (is_active(cell) && is_local(cell))
      
#line 1364
if (f.i < 0 || val(f,0,0,0) != 1e30f) {
 coord v[12];
 int m = facets (n, alpha, v, 1.);
 if (m > 2) {
   vertex_buffer_glBegin (0x0009);
   for (int i = 0; i < m; i++) {
     if (color && (!linear || col.i < 0)) { Color b = colormap_color (cmap, col.i < 0 ? (double) level : val(col,0,0,0), min, max); vertex_buffer_glColor3f (b.r/255., b.g/255., b.b/255.); };
     glvertex3d (view,
   x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
   }
   vertex_buffer_glEnd ();
   view->ni++;
 }
      } 
#line 380
continue;
      }
    } 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}
  
#line 383 "/home/pwachara/basilisk/src/draw.h"
}
}

  
#line 1379
}
  if (expr) delete (((scalar[]){col,{-1}}));




  {end_tracing("squares","/home/pwachara/basilisk/src/draw.h",1385);return true;}
end_tracing("squares","/home/pwachara/basilisk/src/draw.h",1386);}
#line 1397 "/home/pwachara/basilisk/src/draw.h"
     
bool box (bool notics, float lc[3], float lw)
{tracing("box","/home/pwachara/basilisk/src/draw.h",1398);
  bview * view = draw();
  coord box[2] = {
    {X0, Y0, Z0},
    {X0 + L0,
     Y0 + L0*Dimensions.y/Dimensions.x

     , Z0 + L0*Dimensions.z/Dimensions.x

    }
  };
  coord e;
  double emin = 1e30f;
   {
    e.x = box[1].x - box[0].x;
    if (e.x < emin)
      emin = e.x;
  } 
#line 1412
{
    e.y = box[1].y - box[0].y;
    if (e.y < emin)
      emin = e.y;
  } 
#line 1412
{
    e.z = box[1].z - box[0].z;
    if (e.z < emin)
      emin = e.z;
  }  
#line 389
{
    glMatrixMode (0x1701);
    glPushMatrix();
    glTranslatef (0., 0., view->lc*view->fov/24.);
    vertex_buffer_glColor3f (lc[0], lc[1], lc[2]);
    glLineWidth (view->samples*(lw > 0. ? lw : 1.));
    bool _reversed = view->reversed;
    view->reversed = false; 
#line 1417
{

    float height = 0.5*gl_StrokeHeight();
    float width = gl_StrokeWidth ('1'), scale = emin/(60.*width), length;
    float Z1 = 3 == 2 ? 0. : box[0].z;
    char label[80];

    glMatrixMode (0x1700); 
#line 244 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = 0;
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
    for (_k = 2; _k < point.n.x + 2; _k++) {
      point.i = _k;

      for (point.j = 2; point.j < point.n.y + 2; point.j++)

 for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 1435 "/home/pwachara/basilisk/src/draw.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 1435 "/home/pwachara/basilisk/src/draw.h"
{
      for (int i = -1; i <= 1; i += 2) {
 vertex_buffer_glBegin (0x0002);
 glvertex3d (view, box[0].x, box[0].y, z + i*Delta/2.);
 glvertex3d (view, box[1].x, box[0].y, z + i*Delta/2.);
 glvertex3d (view, box[1].x, box[1].y, z + i*Delta/2.);
 glvertex3d (view, box[0].x, box[1].y, z + i*Delta/2.);
 vertex_buffer_glEnd ();
 view->ni++;
 vertex_buffer_glBegin (0x0001);
 for (int j = -1; j <= 1; j += 2) {
   glvertex3d (view, x + i*Delta/2., y + j*Delta/2., z - Delta/2.);
   glvertex3d (view, x + i*Delta/2., y + j*Delta/2., z + Delta/2.);
 }
 vertex_buffer_glEnd ();
 view->ni++;
      }
    }}    
#line 261 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}


    
#line 1455 "/home/pwachara/basilisk/src/draw.h"
if (!notics) {
      int nt = 8;
      for (int i = 0; i <= nt; i++) {
 glPushMatrix();
 glTranslatef (X0 + i*e.x/nt - height/2.*scale,
        Y0 - width/3.*scale, Z1);
 glRotatef (-90, 0, 0, 1);
 glScalef (scale, scale, scale);
 sprintf (label, "%g", X0 + i*e.x/nt);
 gl_StrokeString (label);
 glPopMatrix();

 glPushMatrix();
 sprintf (label, "%g", Y0 + i*e.y/nt);
 length = gl_StrokeLength (label);
 glTranslatef (X0 - (length + width/3.)*scale,
        Y0 + i*e.y/nt - height/2.*scale, Z1);
 glScalef (scale, scale, scale);
 gl_StrokeString (label);
 glPopMatrix();


 glPushMatrix();
 sprintf (label, "%g", Z0 + i*e.z/nt);
 length = gl_StrokeLength (label);
 glTranslatef (X0 - (length + width/3.)*scale,
        Y0, Z0 + i*e.z/nt + height/2.*scale);
 glRotatef (-90, 1, 0, 0);
 glScalef (scale, scale, scale);
 gl_StrokeString (label);
 glPopMatrix();

      }

      glPushMatrix();
      sprintf (label, "%g", X0 + e.x/2.);
      length = gl_StrokeLength (label);
      glTranslatef (X0 + e.x/2 - height*scale,
      Y0 - (length + 4.*width)*scale, Z1);
      glScalef (2.*scale, 2.*scale, 2.*scale);
      gl_StrokeString ("X");
      glPopMatrix();


      glPushMatrix();
      sprintf (label, "%g", Y0 + e.y/2.);
      length = gl_StrokeLength (label);
      glTranslatef (X0 - (length + 4.*width)*scale,
      Y0 + e.y/2. - height*scale, Z1);
      glScalef (2.*scale, 2.*scale, 2.*scale);
      gl_StrokeString ("Y");
      glPopMatrix();


      glPushMatrix();
      sprintf (label, "%g", Z0 + e.z/2.);
      length = gl_StrokeLength (label);
      glTranslatef (X0 - (length + 4.*width)*scale,
      Y0, Z0 + e.z/2. + height*scale);
      glRotatef (-90, 1, 0, 0);
      glScalef (2.*scale, 2.*scale, 2.*scale);
      gl_StrokeString ("Z");
      glPopMatrix();

    }
  }    
#line 398
glMatrixMode (0x1701);
    glPopMatrix();
    view->reversed = _reversed;
  }
  
#line 1521
{end_tracing("box","/home/pwachara/basilisk/src/draw.h",1521);return true;}
end_tracing("box","/home/pwachara/basilisk/src/draw.h",1522);}
#line 1535 "/home/pwachara/basilisk/src/draw.h"
     
bool isosurface (char * f,
   double v,

   char * color,
   double min, double max, double spread,
   bool linear,
   Colormap map,
   float fc[3], float lc[3], float lw,
   bool expr,
   bool cbar, float size, float pos[2], char * label, double lscale, bool horizontal, bool border, bool mid, float fsize, char * format, int levels)
{tracing("isosurface","/home/pwachara/basilisk/src/draw.h",1536);

  if (!f)
    {end_tracing("isosurface","/home/pwachara/basilisk/src/draw.h",1549);return false;}

  scalar ff = {-1};
  bool fexpr;
  if (strcmp (f, "level")) {
    ff = compile_expression (f, &fexpr);
    if (ff.i < 0)
      {end_tracing("isosurface","/home/pwachara/basilisk/src/draw.h",1556);return false;}
  }

  scalar col = {-1}; if (color && strcmp (color, "level")) { col = compile_expression (color, &expr); if (col.i < 0) {end_tracing("isosurface","/home/pwachara/basilisk/src/draw.h",1559);return false;} } double cmap[127][3]; if (color) { if (min == 0 && max == 0) { if (col.i < 0) min = 0, max = depth(); else { stats s = statsf (col); double avg = s.sum/s.volume; if (spread < 0.) min = s.min, max = s.max; else { if (!spread) spread = 5.; min = avg - spread*s.stddev; max = avg + spread*s.stddev; } } } if (!map) map = jet; (* map) (cmap); } if ((3 > 2 || linear) && !fc[0] && !fc[1] && !fc[2]) fc[0] = fc[1] = fc[2] = 1.; if (cbar) colorbar (map, size, pos, label, lscale, min, max, horizontal, border, mid, lc, lw, fsize, format, levels);;

  scalar  fv=new_vertex_scalar("fv");  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/draw.h", .line = 1562, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
    
#line 1563 "/home/pwachara/basilisk/src/draw.h"
{_stencil_val(ff,0,0,0); _stencil_val(ff,-1,0,0); _stencil_val(ff,0,-1,0); _stencil_val(ff,-1,-1,0);
     _stencil_val(ff,0,0,-1); _stencil_val(ff,-1,0,-1); _stencil_val(ff,0,-1,-1); _stencil_val(ff,-1,-1,-1);
#line 1563
_stencil_val_a(fv,0,0,0);         
}  
#line 338 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 912 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
#line 300
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 913
{
    int ig = -1; NOT_UNUSED(ig);

    int jg = -1; NOT_UNUSED(jg);


    int kg = -1; NOT_UNUSED(kg);
    
#line 1563 "/home/pwachara/basilisk/src/draw.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 1563 "/home/pwachara/basilisk/src/draw.h"
val(fv,0,0,0) = (val(ff,0,0,0) + val(ff,-1,0,0) + val(ff,0,-1,0) + val(ff,-1,-1,0) +
     val(ff,0,0,-1) + val(ff,-1,0,-1) + val(ff,0,-1,-1) + val(ff,-1,-1,-1))/8.;}  
#line 922 "/home/pwachara/basilisk/src/grid/multigrid.h"
}      
#line 317
}
  }
}

#line 923
}

  
#line 1566 "/home/pwachara/basilisk/src/draw.h"
vector  n=new_vector("n");  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/draw.h", .line = 1567, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);
    
#line 1568 "/home/pwachara/basilisk/src/draw.h"
{
      {_stencil_val(fs.x,0,0,0); _stencil_val(fs.x,1,0,0);_stencil_val(ff,1,0,0); _stencil_val(ff,-1,0,0); _stencil_val(fs.x,1,0,0);_stencil_val(ff,1,0,0); _stencil_val(ff,0,0,0); _stencil_val(fs.x,0,0,0);_stencil_val(ff,0,0,0); _stencil_val(ff,-1,0,0);_stencil_val_a(n.x,0,0,0);                }      {_stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,1,0);_stencil_val(ff,0,1,0); _stencil_val(ff,0,-1,0); _stencil_val(fs.y,0,1,0);_stencil_val(ff,0,1,0); _stencil_val(ff,0,0,0); _stencil_val(fs.y,0,0,0);_stencil_val(ff,0,0,0); _stencil_val(ff,0,-1,0);_stencil_val_a(n.y,0,0,0);                }      {_stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,1);_stencil_val(ff,0,0,1); _stencil_val(ff,0,0,-1); _stencil_val(fs.z,0,0,1);_stencil_val(ff,0,0,1); _stencil_val(ff,0,0,0); _stencil_val(fs.z,0,0,0);_stencil_val(ff,0,0,0); _stencil_val(ff,0,0,-1);_stencil_val_a(n.z,0,0,0);                }}    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)
    
#line 1568 "/home/pwachara/basilisk/src/draw.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 1568 "/home/pwachara/basilisk/src/draw.h"
{
      val(n.x,0,0,0) = (val(fs.x,0,0,0) && val(fs.x,1,0,0) ? (val(ff,1,0,0) - val(ff,-1,0,0))/(2.*Delta) : val(fs.x,1,0,0) ? (val(ff,1,0,0) - val(ff,0,0,0))/Delta : val(fs.x,0,0,0) ? (val(ff,0,0,0) - val(ff,-1,0,0))/Delta : 0.);      val(n.y,0,0,0) = (val(fs.y,0,0,0) && val(fs.y,0,1,0) ? (val(ff,0,1,0) - val(ff,0,-1,0))/(2.*Delta) : val(fs.y,0,1,0) ? (val(ff,0,1,0) - val(ff,0,0,0))/Delta : val(fs.y,0,0,0) ? (val(ff,0,0,0) - val(ff,0,-1,0))/Delta : 0.);      val(n.z,0,0,0) = (val(fs.z,0,0,0) && val(fs.z,0,0,1) ? (val(ff,0,0,1) - val(ff,0,0,-1))/(2.*Delta) : val(fs.z,0,0,1) ? (val(ff,0,0,1) - val(ff,0,0,0))/Delta : val(fs.z,0,0,0) ? (val(ff,0,0,0) - val(ff,0,0,-1))/Delta : 0.);}}      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}

  
#line 1571 "/home/pwachara/basilisk/src/draw.h"
bview * view = draw();
  glShadeModel (0x1D01);  
#line 618
if ((
#line 1573
!VertexBuffer.color && color && linear && col.i >= 0
#line 618
)) {
    GLfloat texture[3*256];
    for (int i = 0; i < 256; i++) {
      Color j = colormap_color (cmap, i/255., 0, 1);
      texture[3*i] = j.r/255.;
      texture[3*i + 1] = j.g/255.;
      texture[3*i + 2] = j.b/255.;
    }
    glTexImage1D (0x0DE0, 0, 0x1907, 256,0, 0x1907, 0x1406, texture);
    glTexParameteri (0x0DE0, 0x2801, 0x2601);
    glTexParameteri (0x0DE0, 0x2800, 0x2601);
    glTexParameteri (0x0DE0, 0x2802, 0x812F);
    glTexParameteri (0x0DE0, 0x2803, 0x812F);
    glEnable (0x0DE0);
  }
  if ((
#line 1573
!VertexBuffer.color || !color
#line 633
))
    vertex_buffer_glColor3f (fc[0], fc[1], fc[2]); 
#line 1573
{    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/draw.h", .line = 1574, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 1574 "/home/pwachara/basilisk/src/draw.h"
{  
       
       
_stencil_val(fv,0,1,1); _stencil_val(fv,1,1,1); _stencil_val(fv,1,1,0); _stencil_val(fv,0,1,0); 
#line 1576
_stencil_val(fv,0,0,1); _stencil_val(fv,1,0,1); _stencil_val(fv,1,0,0); _stencil_val(fv,0,0,0);       
      
         
            

{
 if (color && (!linear || col.i < 0)) {               _stencil_val(col,0,0,0);     } 
 
 for (int j = 0; j < 3; j++) {      
   
   
     { _stencil_interp (point,NULL , n.x); }     { _stencil_interp (point,NULL , n.y); }     { _stencil_interp (point,NULL , n.z); }    
   
   if (linear) {
     if (color && linear && col.i >= 0) { if (VertexBuffer.color) {        _stencil_interp (point,NULL , col);     } else {    _stencil_interp (point,NULL , col);                                   } }
   }
   else {
     if (color && (!linear || col.i < 0)) {               _stencil_val(col,0,0,0);     }
   }          
   
 } 
 
 
      }
    }    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 308 "/home/pwachara/basilisk/src/draw.h"
{
#line 126 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
{
  {





    Point root = {2,2,2,0};
#line 67
{
  {
    int ig = 0, jg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg);
    Point point = {0};





    int kg = 0; NOT_UNUSED(kg);
    struct { int l, i, j, k, stage; } stack[20];

    int _s = -1;
    { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; };
    while (_s >= 0) {
      int stage;
      { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; };
      if (!allocated (0,0,0))
 continue;
      switch (stage) {
      case 0: { 
#line 309 "/home/pwachara/basilisk/src/draw.h"
{    
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;



    
#line 314 "/home/pwachara/basilisk/src/draw.h"
double _r = Delta*0.87;

    coord _p = {x, y, z};
    if ((view)->map)
      mapped_position (view, &_p, &_r);
    if (VertexBuffer.visible &&
 !sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum))
      continue;
    if (is_leaf(cell) || point.level == (view)->maxlevel ||
 (VertexBuffer.visible &&
  sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res)) {
      if (is_active(cell) && is_local(cell)) 
#line 1574
{
      double val[8] = {
 val(fv,0,0,0), val(fv,1,0,0), val(fv,1,0,1), val(fv,0,0,1),
 val(fv,0,1,0), val(fv,1,1,0), val(fv,1,1,1), val(fv,0,1,1)
      };
      double t[5][3][3];
      int nt = polygonize (val, v, t);
      for (int i = 0; i < nt; i++) {
 if (color && (!linear || col.i < 0)) { Color b = colormap_color (cmap, col.i < 0 ? (double) level : val(col,0,0,0), min, max); vertex_buffer_glColor3f (b.r/255., b.g/255., b.b/255.); };
 vertex_buffer_glBegin (0x0009);
 for (int j = 0; j < 3; j++) {
   coord v = {t[i][j][0], t[i][j][1], t[i][j][2]}, np;
   
     np.x = interp (point, v, n.x);     np.y = interp (point, v, n.y);     np.z = interp (point, v, n.z);
   glnormal3d (view, np.x, np.y, np.z);
   if (linear) {
     if (color && linear && col.i >= 0) { if (VertexBuffer.color) { Color b = colormap_color (cmap, interp (point, v, col), min, max); vertex_buffer_glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = interp (point, v, col); if (max > min) glTexCoord1d (( (((_v) - min)/(max - min)) < 0. ? 0. : (((_v) - min)/(max - min)) > 1. ? 1. : (((_v) - min)/(max - min)))); else glTexCoord1d (0.); } };
   }
   else {
     if (color && (!linear || col.i < 0)) { Color b = colormap_color (cmap, col.i < 0 ? (double) level : val(col,0,0,0), min, max); vertex_buffer_glColor3f (b.r/255., b.g/255., b.b/255.); };
   }
   glvertex3d (view, x + v.x*Delta_x, y + v.y*Delta_y, z + v.z*Delta_z);
 }
 vertex_buffer_glEnd ();
 view->ni++;
      }
    }      
#line 327
continue;
    }
  } 
#line 91 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
if (point.level < grid->depth) {
   { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; };
   { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; };
 }
 break;
      }
#line 106 "/home/pwachara/basilisk/src/grid/foreach_cell.h"
      case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;
      case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; };
 { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break;
      case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break;

      }
    }
  }
}
  
#line 137
}
}

#line 330 "/home/pwachara/basilisk/src/draw.h"
}
  
#line 1601
}  
#line 638
glDisable (0x0DE0);
  
#line 1602
if (expr) delete (((scalar[]){col,{-1}}));
  if (fexpr) delete (((scalar[]){ff,{-1}}));

  {delete((scalar*)((scalar[]){n.x,n.y,n.z,fv,{-1}}));{end_tracing("isosurface","/home/pwachara/basilisk/src/draw.h",1605);return true;}}delete((scalar*)((scalar[]){n.x,n.y,n.z,fv,{-1}}));
end_tracing("isosurface","/home/pwachara/basilisk/src/draw.h",1606);}
#line 1619 "/home/pwachara/basilisk/src/draw.h"
void travelling (double start, double end,
   float tx, float ty, float quat[4], float fov)
{
  static float stx, sty, squat[4], sfov;
  static double told = -1.;
  if (told < start && t >= start) {
    bview * view = get_view();
    stx = view->tx, sty = view->ty, sfov = view->fov;
    for (int i = 0; i < 4; i++)
      squat[i] = view->quat[i];
  }
  if (t >= start && t <= end)
    view ( (!tx ? stx : ((t - start)*(tx) + (end - t)*(stx))/(end - start)), (!ty ? sty : ((t - start)*(ty) + (end - t)*(sty))/(end - start))
, (!fov ? sfov : ((t - start)*(fov) + (end - t)*(sfov))/(end - start))
,
#line 52
(    float[4]) 
#line 1633
{(!quat[0] ? squat[0] : ((t - start)*(quat[0]) + (end - t)*(squat[0]))/(end - start)), (!quat[1] ? squat[1] : ((t - start)*(quat[1]) + (end - t)*(squat[1]))/(end - start)),
           (!quat[2] ? squat[2] : ((t - start)*(quat[2]) + (end - t)*(squat[2]))/(end - start)), (!quat[3] ? squat[3] : ((t - start)*(quat[3]) + (end - t)*(squat[3]))/(end - start))}
#line 52
, 
1., 1., 1., 
800, 800, 4,
(    float[3]) {0}, 
0., 0., 0., 
false, 
0., 0., 0., 
0., 
NULL, 
NULL, 
0, 
0., 0., 0., 0., 
NULL
#line 1634
);
  if (told < end && t >= end) {
    bview * view = get_view();
    stx = view->tx, sty = view->ty, sfov = view->fov;
    for (int i = 0; i < 4; i++)
      squat[i] = view->quat[i];
  }
  told = t;
}
#line 1659 "/home/pwachara/basilisk/src/draw.h"
     
bool draw_string (char * str,
    int pos,
    float size,
    float lc[3], float lw)

{tracing("draw_string","/home/pwachara/basilisk/src/draw.h",1660);
  bview * view = draw();

  glMatrixMode (0x1701);
  glPushMatrix();
  glLoadIdentity();

  glMatrixMode (0x1700);
  glPushMatrix();
  glLoadIdentity();

  vertex_buffer_glColor3f (lc[0], lc[1], lc[2]);
  glLineWidth (view->samples*(lw > 0. ? lw : 1.));

  float width = gl_StrokeWidth ('1'), height = gl_StrokeHeight();
  if (!size)
    size = 40;
  float hscale = 2./(size*width), vscale = hscale*view->width/view->height;
  float vmargin = width/2.*vscale;
  if (pos == 0)
    glTranslatef (-1., -1. + vmargin, 0.);
  else if (pos == 1)
    glTranslatef (-1., 1. - height*vscale, 0.);
  else if (pos == 2)
    glTranslatef (1. - strlen(str)*width*hscale, 1. - height*vscale, 0.);
  else
    glTranslatef (1. - strlen(str)*width*hscale, -1. + vmargin, 0.);
  glScalef (hscale, vscale, 1.);
  gl_StrokeString (str);

  glMatrixMode (0x1700);
  glPopMatrix();
  glMatrixMode (0x1701);
  glPopMatrix();

  {end_tracing("draw_string","/home/pwachara/basilisk/src/draw.h",1700);return true;}
end_tracing("draw_string","/home/pwachara/basilisk/src/draw.h",1701);}




     
bool labels (char * f,
      float lc[3], float lw)
{tracing("labels","/home/pwachara/basilisk/src/draw.h",1707);
#line 1738 "/home/pwachara/basilisk/src/draw.h"
  fprintf (ferr, "labels() is not implemented in 3D yet\n");
  {end_tracing("labels","/home/pwachara/basilisk/src/draw.h",1739);return false;}

end_tracing("labels","/home/pwachara/basilisk/src/draw.h",1741);}
#line 1752 "/home/pwachara/basilisk/src/draw.h"
     
bool lines (char * file, float lc[3], float lw)
{tracing("lines","/home/pwachara/basilisk/src/draw.h",1753);

  if (!(false)) qassert ("/home/pwachara/basilisk/src/draw.h", 1756, "false");
#line 1802 "/home/pwachara/basilisk/src/draw.h"
  {end_tracing("lines","/home/pwachara/basilisk/src/draw.h",1802);return true;}
end_tracing("lines","/home/pwachara/basilisk/src/draw.h",1803);}







#line 1 "draw_json.h"
#line 1 "/home/pwachara/basilisk/src/draw_json.h"

int _view_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"view\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"tx\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"ty\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"fov\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"quat\": { \"type\": \"pfloat\", \"cardinality\": 4, \"value\": [%f,%f,%f,%f] }", 0., 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"sx\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"sy\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"sz\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"width\": { \"type\": \"punsigned\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"height\": { \"type\": \"punsigned\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"samples\": { \"type\": \"punsigned\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"bg\": { \"type\": \"pfloat\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"theta\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"phi\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"psi\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"relative\": { \"type\": \"pbool\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"tz\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"near\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"far\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"res\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"camera\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"cache\": { \"type\": \"pint\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"p1x\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"p1y\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"p2x\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"p2y\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _draw_vof_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"draw_vof\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"c\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"s\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"edges\": { \"type\": \"pbool\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"larger\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"filled\": { \"type\": \"pint\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"color\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"min\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"max\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"spread\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"linear\": { \"type\": \"pbool\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"fc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lw\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _isoline_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"isoline\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"phi\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"val\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"n\": { \"type\": \"pint\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"edges\": { \"type\": \"pbool\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"larger\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"filled\": { \"type\": \"pint\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"color\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"min\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"max\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"spread\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"linear\": { \"type\": \"pbool\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"fc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lw\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _cells_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"cells\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"n\": { \"type\": \"pdouble\", \"cardinality\": 3, \"value\": [%lf,%lf,%lf] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"alpha\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lw\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _vectors_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"vectors\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"u\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"scale\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lw\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"level\": { \"type\": \"pint\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _squares_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"squares\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"color\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"z\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"min\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"max\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"spread\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"linear\": { \"type\": \"pbool\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"fc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"n\": { \"type\": \"pdouble\", \"cardinality\": 3, \"value\": [%lf,%lf,%lf] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"alpha\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _box_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"box\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"notics\": { \"type\": \"pbool\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lw\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _isosurface_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"isosurface\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"f\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"v\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"color\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"min\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"max\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"spread\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"linear\": { \"type\": \"pbool\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"fc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lw\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _travelling_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"travelling\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"start\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"end\": { \"type\": \"pdouble\", \"cardinality\": 1, \"value\": \"%lf\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"tx\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"ty\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"quat\": { \"type\": \"pfloat\", \"cardinality\": 4, \"value\": [%f,%f,%f,%f] }", 0., 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"fov\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _draw_string_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"draw_string\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"str\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"pos\": { \"type\": \"pint\", \"cardinality\": 1, \"value\": \"%d\" }", 0);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"size\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lw\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _labels_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"labels\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"f\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lw\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
int _lines_json (char * s, int len) {
  int i, len1 = 0;
  i = snprintf (s, len, "  \"lines\" : {");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n    \"file\": { \"type\": \"pstring\", \"cardinality\": 1, \"value\": \"%s\" }", "");
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lc\": { \"type\": \"color\", \"cardinality\": 3, \"value\": [%f,%f,%f] }", 0., 0., 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, ",\n    \"lw\": { \"type\": \"pfloat\", \"cardinality\": 1, \"value\": \"%f\" }", 0.);
  s += i, len -= i, len1 += i;
  i = snprintf (s, len, "\n  }");
  s += i, len -= i, len1 += i;
  return len1;
}
#line 1812 "/home/pwachara/basilisk/src/draw.h"

struct {
  int (* json) (char * s, int len);
} bview_interface[] = {
  { _draw_vof_json },
  { _squares_json },
  { _cells_json },
  { _box_json },






  { _isosurface_json },

  { NULL }
};
#line 427 "/home/pwachara/basilisk/src/view.h"
#line 442 "/home/pwachara/basilisk/src/view.h"
bool load (FILE * fp, char * file, Array * buf);

static void bview_draw (bview * view)
{
  if (!view->active)
    return;
  view->active = false;
  glFinish ();
  enable_fpe (FE_DIVBYZERO|FE_INVALID);
}
#line 499 "/home/pwachara/basilisk/src/view.h"
     
bool save (char * file, char * format, char * opt,
    FILE * fp,
    float lw,
    int sort, int options,
    FILE * checksum,

    bview * view)
{tracing("save","/home/pwachara/basilisk/src/view.h",500);
  if (file) {
    char * s = strchr (file, '.'), * dot = s;
    while (s) {
      dot = s;
      s = strchr (s + 1, '.');
    }
    if (dot)
      format = dot + 1;
  }

  if (!view)
    view = get_view();

  if ((!strcmp (format, "png") && which ("convert")) ||
      !strcmp (format, "jpg") ||
      (file && is_animation (file))) {
    bview_draw (view);
    unsigned char * image = (unsigned char *) compose_image (view);
    if (pid() == 0) {
      FILE * fp = open_image (file, opt);
      if (!fp) {
 perror (file);
 {end_tracing("save","/home/pwachara/basilisk/src/view.h",530);return false;}
      }
      gl_write_image (fp, image, view->width, view->height, view->samples);
      close_image (file, fp);
      if (checksum) {
 Adler32Hash hash;
 a32_hash_init (&hash);
 a32_hash_add (&hash, image, view->width*view->height*4*sizeof (unsigned char));
 fputs ("# ", checksum);
 if (file)
   fprintf (checksum, "%s: ", file);
 fprintf (checksum, "checksum: %08lx\n", (unsigned long) a32_hash (&hash));
      }
    }
    {end_tracing("save","/home/pwachara/basilisk/src/view.h",544);return true;}
  }

  if (file && (fp = fopen (file, "w")) == NULL) {
    perror (file);
    {end_tracing("save","/home/pwachara/basilisk/src/view.h",549);return false;}
  }
  if (!fp)
    fp = fout;

  if (!strcmp (format, "ppm")) {
    bview_draw (view);
    unsigned char * image = (unsigned char *) compose_image (view);
    if (pid() == 0)
      gl_write_image (fp, image, view->width, view->height, view->samples);
  }

  else if (!strcmp (format, "png")) {
    bview_draw (view);
    unsigned char * image = (unsigned char *) compose_image (view);
    if (pid() == 0)
      gl_write_image_png (fp, image, view->width, view->height, view->samples);
  }

  else if (!strcmp (format, "bv")) {

    fprintf (ferr, "save(): error: the '%s' format is no longer supported\n",
      format);
#line 588 "/home/pwachara/basilisk/src/view.h"
  }

  else if (!strcmp (format, "gnu") ||
    !strcmp (format, "obj") ||
    !strcmp (format, "kml") ||
    !strcmp (format, "ps") ||
    !strcmp (format, "eps") ||
    !strcmp (format, "tex") ||
    !strcmp (format, "pdf") ||
    !strcmp (format, "svg") ||
    !strcmp (format, "pgf"))
    fprintf (ferr, "save(): error: the '%s' format is no longer supported\n",
      format);

  else {
    fprintf (ferr, "save(): unknown format '%s'\n", format);
    if (file) {
      fclose (fp);
      remove (file);
    }
    {end_tracing("save","/home/pwachara/basilisk/src/view.h",608);return false;}
  }

  fflush (fp);
  if (file)
    fclose (fp);

  {end_tracing("save","/home/pwachara/basilisk/src/view.h",615);return true;}
end_tracing("save","/home/pwachara/basilisk/src/view.h",616);}







static char * remove_blanks (char * line)
{
  while (strchr (" \t", *line)) line++;
  char * s = line, * cur = line;
  bool instring = false;
  while (*s != '\0' && *s != '#') {
    if (*s == '"')
      instring = !instring;
    if (instring || !strchr (" \t", *s))
      *cur++ = *s;
    s++;
  }
  *cur = '\0';
  return line;
}

#line 1 "parse.h"
#line 1 "/home/pwachara/basilisk/src/parse.h"




enum ParamsType { pstring, pint, punsigned, pbool, pfloat, pdouble, pcolormap };

typedef struct {
  char * key;
  enum ParamsType type;
  void * val;
  int n;
} Params;

static bool atobool (char * s)
{
  if (!strcmp (s, "true"))
    return true;
  if (!strcmp (s, "false"))
    return false;
  return atoi (s) != 0;
}

static bool args (Params * p, char * val)
{
  static char * name[] = { "string", "int", "unsigned",
      "bool", "float", "double", "colormap" };
  switch (p->type) {

  case pstring:
    if (val[0] != '"') {
      fprintf (ferr, "expecting a string for '%s' got '%s'\n", p->key, val);
      return false;
    }
    if (val[strlen(val) - 1] != '"') {
      fprintf (ferr, "unterminated quoted string '%s'\n", val);
      return false;
    }
    val[strlen(val) - 1] = '\0';
    char * s = &val[1];
    int nc = 0;
    while (*s != '\0') {
      if (!strchr (" \t\n\r", *s))
 nc++;
      s++;
    }
    *((char **)p->val) = nc > 0 ? &val[1] : NULL;
    break;

  case pcolormap:
    if (!strcmp (val, "jet"))
      *((Colormap *)p->val) = jet;
    else if (!strcmp (val, "cool_warm"))
      *((Colormap *)p->val) = cool_warm;
    else if (!strcmp (val, "gray"))
      *((Colormap *)p->val) = gray;
    else if (!strcmp (val, "randomap"))
      *((Colormap *)p->val) = randomap;
    else {
      fprintf (ferr, "unknown colormap '%s'\n", val);
      return false;
    }
    break;

  case pint: case punsigned: case pbool: case pdouble: case pfloat:
    if (val[0] == '"') {
      fprintf (ferr, "expecting a %s for '%s' got %s\n",
        name[p->type], p->key, val);
      return false;
    }
    if (!p->n) {
      switch (p->type) {
      case pint: *((int *)p->val) = atoi(val); break;
      case punsigned: *((unsigned *)p->val) = atoi(val); break;
      case pbool: *((bool *)p->val) = atobool(val); break;
      case pfloat: *((float *)p->val) = atof(val); break;
      case pdouble: *((double *)p->val) = atof(val); break;
      default: if (!(false)) qassert ("/home/pwachara/basilisk/src/parse.h", 77, "false");
      }
    }
    else {
      if (val[0] != '{') {
 fprintf (ferr, "expecting an array for '%s' got %s\n", p->key, val);
 return false;
      }
      val++;
      int i = 0;
      char c = ',';
      while (i < p->n && c != '}') {
 char * s = strchr (val, ',');
 if (!s)
   s = strchr (val, '}');
 if (!s) {
   fprintf (ferr, "expecting an array for '%s' got %s\n", p->key, val);
   return false;
 }
 c = *s;
 *s++ = '\0';
 switch (p->type) {
 case pint: ((int *)p->val)[i++] = atoi (val); break;
 case punsigned: ((unsigned *)p->val)[i++] = atoi (val); break;
 case pbool: ((bool *)p->val)[i++] = atobool (val); break;
 case pfloat: ((float *)p->val)[i++] = atof (val); break;
 case pdouble: ((double *)p->val)[i++] = atof (val); break;
 default: if (!(false)) qassert ("/home/pwachara/basilisk/src/parse.h", 104, "false");
 }
 val = s;
      }
      if (c != '}') {
 fprintf (ferr, "expecting '}' for '%s' got %s\n", p->key, val);
 return false;
      }
    }
    break;

  default:
    if (!(false)) qassert ("/home/pwachara/basilisk/src/parse.h", 116, "false");
  }
  return true;
}

static char * find_comma (char * s)
{
  int par = 0;
  while (*s != '\0') {
    if (*s == ',' && par == 0) {
      *s = '\0';
      return s + 1;
    }
    if (*s == '{')
      par++;
    else if (*s == '}')
      par--;
    s++;
  }
  return NULL;
}

static char * mystrtok (char * str, const char * delim)
{
  static char * s = NULL;
  char * start = str ? str : s;
  bool string = false;
  s = start;
  while (*s != '\0') {
    if (*s == '"')
      string = !string;
    if (!string && strchr(delim, *s))
      break;
    s++;
  }
  if (*s != '\0')
    *s++ = '\0';
  return start;
}

int parse_params (Params * params)
{
  char * s;
  int i = 0, n = 0;
  Params * p = params;
  while (p->key) p++, n++;
  if (!(s = mystrtok (NULL, ");")) || s[0] == '\n')
    return false;
  while (s && *s != '\0') {
    char * next = find_comma (s), * key = s;
    if ((s = strchr (key, '='))) {
      s[0] = '\0', s++;
      i = -1;
      Params * p = params;
      while (p->key && strcmp(p->key, key)) p++;
      if (!p->key) {
 fprintf (ferr, "unknown key '%s'\n", key);
 return false;
      }
      if (!args (p, s))
 return false;
    }
    else {
      if (i < 0) {
 fprintf (ferr, "anonymous value '%s' after keys\n", key);
 return false;
      }
      if (i >= n) {
 fprintf (ferr, "too many parameters: '%s' %d %d\n", key, i, n);
 return false;
      }
      if (!args (&params[i], key))
 return false;
      i++;
    }
    s = next;
  }
  return true;
}
#line 641 "/home/pwachara/basilisk/src/view.h"

bool process_line (char * line)
{
  if (line[0] == '\0')
    return true;
  char * s = mystrtok (remove_blanks (line), "(");
  if (!s)
    return true;

  if (!strcmp (s, "restore")) {
    char * file = NULL;
    parse_params ((Params[]){{"file", pstring, &file}, {NULL}});
    if (file) {
      bview * view = get_view();
      if (view->cache) {
 free_cexpr (view->cache);
 view->cache = pcalloc (1, sizeof (cexpr),__func__,__FILE__,__LINE__);
      }
      if (!restore ( file, all
#line 1221 "/home/pwachara/basilisk/src/output.h"
, 
NULL
#line 659 "/home/pwachara/basilisk/src/view.h"
))
 fprintf (ferr, "could not restore from '%s'\n", file);
      else {
 restriction (all);
 fields_stats( 
#line 380 "/home/pwachara/basilisk/src/utils.h"
all
#line 663 "/home/pwachara/basilisk/src/view.h"
);
 clear();
      }
    }
  }

  else if (!strcmp (s, "dump")) {
    char * file = NULL;
    parse_params ((Params[]){{"file", pstring, &file}, {NULL}});
    dump ( file
#line 1142 "/home/pwachara/basilisk/src/output.h"
, 
all, 
NULL, 
false, 
true
#line 672 "/home/pwachara/basilisk/src/view.h"
);
  }

  else if (!strcmp (s, "input_gfs")) {
    char * file = NULL;
    parse_params ((Params[]){{"file", pstring, &file}, {NULL}});
    if (file) {
      input_gfs ( 
#line 157 "/home/pwachara/basilisk/src/input.h"
stdin
#line 679 "/home/pwachara/basilisk/src/view.h"
, all, file);
      restriction (all);
      fields_stats( 
#line 380 "/home/pwachara/basilisk/src/utils.h"
all
#line 681 "/home/pwachara/basilisk/src/view.h"
);
      clear();
    }
  }

  else if (!strcmp (s, "save")) {
    char * file = NULL;
    parse_params ((Params[]){{"file", pstring, &file}, {NULL}});
    if (file)
      save ( file
#line 500
, "ppm", NULL, 
NULL, 
0, 
0, 0, 
NULL, 

NULL
#line 690
);
  }

  else if (!strcmp (s, "load")) {
    char * file = NULL;
    parse_params ((Params[]){{"file", pstring, &file}, {NULL}});
    if (file)
      load ( 
#line 442
NULL
#line 697
, file
#line 442
, NULL
#line 697
);
  }






#line 1 "draw_get.h"
#line 1 "/home/pwachara/basilisk/src/draw_get.h"

else if (!strcmp (s, "view")) {
  float tx = 0.;
  float ty = 0.;
  float fov = 0.;
  float quat[4] = {0};
  float sx = 1.;
  float sy = 1.;
  float sz = 1.;
  unsigned width = 800;
  unsigned height = 800;
  unsigned samples = 4;
  float bg[3] = {0};
  float theta = 0.;
  float phi = 0.;
  float psi = 0.;
  bool relative = false;
  float tz = 0.;
  float near = 0.;
  float far = 0.;
  float res = 0.;
  char * camera = NULL;
  MapFunc map = NULL;
  int cache = 0;
  float p1x = 0.;
  float p1y = 0.;
  float p2x = 0.;
  float p2y = 0.;
  bview * view1 = NULL;
  Params params[] = {
    {"tx", pfloat, &tx},
    {"ty", pfloat, &ty},
    {"fov", pfloat, &fov},
    {"quat", pfloat, quat, 4},
    {"sx", pfloat, &sx},
    {"sy", pfloat, &sy},
    {"sz", pfloat, &sz},
    {"width", punsigned, &width},
    {"height", punsigned, &height},
    {"samples", punsigned, &samples},
    {"bg", pfloat, bg, 3},
    {"theta", pfloat, &theta},
    {"phi", pfloat, &phi},
    {"psi", pfloat, &psi},
    {"relative", pbool, &relative},
    {"tz", pfloat, &tz},
    {"near", pfloat, &near},
    {"far", pfloat, &far},
    {"res", pfloat, &res},
    {"camera", pstring, &camera},
    {"cache", pint, &cache},
    {"p1x", pfloat, &p1x},
    {"p1y", pfloat, &p1y},
    {"p2x", pfloat, &p2x},
    {"p2y", pfloat, &p2y},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  view (tx,ty,fov,quat,sx,sy,sz,width,height,samples,bg,theta,phi,psi,relative,tz,near,far,res,camera,map,cache,p1x,p1y,p2x,p2y,view1);
}
else if (!strcmp (s, "draw_vof")) {
  char * c = NULL;
  char * s = NULL;
  bool edges = false;
  double larger = 0.;
  int filled = 0;
  char * color = NULL;
  double min = 0;
  double max = 0;
  double spread = 0;
  bool linear = false;
  Colormap map = jet;
  float fc[3] = {0};
  float lc[3] = {0};
  float lw = 1.;
  bool expr = false;
  Params params[] = {
    {"c", pstring, &c},
    {"s", pstring, &s},
    {"edges", pbool, &edges},
    {"larger", pdouble, &larger},
    {"filled", pint, &filled},
    {"color", pstring, &color},
    {"min", pdouble, &min},
    {"max", pdouble, &max},
    {"spread", pdouble, &spread},
    {"linear", pbool, &linear},
    {"fc", pfloat, fc, 3},
    {"lc", pfloat, lc, 3},
    {"lw", pfloat, &lw},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!draw_vof (c,s,edges,larger,filled,color,min,max,spread,linear,map,fc,lc,lw,expr
#line 903 "/home/pwachara/basilisk/src/draw.h"
, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 96 "/home/pwachara/basilisk/src/draw_get.h"
))
    return false;
}
else if (!strcmp (s, "isoline")) {
  char * phi = NULL;
  double val = 0.;
  int n = 1;
  bool edges = false;
  double larger = 0.;
  int filled = 0;
  char * color = NULL;
  double min = 0;
  double max = 0;
  double spread = 0;
  bool linear = false;
  Colormap map = jet;
  float fc[3] = {0};
  float lc[3] = {0};
  float lw = 1.;
  bool expr = false;
  Params params[] = {
    {"phi", pstring, &phi},
    {"val", pdouble, &val},
    {"n", pint, &n},
    {"edges", pbool, &edges},
    {"larger", pdouble, &larger},
    {"filled", pint, &filled},
    {"color", pstring, &color},
    {"min", pdouble, &min},
    {"max", pdouble, &max},
    {"spread", pdouble, &spread},
    {"linear", pbool, &linear},
    {"fc", pfloat, fc, 3},
    {"lc", pfloat, lc, 3},
    {"lw", pfloat, &lw},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!isoline (phi,val,n,edges,larger,filled,color,min,max,spread,linear,map,fc,lc,lw,expr
#line 1084 "/home/pwachara/basilisk/src/draw.h"
, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 135 "/home/pwachara/basilisk/src/draw_get.h"
))
    return false;
}
else if (!strcmp (s, "cells")) {
  coord n = {0,0,1};
  double alpha = 0.;
  float lc[3] = {0};
  float lw = 1.;
  Params params[] = {
    {"n", pdouble, &n, 3},
    {"alpha", pdouble, &alpha},
    {"lc", pfloat, lc, 3},
    {"lw", pfloat, &lw},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!cells (n,alpha,lc,lw))
    return false;
}
else if (!strcmp (s, "vectors")) {
  char * u = NULL;
  double scale = 1;
  float lc[3] = {0};
  float lw = 1.;
  int level = -1;
  Params params[] = {
    {"u", pstring, &u},
    {"scale", pdouble, &scale},
    {"lc", pfloat, lc, 3},
    {"lw", pfloat, &lw},
    {"level", pint, &level},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!vectors (u,scale,lc,lw,level))
    return false;
}
else if (!strcmp (s, "squares")) {
  char * color = NULL;
  char * z = NULL;
  double min = 0;
  double max = 0;
  double spread = 0;
  bool linear = false;
  Colormap map = jet;
  float fc[3] = {0};
  float lc[3] = {0};
  bool expr = false;
  coord n = {0,0,1};
  double alpha = 0;
  Params params[] = {
    {"color", pstring, &color},
    {"z", pstring, &z},
    {"min", pdouble, &min},
    {"max", pdouble, &max},
    {"spread", pdouble, &spread},
    {"linear", pbool, &linear},
    {"fc", pfloat, fc, 3},
    {"lc", pfloat, lc, 3},
    {"n", pdouble, &n, 3},
    {"alpha", pdouble, &alpha},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!squares (color,z,min,max,spread,linear,map,fc,lc,expr,n,alpha
#line 1243 "/home/pwachara/basilisk/src/draw.h"
, 
1, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 202 "/home/pwachara/basilisk/src/draw_get.h"
))
    return false;
}
else if (!strcmp (s, "box")) {
  bool notics = false;
  float lc[3] = {0};
  float lw = 1.;
  Params params[] = {
    {"notics", pbool, &notics},
    {"lc", pfloat, lc, 3},
    {"lw", pfloat, &lw},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!box (notics,lc,lw))
    return false;
}
else if (!strcmp (s, "isosurface")) {
  char * f = NULL;
  double v = 0.;
  char * color = NULL;
  double min = 0;
  double max = 0;
  double spread = 0;
  bool linear = false;
  Colormap map = jet;
  float fc[3] = {0};
  float lc[3] = {0};
  float lw = 1;
  bool expr = false;
  Params params[] = {
    {"f", pstring, &f},
    {"v", pdouble, &v},
    {"color", pstring, &color},
    {"min", pdouble, &min},
    {"max", pdouble, &max},
    {"spread", pdouble, &spread},
    {"linear", pbool, &linear},
    {"fc", pfloat, fc, 3},
    {"lc", pfloat, lc, 3},
    {"lw", pfloat, &lw},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!isosurface (f,v,color,min,max,spread,linear,map,fc,lc,lw,expr
#line 1544 "/home/pwachara/basilisk/src/draw.h"
, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 248 "/home/pwachara/basilisk/src/draw_get.h"
))
    return false;
}
else if (!strcmp (s, "travelling")) {
  double start = 0;
  double end = 0;
  float tx = 0;
  float ty = 0;
  float quat[4] = {0};
  float fov = 0;
  Params params[] = {
    {"start", pdouble, &start},
    {"end", pdouble, &end},
    {"tx", pfloat, &tx},
    {"ty", pfloat, &ty},
    {"quat", pfloat, quat, 4},
    {"fov", pfloat, &fov},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  travelling (start,end,tx,ty,quat,fov);
}
else if (!strcmp (s, "draw_string")) {
  char * str = NULL;
  int pos = 0;
  float size = 40;
  float lc[3] = {0};
  float lw = 1;
  Params params[] = {
    {"str", pstring, &str},
    {"pos", pint, &pos},
    {"size", pfloat, &size},
    {"lc", pfloat, lc, 3},
    {"lw", pfloat, &lw},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!draw_string (str,pos,size,lc,lw))
    return false;
}
else if (!strcmp (s, "labels")) {
  char * f = NULL;
  float lc[3] = {0};
  float lw = 1;
  Params params[] = {
    {"f", pstring, &f},
    {"lc", pfloat, lc, 3},
    {"lw", pfloat, &lw},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!labels (f,lc,lw))
    return false;
}
else if (!strcmp (s, "lines")) {
  char * file = NULL;
  float lc[3] = {0};
  float lw = 1.;
  Params params[] = {
    {"file", pstring, &file},
    {"lc", pfloat, lc, 3},
    {"lw", pfloat, &lw},
    {NULL}
  };
  if (!parse_params (params))
    return false;
  if (!lines (file,lc,lw))
    return false;
}
#line 706 "/home/pwachara/basilisk/src/view.h"

  else if (!strcmp (s, "clear"))
    clear();

  else if (s[0] != '\n' && s[0] != '\0')
    fprintf (ferr, "load(): syntax error: '%s'\n", s);

  return true;
}

bool load (FILE * fp, char * file, Array * buf)
{
  if (file) {
    fp = fopen (file, "r");
    if (!fp) {
      perror (file);
      return false;
    }
  }

  if (fp) {
    char line[256];
    while (fgets (line, 256, fp) && process_line (line));
  }
  else if (buf) {
    int i = 0;
    char * s = (char *) buf->p;
    while (i < buf->len) {
      char * start = s;
      while (i < buf->len && *s != '\n')
 s++, i++;
      if (*s == '\n' && ++s > start) {
 char line[s - start + 1];
 strncpy (line, start, s - start);
 line[s - start] = '\0';
 process_line (line);
      }
    }
  }
  return true;
}
#line 9 "CubicTest.c"
#line 1 "lambda2.h"
#line 1 "/home/pwachara/basilisk/src/lambda2.h"
static void eigsrt (double d[3],
      double v[3][3])
{
  int k, j, i;
  double p;

  for (i = 0; i < 3 - 1; i++) {
    p = d[k = i];

    for (j = i + 1; j < 3; j++)
      if (d[j] >= p)
 p = d[k = j];
    if (k != i) {
      d[k] = d[i];
      d[i] = p;
      for (j = 0; j < 3; j++) {
 p = v[j][i];
 v[j][i] = v[j][k];
 v[j][k] = p;
      }
    }
  }
}
#line 37 "/home/pwachara/basilisk/src/lambda2.h"
void eigenvalues (double a[3][3],
    double d[3],
    double v[3][3])
{
  int j, iq, ip, i;
  double tresh, theta, tau, t, sm, s, h, g, c, b[3], z[3];

  for (ip = 0; ip < 3; ip++) {
    for (iq = 0; iq < 3; iq++)
      v[ip][iq] = 0.0;
    v[ip][ip] = 1.0;
  }

  for (ip = 0; ip < 3; ip++) {
    b[ip] = d[ip] = a[ip][ip];
    z[ip] = 0.0;
  }

  for (i = 1; i <= 50; i++) {
    sm = 0.0;
    for (ip = 0; ip < 3 - 1; ip++) {
      for (iq = ip + 1; iq < 3; iq++)
 sm += fabs (a[ip][iq]);
    }
    if (sm == 0.0) {
      eigsrt (d, v);
      return;
    }
    if (i < 4)
      tresh = 0.2*sm/(3*3);
    else
      tresh = 0.0;
    for (ip = 0; ip < 3 - 1; ip++) {
      for (iq = ip + 1; iq < 3; iq++) {
 g = 100.0*fabs (a[ip][iq]);
 if (i > 4 && fabs(d[ip]) + g == fabs(d[ip]) &&
     fabs(d[iq]) + g == fabs(d[iq]))
   a[ip][iq] = 0.0;
 else if (fabs (a[ip][iq]) > tresh) {
   h = d[iq] - d[ip];
   if (fabs(h) + g == fabs(h))
     t = a[ip][iq]/h;
   else {
     theta = 0.5*h/a[ip][iq];
     t = 1.0/(fabs (theta) + sqrt (1.0 + theta*theta));
     if (theta < 0.0) t = -t;
   }
   c = 1.0/sqrt (1 + t*t);
   s = t*c;
   tau = s/(1.0 + c);
   h = t*a[ip][iq];
   z[ip] -= h;
   z[iq] += h;
   d[ip] -= h;
   d[iq] += h;
   a[ip][iq] = 0.0;
   for (j = 0; j <= ip - 1; j++)
     { g=a[j][ip];h=a[j][iq];a[j][ip]=g-s*(h+g*tau);a[j][iq]=h+s*(g-h*tau);};
   for (j = ip + 1; j <= iq - 1; j++)
     { g=a[ip][j];h=a[j][iq];a[ip][j]=g-s*(h+g*tau);a[j][iq]=h+s*(g-h*tau);};
   for (j = iq + 1; j < 3; j++)
     { g=a[ip][j];h=a[iq][j];a[ip][j]=g-s*(h+g*tau);a[iq][j]=h+s*(g-h*tau);};
   for (j = 0; j < 3; j++)
     { g=v[j][ip];h=v[j][iq];v[j][ip]=g-s*(h+g*tau);v[j][iq]=h+s*(g-h*tau);};
 }
      }
    }
    for (ip = 0; ip < 3; ip++) {
      b[ip] += z[ip];
      d[ip] = b[ip];
      z[ip] = 0.0;
    }
  }

  for (i = 0; i < 3; i++) {
    for (j = 0; j < 3; j++)
      fprintf (ferr, "%10.3g ", a[i][j]);
    fprintf (ferr, "\n");
  }
  if (!(false)) qassert ("/home/pwachara/basilisk/src/lambda2.h", 116, "false");
}

void lambda2 (const vector u, scalar l2)
{
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/lambda2.h", .line = 121, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 121 "/home/pwachara/basilisk/src/lambda2.h"
{ 
    
    scalar s = u.x;   
    
    
      {_stencil_val(fs.x,0,0,0); _stencil_val(fs.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(s,-1,0,0); _stencil_val(fs.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(s,0,0,0); _stencil_val(fs.x,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,-1,0,0);                }      {_stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(s,0,-1,0); _stencil_val(fs.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(s,0,0,0); _stencil_val(fs.y,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0,-1,0);                }      {_stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,-1); _stencil_val(fs.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,0); _stencil_val(fs.z,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,-1);                }
    s = u.y;   
    
      {_stencil_val(fs.x,0,0,0); _stencil_val(fs.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(s,-1,0,0); _stencil_val(fs.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(s,0,0,0); _stencil_val(fs.x,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,-1,0,0);                }      {_stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(s,0,-1,0); _stencil_val(fs.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(s,0,0,0); _stencil_val(fs.y,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0,-1,0);                }      {_stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,-1); _stencil_val(fs.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,0); _stencil_val(fs.z,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,-1);                }
    s = u.z;   
    
      {_stencil_val(fs.x,0,0,0); _stencil_val(fs.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(s,-1,0,0); _stencil_val(fs.x,1,0,0);_stencil_val(s,1,0,0); _stencil_val(s,0,0,0); _stencil_val(fs.x,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,-1,0,0);                }      {_stencil_val(fs.y,0,0,0); _stencil_val(fs.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(s,0,-1,0); _stencil_val(fs.y,0,1,0);_stencil_val(s,0,1,0); _stencil_val(s,0,0,0); _stencil_val(fs.y,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0,-1,0);                }      {_stencil_val(fs.z,0,0,0); _stencil_val(fs.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,-1); _stencil_val(fs.z,0,0,1);_stencil_val(s,0,0,1); _stencil_val(s,0,0,0); _stencil_val(fs.z,0,0,0);_stencil_val(s,0,0,0); _stencil_val(s,0,0,-1);                }   
            
            
       
       
     
      
       
       
    
    _stencil_val_a(l2,0,0,0);  
  }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 121 "/home/pwachara/basilisk/src/lambda2.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 121 "/home/pwachara/basilisk/src/lambda2.h"
{
    double JJ[3][3];
    scalar s = u.x;
    int i = 0;
    
      JJ[0][i++] = (val(fs.x,0,0,0) && val(fs.x,1,0,0) ? (val(s,1,0,0) - val(s,-1,0,0))/(2.*Delta) : val(fs.x,1,0,0) ? (val(s,1,0,0) - val(s,0,0,0))/Delta : val(fs.x,0,0,0) ? (val(s,0,0,0) - val(s,-1,0,0))/Delta : 0.);      JJ[0][i++] = (val(fs.y,0,0,0) && val(fs.y,0,1,0) ? (val(s,0,1,0) - val(s,0,-1,0))/(2.*Delta) : val(fs.y,0,1,0) ? (val(s,0,1,0) - val(s,0,0,0))/Delta : val(fs.y,0,0,0) ? (val(s,0,0,0) - val(s,0,-1,0))/Delta : 0.);      JJ[0][i++] = (val(fs.z,0,0,0) && val(fs.z,0,0,1) ? (val(s,0,0,1) - val(s,0,0,-1))/(2.*Delta) : val(fs.z,0,0,1) ? (val(s,0,0,1) - val(s,0,0,0))/Delta : val(fs.z,0,0,0) ? (val(s,0,0,0) - val(s,0,0,-1))/Delta : 0.);
    s = u.y; i = 0;
    
      JJ[1][i++] = (val(fs.x,0,0,0) && val(fs.x,1,0,0) ? (val(s,1,0,0) - val(s,-1,0,0))/(2.*Delta) : val(fs.x,1,0,0) ? (val(s,1,0,0) - val(s,0,0,0))/Delta : val(fs.x,0,0,0) ? (val(s,0,0,0) - val(s,-1,0,0))/Delta : 0.);      JJ[1][i++] = (val(fs.y,0,0,0) && val(fs.y,0,1,0) ? (val(s,0,1,0) - val(s,0,-1,0))/(2.*Delta) : val(fs.y,0,1,0) ? (val(s,0,1,0) - val(s,0,0,0))/Delta : val(fs.y,0,0,0) ? (val(s,0,0,0) - val(s,0,-1,0))/Delta : 0.);      JJ[1][i++] = (val(fs.z,0,0,0) && val(fs.z,0,0,1) ? (val(s,0,0,1) - val(s,0,0,-1))/(2.*Delta) : val(fs.z,0,0,1) ? (val(s,0,0,1) - val(s,0,0,0))/Delta : val(fs.z,0,0,0) ? (val(s,0,0,0) - val(s,0,0,-1))/Delta : 0.);
    s = u.z; i = 0;
    
      JJ[2][i++] = (val(fs.x,0,0,0) && val(fs.x,1,0,0) ? (val(s,1,0,0) - val(s,-1,0,0))/(2.*Delta) : val(fs.x,1,0,0) ? (val(s,1,0,0) - val(s,0,0,0))/Delta : val(fs.x,0,0,0) ? (val(s,0,0,0) - val(s,-1,0,0))/Delta : 0.);      JJ[2][i++] = (val(fs.y,0,0,0) && val(fs.y,0,1,0) ? (val(s,0,1,0) - val(s,0,-1,0))/(2.*Delta) : val(fs.y,0,1,0) ? (val(s,0,1,0) - val(s,0,0,0))/Delta : val(fs.y,0,0,0) ? (val(s,0,0,0) - val(s,0,-1,0))/Delta : 0.);      JJ[2][i++] = (val(fs.z,0,0,0) && val(fs.z,0,0,1) ? (val(s,0,0,1) - val(s,0,0,-1))/(2.*Delta) : val(fs.z,0,0,1) ? (val(s,0,0,1) - val(s,0,0,0))/Delta : val(fs.z,0,0,0) ? (val(s,0,0,0) - val(s,0,0,-1))/Delta : 0.);
    double S2O2[3][3];
    for (int i = 0; i < 3; i++)
      for (int j = 0; j < 3; j++) {
 S2O2[i][j] = 0.;
 for (int k = 0; k < 3; k++)
   S2O2[i][j] += JJ[i][k]*JJ[k][j] + JJ[k][i]*JJ[j][k];
      }
    double lambda[3], ev[3][3];
    eigenvalues (S2O2, lambda, ev);
    val(l2,0,0,0) = lambda[1]/2.;
  }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}
#line 144 "/home/pwachara/basilisk/src/lambda2.h"
}
#line 10 "CubicTest.c"
#line 1 "maxruntime.h"
#line 1 "/home/pwachara/basilisk/src/maxruntime.h"
#line 18 "/home/pwachara/basilisk/src/maxruntime.h"
static double _maxruntime = 1e30f;

static int runtime_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i += 10)!=0;*ip=i;*tp=t;return ret;}      static int runtime(const int i,const double t,Event *_ev){tracing("runtime","/home/pwachara/basilisk/src/maxruntime.h",20); {
  mpi_all_reduce (perf.t, MPI_DOUBLE, MPI_MAX);
  if (perf.t >= _maxruntime - 300) {
    dump ( "restart"
#line 1142 "/home/pwachara/basilisk/src/output.h"
, 
all, 
NULL, 
false, 
true
#line 23 "/home/pwachara/basilisk/src/maxruntime.h"
);
    {end_tracing("runtime","/home/pwachara/basilisk/src/maxruntime.h",24);return 1;}
  }
}{end_tracing("runtime","/home/pwachara/basilisk/src/maxruntime.h",26);return 0;}end_tracing("runtime","/home/pwachara/basilisk/src/maxruntime.h",26);}

void maxruntime (int * argc, char * argv[])
{
  for (int i = 0; i < *argc; i++)
    if (!strcmp (argv[i], "--maxruntime") || !strcmp (argv[i], "-m")) {
      if (i + 1 < *argc) {
 char * s = strtok (argv[i + 1], ":");
 int n = 0;
 _maxruntime = 0;
 do {
   _maxruntime = 60*_maxruntime + atoi(s);
   n++;
 } while ((s = strtok (NULL, ":")));
 if (n > 3) {
   fprintf (ferr, "maxruntime: TIME format must be H:M:S\n");
   exit (1);
 }
      }
      else {
 fprintf (ferr, "usage: %s TIME\n", argv[i]);
 exit (1);
      }
      *argc -= 2;
      for (int j = i; j < *argc; j++)
 argv[j] = argv[j + 2];
    }
}
#line 7 "/home/pwachara/basilisk/src/navier-stokes/perfs.h"
static int perfs_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i += 1)!=0;*ip=i;*tp=t;return ret;}
#line 11 "CubicTest.c"
#line 1 "navier-stokes/perfs.h"
#line 1 "/home/pwachara/basilisk/src/navier-stokes/perfs.h"






      static int perfs(const int i,const double t,Event *_ev){tracing("perfs","/home/pwachara/basilisk/src/navier-stokes/perfs.h",7); {
  static FILE * fp =NULL;if(!fp||i==0)fp=pid()>0?fopen("/dev/null","w"): fopen ("perfs", "w");
  if (i == 0)
    fprintf (fp,
      "t dt mgp.i mgp.nrelax mgpf.i mgpf.nrelax mgu.i mgu.nrelax "
      "grid->tn perf.t perf.speed npe perf.ispeed\n");
  static double start = 0.;
  if (i > 10 && perf.t - start < 1.) {end_tracing("perfs","/home/pwachara/basilisk/src/navier-stokes/perfs.h",14);return 0;}
  fprintf (fp, "%g %g %d %d %d %d %d %d %ld %g %g %d %g\n",
    t, dt, mgp.i, mgp.nrelax, mgpf.i, mgpf.nrelax, mgu.i, mgu.nrelax,
    grid->tn, perf.t, perf.speed, npe(), perf.ispeed);
  fflush (fp);
  start = perf.t;
}{end_tracing("perfs","/home/pwachara/basilisk/src/navier-stokes/perfs.h",20);return 0;}end_tracing("perfs","/home/pwachara/basilisk/src/navier-stokes/perfs.h",20);}






static int perf_plot_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i = 10)!=0;*ip=i;*tp=t;return ret;}      static int perf_plot(const int i,const double t,Event *_ev){tracing("perf_plot","/home/pwachara/basilisk/src/navier-stokes/perfs.h",27); {
  if (getenv ("DISPLAY"))
    qpopen ("gnuplot -e 'set term x11 noraise title perfs' "
    "$BASILISK/navier-stokes/perfs.plot "
    "& read dummy; kill $!", "w");
}{end_tracing("perf_plot","/home/pwachara/basilisk/src/navier-stokes/perfs.h",32);return 0;}end_tracing("perf_plot","/home/pwachara/basilisk/src/navier-stokes/perfs.h",32);}
#line 12 "CubicTest.c"
#line 21 "CubicTest.c"
double froude_liquid = 0.02;
double froude_gas = 4.12;
double reynold_liquid = 240.0;
double reynold_gas = 3284.0;


double h_L_D_init = 0.2;
double forcing = 0.1;
double U1s_init = 0.01;
double U2s_init = 2.0;


scalar  f0={20};
double U_LS;
double U_GS;
double liquid_area;
double froude_liquid_instant;
double FROUDE;


double calculate_froude_liquid(double U_LS_local);
void calculate_superficial_vel(double *U_LS, double *U_GS, double *liquid_area);



static double _boundary6(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 46 "CubicTest.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 46 "CubicTest.c"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = true, 0. : 2.*0. - val(_s,0,0,0)));}}}static double _boundary6_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 46 "CubicTest.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 46 "CubicTest.c"
{return( ( data ? *((bool *)data) = true, 0 : - val(_s,0,0,0)));}}}
static double _boundary7(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 47 "CubicTest.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 47 "CubicTest.c"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = true, 0. : 2.*0. - val(_s,0,0,0)));}}}static double _boundary7_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 47 "CubicTest.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 47 "CubicTest.c"
{return( ( data ? *((bool *)data) = true, 0 : - val(_s,0,0,0)));}}}
static double _boundary8(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 48 "CubicTest.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 48 "CubicTest.c"
{return( ( data ? embed_area_center (point, &x, &y, &z),    *((bool *)data) = true, 0. : 2.*0. - val(_s,0,0,0)));}}}static double _boundary8_homogeneous(Point point,Point neighbor,scalar _s,bool *data){int ig=0;NOT_UNUSED(ig);int jg=0;NOT_UNUSED(jg);int kg=0;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 48 "CubicTest.c"
{int ig=neighbor.i-point.i;if(ig==0)ig=_attribute[_s.i].d.x;NOT_UNUSED(ig);int jg=neighbor.j-point.j;if(jg==0)jg=_attribute[_s.i].d.y;NOT_UNUSED(jg);int kg=neighbor.k-point.k;if(kg==0)kg=_attribute[_s.i].d.z;NOT_UNUSED(kg);  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 48 "CubicTest.c"
{return( ( data ? *((bool *)data) = true, 0 : - val(_s,0,0,0)));}}}

int main(){
#line 66
_init_solver();    
#line 51
size(2.0);
    dimensions ( 1.0 * 2., 1.0 * 2., 1.0 * 2.);
    init_grid (64);

    rho1 = 1000.0;
    rho2 = 1.0;
    mu1 = 54.0;
    mu2 = 1.0;

    origin (0, -(1.0)/2.0, -(1.0)/2.0);
    FROUDE = froude_liquid;
    _attribute[f.i].sigma = (1./79.0) * (1000.0 - 1.0);

    periodic(right);
    run();
free_solver();}


static int init_0_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(t = 0)!=0;*ip=i;*tp=t;return ret;}      static int init_0(const int i,const double t,Event *_ev){tracing("init_0","CubicTest.c",69); {
  
  
#line 369 "/home/pwachara/basilisk/src/fractions.h"
{
    scalar  phi=new_vertex_scalar("phi");    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/fractions.h", .line = 371, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
      
#line 372 "/home/pwachara/basilisk/src/fractions.h"
{_stencil_val_a(phi,0,0,0);        }  
#line 338 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 912 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
#line 300
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 913
{
    int ig = -1; NOT_UNUSED(ig);

    int jg = -1; NOT_UNUSED(jg);


    int kg = -1; NOT_UNUSED(kg);      
#line 372 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 372 "/home/pwachara/basilisk/src/fractions.h"
val(phi,0,0,0) = (
#line 70 "CubicTest.c"
-( y*y) - ( z*z) + pow(1.0/2,2)
#line 372 "/home/pwachara/basilisk/src/fractions.h"
);}
  
#line 922 "/home/pwachara/basilisk/src/grid/multigrid.h"
}      
#line 317
}
  }
}

#line 923
}    
#line 373 "/home/pwachara/basilisk/src/fractions.h"
fractions (phi, cs, fs
#line 122
, 0.
#line 373
);delete((scalar*)((scalar[]){phi,{-1}}));
  }  
#line 71 "CubicTest.c"
fractions_cleanup (cs, fs
#line 293 "/home/pwachara/basilisk/src/embed.h"
, 
0., false
#line 71 "CubicTest.c"
);
  

  
#line 359 "/home/pwachara/basilisk/src/fractions.h"
{
    scalar  phi=new_vertex_scalar("phi");    
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "/home/pwachara/basilisk/src/fractions.h", .line = 361, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 335
{
    _loop.vertex = true;
      
#line 362 "/home/pwachara/basilisk/src/fractions.h"
{_stencil_val_a(phi,0,0,0);                  }  
#line 338 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 912 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
#line 300
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 913
{
    int ig = -1; NOT_UNUSED(ig);

    int jg = -1; NOT_UNUSED(jg);


    int kg = -1; NOT_UNUSED(kg);      
#line 362 "/home/pwachara/basilisk/src/fractions.h"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 362 "/home/pwachara/basilisk/src/fractions.h"
val(phi,0,0,0) = (
#line 73 "CubicTest.c"
y < (h_L_D_init - 1.0/2) ?
          -( y*y) - ( z*z) + pow(1.0/2,2) :-1
#line 362 "/home/pwachara/basilisk/src/fractions.h"
);}
  
#line 922 "/home/pwachara/basilisk/src/grid/multigrid.h"
}      
#line 317
}
  }
}

#line 923
}    
#line 363 "/home/pwachara/basilisk/src/fractions.h"
fractions (phi, f0
#line 121
,
(  vector) {0}, 0.
#line 363
);delete((scalar*)((scalar[]){phi,{-1}}));
  }  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "CubicTest.c", .line = 76, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 76 "CubicTest.c"
{ 
_stencil_val(f0,0,0,0);    _stencil_val_a(f,0,0,0);
_stencil_val(f,0,0,0);_stencil_val(f,0,0,0);    _stencil_val_a(u.x,0,0,0);    
  }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++) 
#line 76 "CubicTest.c"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 76 "CubicTest.c"
{
    val(f,0,0,0) = val(f0,0,0,0);
    val(u.x,0,0,0) = U1s_init*val(f,0,0,0) + U2s_init*(1-val(f,0,0,0));
  }}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 81 "CubicTest.c"
view(0,0,0
#line 51 "/home/pwachara/basilisk/src/draw.h"
,
(    float[4]) {0}, 
1., 1., 1., 
800, 800, 4,
(    float[3]) {0}, 
0., 0., 0., 
false, 
0., 0., 0., 
0.
#line 81 "CubicTest.c"
,"left"
#line 60 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 
0., 0., 0., 0., 
NULL
#line 81 "CubicTest.c"
);
  clear();
  draw_vof("cs"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0.
#line 83 "CubicTest.c"
,-1
#line 897 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 0, 0, 
false, 
jet
#line 83 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
(        float[3])
#line 83 "CubicTest.c"
{1,1,1}
#line 902 "/home/pwachara/basilisk/src/draw.h"
,( float[3]) {0}, 1., 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 83 "CubicTest.c"
);
  draw_vof("f0"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0.
#line 84 "CubicTest.c"
,-1
#line 897 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 0, 0, 
false, 
jet
#line 84 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
(        float[3])
#line 84 "CubicTest.c"
{1,0,1}
#line 902 "/home/pwachara/basilisk/src/draw.h"
,( float[3]) {0}, 1., 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 84 "CubicTest.c"
);
  cells(
#line 1131 "/home/pwachara/basilisk/src/draw.h"
(coord) {0,0,1}, 0.,
(     float[3]) {0}, 1.
#line 85 "CubicTest.c"
);
  save("grid_t0_left.jpg"
#line 500 "/home/pwachara/basilisk/src/view.h"
, "ppm", NULL, 
NULL, 
0, 
0, 0, 
NULL, 

NULL
#line 86 "CubicTest.c"
);

  view(0,0,0
#line 51 "/home/pwachara/basilisk/src/draw.h"
,
(    float[4]) {0}, 
1., 1., 1., 
800, 800, 4,
(    float[3]) {0}, 
0., 0., 0., 
false, 
0., 0., 0., 
0.
#line 88 "CubicTest.c"
,"top"
#line 60 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 
0., 0., 0., 0., 
NULL
#line 88 "CubicTest.c"
);
  clear();
  draw_vof("cs"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0.
#line 90 "CubicTest.c"
,-1
#line 897 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 0, 0, 
false, 
jet
#line 90 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
(        float[3])
#line 90 "CubicTest.c"
{1,1,1}
#line 902 "/home/pwachara/basilisk/src/draw.h"
,( float[3]) {0}, 1., 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 90 "CubicTest.c"
);
  draw_vof("f0"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0.
#line 91 "CubicTest.c"
,-1
#line 897 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 0, 0, 
false, 
jet
#line 91 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
(        float[3])
#line 91 "CubicTest.c"
{1,0,1}
#line 902 "/home/pwachara/basilisk/src/draw.h"
,( float[3]) {0}, 1., 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 91 "CubicTest.c"
);
  cells(
#line 1131 "/home/pwachara/basilisk/src/draw.h"
(coord) {0,0,1}, 0.,
(     float[3]) {0}, 1.
#line 92 "CubicTest.c"
);
  save("grid_t0_top.jpg"
#line 500 "/home/pwachara/basilisk/src/view.h"
, "ppm", NULL, 
NULL, 
0, 
0, 0, 
NULL, 

NULL
#line 93 "CubicTest.c"
);

  view(0,0,0
#line 51 "/home/pwachara/basilisk/src/draw.h"
,
(    float[4]) {0}, 
1., 1., 1., 
800, 800, 4,
(    float[3]) {0}
#line 95 "CubicTest.c"
, 3.14/2 + 0.5, 0.4, 0.
#line 56 "/home/pwachara/basilisk/src/draw.h"
, 
false, 
0., 0., 0., 
0., 
NULL, 
NULL, 
0, 
0., 0., 0., 0., 
NULL
#line 95 "CubicTest.c"
);
  clear();
  draw_vof("f"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0.
#line 97 "CubicTest.c"
,-1
#line 897 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 0, 0, 
false, 
jet
#line 97 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
(        float[3])
#line 97 "CubicTest.c"
{1,0,1}
#line 902 "/home/pwachara/basilisk/src/draw.h"
,( float[3]) {0}, 1., 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 97 "CubicTest.c"
);
  cells(
#line 1131 "/home/pwachara/basilisk/src/draw.h"
(coord) {0,0,1}, 0.,
(     float[3]) {0}, 1.
#line 98 "CubicTest.c"
);
  save("grid_t0_side.jpg"
#line 500 "/home/pwachara/basilisk/src/view.h"
, "ppm", NULL, 
NULL, 
0, 
0, 0, 
NULL, 

NULL
#line 99 "CubicTest.c"
);
  printf("Hi!");
}{end_tracing("init_0","CubicTest.c",101);return 0;}end_tracing("init_0","CubicTest.c",101);}

static int solute_movie_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i += 2)!=0;*ip=i;*tp=t;return ret;}      static int solute_movie(const int i,const double t,Event *_ev){tracing("solute_movie","CubicTest.c",103); {
  view(0,0,0
#line 51 "/home/pwachara/basilisk/src/draw.h"
,
(    float[4]) {0}, 
1., 1., 1., 
800, 800, 4,
(    float[3]) {0}, 
0., 0., 0., 
false, 
0., 0., 0., 
0.
#line 104 "CubicTest.c"
,"front"
#line 60 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 
0., 0., 0., 0., 
NULL
#line 104 "CubicTest.c"
);
  clear();
  draw_vof("cs"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0.
#line 106 "CubicTest.c"
,1
#line 897 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 0, 0, 
false, 
jet
#line 106 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
(        float[3])
#line 106 "CubicTest.c"
{1,1,1}
#line 902 "/home/pwachara/basilisk/src/draw.h"
,( float[3]) {0}, 1., 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 106 "CubicTest.c"
);
  draw_vof("f"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0., 0, 
NULL
#line 107 "CubicTest.c"
, -0.1, 0.1
#line 899 "/home/pwachara/basilisk/src/draw.h"
, 0, 
false, 
jet,
(        float[3]) {0}
#line 107 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
( float[3])
#line 107 "CubicTest.c"
{1,1,0},3
#line 902 "/home/pwachara/basilisk/src/draw.h"
, 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 107 "CubicTest.c"
);
  scalar  vel=new_scalar("vel");
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "CubicTest.c", .line = 109, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 110 "CubicTest.c"
{_stencil_val(u.x,0,0,0);_stencil_val(u.x,0,0,0);_stencil_val(u.y,0,0,0);_stencil_val(u.y,0,0,0);_stencil_val_a(vel,0,0,0);    }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 110 "CubicTest.c"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 110 "CubicTest.c"
val(vel,0,0,0) = sqrt(( (val(u.x,0,0,0))*(val(u.x,0,0,0)))+( (val(u.y,0,0,0))*(val(u.y,0,0,0))));}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 111 "CubicTest.c"
squares("vel"
#line 1234 "/home/pwachara/basilisk/src/draw.h"
, 
NULL
#line 111 "CubicTest.c"
,0.,1.
#line 1236 "/home/pwachara/basilisk/src/draw.h"
, 0, 
false
#line 111 "CubicTest.c"
,jet
#line 1238 "/home/pwachara/basilisk/src/draw.h"
,
(       float[3]) {0},( float[3]) {0}, 
false,

(       coord) {0,0,1}, 
0, 
1, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 111 "CubicTest.c"
);
  cells(
#line 1131 "/home/pwachara/basilisk/src/draw.h"
(coord) {0,0,1}, 0.,
(     float[3]) {0}, 1.
#line 112 "CubicTest.c"
);
  save("velocity_xy.mp4"
#line 500 "/home/pwachara/basilisk/src/view.h"
, "ppm", NULL, 
NULL, 
0, 
0, 0, 
NULL, 

NULL
#line 113 "CubicTest.c"
);

  view(0,0,0
#line 51 "/home/pwachara/basilisk/src/draw.h"
,
(    float[4]) {0}, 
1., 1., 1., 
800, 800, 4,
(    float[3]) {0}, 
0., 0., 0., 
false, 
0., 0., 0., 
0.
#line 115 "CubicTest.c"
,"front"
#line 60 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 
0., 0., 0., 0., 
NULL
#line 115 "CubicTest.c"
);
  clear();
  draw_vof("cs"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0.
#line 117 "CubicTest.c"
,1
#line 897 "/home/pwachara/basilisk/src/draw.h"
, 
NULL, 
0, 0, 0, 
false, 
jet
#line 117 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
(        float[3])
#line 117 "CubicTest.c"
{1,1,1}
#line 902 "/home/pwachara/basilisk/src/draw.h"
,( float[3]) {0}, 1., 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 117 "CubicTest.c"
);
  draw_vof("f"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0., 0, 
NULL
#line 118 "CubicTest.c"
, -0.1, 0.1
#line 899 "/home/pwachara/basilisk/src/draw.h"
, 0, 
false, 
jet,
(        float[3]) {0}
#line 118 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
( float[3])
#line 118 "CubicTest.c"
{1,1,0},3
#line 902 "/home/pwachara/basilisk/src/draw.h"
, 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 118 "CubicTest.c"
);
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "CubicTest.c", .line = 119, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point);    
#line 120 "CubicTest.c"
{ _stencil_val(u.z,0,0,0);_stencil_val_a(vel,0,0,0); }

    
#line 328 "/home/pwachara/basilisk/src/grid/stencils.h"
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  } 
#line 265 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k < point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j < point.n.y + 2; point.j++)

   for (point.k = 2; point.k < point.n.z + 2; point.k++)    
#line 120 "CubicTest.c"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 120 "CubicTest.c"
val(vel,0,0,0) = val(u.z,0,0,0);}
      
#line 282 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
  }
}  
#line 121 "CubicTest.c"
squares("vel"
#line 1234 "/home/pwachara/basilisk/src/draw.h"
, 
NULL
#line 121 "CubicTest.c"
,0.,1.
#line 1236 "/home/pwachara/basilisk/src/draw.h"
, 0, 
false
#line 121 "CubicTest.c"
,jet
#line 1238 "/home/pwachara/basilisk/src/draw.h"
,
(       float[3]) {0},( float[3]) {0}, 
false,

(       coord) {0,0,1}, 
0, 
1, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 121 "CubicTest.c"
);
  cells(
#line 1131 "/home/pwachara/basilisk/src/draw.h"
(coord) {0,0,1}, 0.,
(     float[3]) {0}, 1.
#line 122 "CubicTest.c"
);
  save("uz.mp4"
#line 500 "/home/pwachara/basilisk/src/view.h"
, "ppm", NULL, 
NULL, 
0, 
0, 0, 
NULL, 

NULL
#line 123 "CubicTest.c"
);


  view(0,0,0
#line 51 "/home/pwachara/basilisk/src/draw.h"
,
(    float[4]) {0}, 
1., 1., 1., 
800, 800, 4,
(    float[3]) {0}
#line 126 "CubicTest.c"
,-(3.14/2 + 0.2), 0.4, 0.
#line 56 "/home/pwachara/basilisk/src/draw.h"
, 
false, 
0., 0., 0., 
0., 
NULL, 
NULL, 
0, 
0., 0., 0., 0., 
NULL
#line 126 "CubicTest.c"
);
  clear();
  draw_vof("f"
#line 896 "/home/pwachara/basilisk/src/draw.h"
, NULL, false, 
0., 0, 
NULL
#line 128 "CubicTest.c"
, -0.1, 0.1
#line 899 "/home/pwachara/basilisk/src/draw.h"
, 0, 
false, 
jet,
(        float[3]) {0}
#line 128 "CubicTest.c"
,
#line 902 "/home/pwachara/basilisk/src/draw.h"
( float[3])
#line 128 "CubicTest.c"
{1,1,0},3
#line 902 "/home/pwachara/basilisk/src/draw.h"
, 
false, 
false, 15,( float[2]) {-.95, -.95}, "", 1, false, false, false, 50, "%g", 50
#line 128 "CubicTest.c"
);
  save("front_vof_vid.mp4"
#line 500 "/home/pwachara/basilisk/src/view.h"
, "ppm", NULL, 
NULL, 
0, 
0, 0, 
NULL, 

NULL
#line 129 "CubicTest.c"
);delete((scalar*)((scalar[]){vel,{-1}}));
}{end_tracing("solute_movie","CubicTest.c",130);return 0;}end_tracing("solute_movie","CubicTest.c",130);}

static int end_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i=10)!=0;*ip=i;*tp=t;return ret;}static int end(const int i,const double t,Event *_ev){{
}return 0;}

static int acceleration_2_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i++)!=0;*ip=i;*tp=t;return ret;}      static int acceleration_2(const int i,const double t,Event *_ev){tracing("acceleration_2","CubicTest.c",135);{
  vector av = a;
  
  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "CubicTest.c", .line = 137, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 378
{ _loop.face |= (1 << 1);
#line 137 "CubicTest.c"
{
    _stencil_val_r(av.z,0,0,0);  
  } 
#line 378 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 392
{
  if (point.i < point.n.x + 2 && point.k < point.n.z + 2) {
    int jg = -1; NOT_UNUSED(jg);
#line 137 "CubicTest.c"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 137 "CubicTest.c"
{
    val(av.z,0,0,0) -= 1.0;
  }}
  
#line 396 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}  
#line 314 "/home/pwachara/basilisk/src/grid/stencils.h"
{
    static int _first = 1.;
    ForeachData _loop = {
      .fname = "CubicTest.c", .line = 140, .first = _first
    };
    if (baseblock) for (scalar s = baseblock[0], * i = baseblock; s.i >= 0; i++, s = *i) {
 _attribute[s.i].input = _attribute[s.i].output = _attribute[s.i].nowarning = false;
 _attribute[s.i].width = 0;
      }
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0}; NOT_UNUSED (point); 
#line 377
{ _loop.face |= (1 << 0);
#line 140 "CubicTest.c"
{
    _stencil_val_r(av.x,0,0,0);  
  } 
#line 377 "/home/pwachara/basilisk/src/grid/stencils.h"
}    
#line 328
check_stencil (&_loop);
    boundary_stencil (&_loop);
    _first = 0;
  }
#line 300 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = depth();
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int _k;
    OMP(omp for schedule(static))
      for (_k = 2; _k <= point.n.x + 2; _k++) {
 point.i = _k;

 for (point.j = 2; point.j <= point.n.y + 2; point.j++)

   for (point.k = 2; point.k <= point.n.z + 2; point.k++) 
#line 385
{
  if (point.j < point.n.y + 2 && point.k < point.n.z + 2) {
    int ig = -1; NOT_UNUSED(ig);
#line 140 "CubicTest.c"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 140 "CubicTest.c"
{
    val(av.x,0,0,0) += forcing;
  }}
  
#line 389 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
}      
#line 317
}
  }
}
#line 143 "CubicTest.c"
}{end_tracing("acceleration_2","CubicTest.c",143);return 0;}end_tracing("acceleration_2","CubicTest.c",143);}

static int logfile_expr0(int *ip,double *tp,Event *_ev){int i=*ip;double t=*tp;int ret=(i += 2)!=0;*ip=i;*tp=t;return ret;}      static int logfile(const int i,const double t,Event *_ev){tracing("logfile","CubicTest.c",145); {
  calculate_superficial_vel(&U_LS, &U_GS, &liquid_area);
  fprintf(ferr, "t = %g, U_LS = %g, U_GS = %g, liquid area = %g\n",
          t, U_LS, U_GS, liquid_area);
}{end_tracing("logfile","CubicTest.c",149);return 0;}end_tracing("logfile","CubicTest.c",149);}

void calculate_superficial_vel(double *U_LS, double *U_GS, double *liquid_area) {
  *U_LS = 0.0;
  *U_GS = 0.0;
  *liquid_area = 0.0;

#line 583 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  if (default_scalar_bc[right] != periodic_bc) 
#line 22 "/home/pwachara/basilisk/src/grid/config.h"
{ 
#line 519 "/home/pwachara/basilisk/src/grid/multigrid.h"
{
  OMP_PARALLEL () {
    int ig = 0, jg = 0, kg = 0; NOT_UNUSED(ig); NOT_UNUSED(jg); NOT_UNUSED(kg);
    Point point = {0};
    point.level = (
#line 585
depth()
#line 523
) < 0 ? depth() : (
#line 585
depth()
#line 523
);
    point.n.x = point.n.y = point.n.z = 1 << point.level;
    int * _i = &point.j, * _j = &point.k;
    int _n[2] = { point.n.y, point.n.z };
    if (right == left) {
      point.i = 2;
      ig = -1;
    }
    else if (right == right) {
      point.i = point.n.x + 2 - 1;
      ig = 1;
    }
    else if (right == bottom) {
      point.j = 2;
      _i = &point.i, _n[0] = point.n.x;
      jg = -1;
    }
    else if (right == top) {
      point.j = point.n.y + 2 - 1;
      _i = &point.i, _n[0] = point.n.x;
      jg = 1;
    }
    else if (right == back) {
      point.k = 2;
      _i = &point.i; _j = &point.j;
      _n[0] = point.n.x, _n[1] = point.n.y;
      kg = -1;
    }
    else if (right == front) {
      point.k = point.n.z + 2 - 1;
      _i = &point.i; _j = &point.j;
      _n[0] = point.n.x, _n[1] = point.n.y;
      kg = 1;
    }
    int _l;
    OMP(omp for schedule(static))
      for (_l = 0; _l < _n[0] + 2*2; _l++) {
 *_i = _l;
 for (int _m = 0; _m < _n[1] + 2*2; _m++) {
   *_j = _m;
      
#line 586
if (!is_boundary(point)) 
#line 156 "CubicTest.c"
{  
#line 3 "/home/pwachara/basilisk/src/grid/variables.h"
double Delta = L0*(1./((1 << point.level)*Dimensions_scale));
  double Delta_x = Delta;

  double Delta_y = Delta;


  double Delta_z = Delta;


  double x = ((ig + 1)/2. + (point.i - 2 + mpi_coords[0]*(1 << point.level)))*Delta + X0; NOT_UNUSED(x);

  double y = ((jg + 1)/2. + (point.j - 2 + mpi_coords[1]*(1 << point.level)))*Delta + Y0;



  NOT_UNUSED(y);

  double z = ((kg + 1)/2. + (point.k - 2 + mpi_coords[2]*(1 << point.level)))*Delta + Z0;



  NOT_UNUSED(z);

  NOT_UNUSED(Delta);
  NOT_UNUSED(Delta_x);

  NOT_UNUSED(Delta_y);


  NOT_UNUSED(Delta_z);


  ;
  
#line 206 "/home/pwachara/basilisk/src/grid/multigrid.h"
int level = point.level; NOT_UNUSED(level);
  struct { int x, y, z; } child = {
    2*((point.i + 2)%2) - 1,
    2*((point.j + 2)%2) - 1,
    2*((point.k + 2)%2) - 1
  }; NOT_UNUSED(child);
  Point parent = point; NOT_UNUSED(parent);
  parent.level--;
  parent.i = (point.i + 2)/2;
  parent.j = (point.j + 2)/2;
  parent.k = (point.k + 2)/2;
#line 156 "CubicTest.c"
{
    *U_LS += val(f,0,0,0) * val(u.x,0,0,0) * ( Delta*Delta) / (M_PI * ( (0.5 * 1.0)*(0.5 * 1.0)));
    *U_GS += (1. - val(f,0,0,0)) * val(u.x,0,0,0) * ( Delta*Delta) / (M_PI * ( (0.5 * 1.0)*(0.5 * 1.0)));
    *liquid_area += val(f,0,0,0) * ( Delta*Delta);
  }}
 
#line 564 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
      }
  }
}
#line 22 "/home/pwachara/basilisk/src/grid/config.h"
}

#line 588 "/home/pwachara/basilisk/src/grid/multigrid.h"
}
#line 161 "CubicTest.c"
}
#line 2 "ast/init_solver.h"

static void _init_solver (void)
{
  void init_solver();
datasize=21*sizeof(real);  init_solver();
  {
#line 24
multigrid_methods();

    

    
#line 12
{
      
      
    
      {  
#line 906 "/home/pwachara/basilisk/src/embed.h"
event_register((Event){0,1,metric,{metric_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/embed.h",906,"metric"});  
#line 949
event_register((Event){0,1,defaults,{defaults_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/embed.h",949,"defaults"});  
#line 42 "/home/pwachara/basilisk/src/run.h"
event_register((Event){0,1,defaults_0,{defaults_0_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/run.h",42,"defaults"});  
#line 126 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
event_register((Event){0,1,defaults_1,{defaults_1_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",126,"defaults"});  
#line 194
event_register((Event){0,1,default_display,{default_display_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",194,"default_display"});  








event_register((Event){0,1,init,{init_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",203,"init"});  
#line 127 "/home/pwachara/basilisk/src/vof.h"
event_register((Event){0,1,defaults_2,{defaults_2_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/vof.h",127,"defaults"});  
#line 10 "/home/pwachara/basilisk/src/two-phase-generic.h"
event_register((Event){0,1,defaults_3,{defaults_3_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/two-phase-generic.h",10,"defaults"});  
#line 37 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
event_register((Event){0,1,defaults_4,{defaults_4_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/conserving.h",37,"defaults"});  
#line 30 "/home/pwachara/basilisk/src/iforce.h"
event_register((Event){0,1,defaults_5,{defaults_5_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/iforce.h",30,"defaults"});  
#line 20 "/home/pwachara/basilisk/src/maxruntime.h"
event_register((Event){0,1,runtime,{runtime_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/maxruntime.h",20,"runtime"});  
#line 7 "/home/pwachara/basilisk/src/navier-stokes/perfs.h"
event_register((Event){0,1,perfs,{perfs_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/perfs.h",7,"perfs"});  
#line 27
event_register((Event){0,1,perf_plot,{perf_plot_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/perfs.h",27,"perf_plot"});  
#line 69 "CubicTest.c"
event_register((Event){0,1,init_0,{init_0_expr0},((int *)0),((double *)0),"CubicTest.c",69,"init"});  
#line 103
event_register((Event){0,1,solute_movie,{solute_movie_expr0},((int *)0),((double *)0),"CubicTest.c",103,"solute_movie"});  
#line 132
event_register((Event){0,1,end,{end_expr0},((int *)0),((double *)0),"CubicTest.c",132,"end"});  
#line 145
event_register((Event){0,1,logfile,{logfile_expr0},((int *)0),((double *)0),"CubicTest.c",145,"logfile"});
	
	
	
      
#line 22 "ast/init_solver.h"
}
#line 385 "/home/pwachara/basilisk/src/common.h"
init_const_vector((vector){{_NVARMAX+4},{_NVARMAX+5},{_NVARMAX+6}},"zerof",(double[]){0.,0.,0.});
init_const_vector((vector){{_NVARMAX+7},{_NVARMAX+8},{_NVARMAX+9}},"unityf",(double[]){1.,1.,1.});
init_const_scalar((scalar){_NVARMAX+10},"unity", 1.);
init_const_scalar((scalar){_NVARMAX+11},"zeroc", 0.);



init_const_vector((vector){{_NVARMAX+12},{_NVARMAX+13},{_NVARMAX+14}},"fm",(double[]){1.,1.,1.});
init_const_scalar((scalar){_NVARMAX+15},"cm", 1.);  init_scalar((scalar){0},"cs");  init_face_vector((vector){{1},{2},{3}},"fs"); 
#line 461 "/home/pwachara/basilisk/src/embed.h"
embed=new_bid();  init_scalar((scalar){4},"p");  init_vector((vector){{5},{6},{7}},"u");  init_vector((vector){{8},{9},{10}},"g");  init_scalar((scalar){11},"pf");  init_face_vector((vector){{12},{13},{14}},"uf");  init_scalar((scalar){15},"f");  init_face_vector((vector){{16},{17},{18}},"alphav");  init_scalar((scalar){19},"rhov");  init_scalar((scalar){20},"f0");    
#line 23 "ast/init_solver.h"
}_attribute[p.i].dirty=1,_attribute[p.i].boundary[right]=_boundary0,_attribute[p.i].boundary_homogeneous[right]=_boundary0_homogeneous;_attribute[p.i].dirty=1,_attribute[p.i].boundary[left]=_boundary1,_attribute[p.i].boundary_homogeneous[left]=_boundary1_homogeneous;_attribute[p.i].dirty=1,_attribute[p.i].boundary[top]=_boundary2,_attribute[p.i].boundary_homogeneous[top]=_boundary2_homogeneous;_attribute[p.i].dirty=1,_attribute[p.i].boundary[bottom]=_boundary3,_attribute[p.i].boundary_homogeneous[bottom]=_boundary3_homogeneous;_attribute[p.i].dirty=1,_attribute[p.i].boundary[front]=_boundary4,_attribute[p.i].boundary_homogeneous[front]=_boundary4_homogeneous;_attribute[p.i].dirty=1,_attribute[p.i].boundary[back]=_boundary5,_attribute[p.i].boundary_homogeneous[back]=_boundary5_homogeneous;_attribute[u.x.i].dirty=1,_attribute[u.x.i].boundary[embed]=_boundary6,_attribute[u.x.i].boundary_homogeneous[embed]=_boundary6_homogeneous;_attribute[u.y.i].dirty=1,_attribute[u.y.i].boundary[embed]=_boundary7,_attribute[u.y.i].boundary_homogeneous[embed]=_boundary7_homogeneous;_attribute[u.z.i].dirty=1,_attribute[u.z.i].boundary[embed]=_boundary8,_attribute[u.z.i].boundary_homogeneous[embed]=_boundary8_homogeneous;  
#line 50 "/home/pwachara/basilisk/src/run.h"
event_register((Event){0,1,cleanup,{cleanup_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/run.h",50,"cleanup"});  
#line 229 "/home/pwachara/basilisk/src/navier-stokes/centered.h"
event_register((Event){0,1,set_dtmax,{set_dtmax_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",229,"set_dtmax"});  

event_register((Event){0,1,stability,{stability_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",231,"stability"});  









event_register((Event){0,1,vof,{vof_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",241,"vof"});  
event_register((Event){0,1,tracer_advection,{tracer_advection_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",242,"tracer_advection"});  
event_register((Event){0,1,tracer_diffusion,{tracer_diffusion_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",243,"tracer_diffusion"});  






event_register((Event){0,1,properties,{properties_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",250,"properties"});  
#line 323
event_register((Event){0,1,advection_term,{advection_term_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",323,"advection_term"});  
#line 352
event_register((Event){0,1,viscous_term,{viscous_term_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",352,"viscous_term"});  
#line 388
event_register((Event){0,1,acceleration,{acceleration_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",388,"acceleration"});  
#line 428
event_register((Event){0,1,projection,{projection_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",428,"projection"});  
#line 443
event_register((Event){0,1,end_timestep,{end_timestep_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/centered.h",443,"end_timestep"});  
#line 140 "/home/pwachara/basilisk/src/vof.h"
event_register((Event){0,1,stability_0,{stability_0_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/vof.h",140,"stability"});  
#line 380
event_register((Event){0,1,vof_0,{vof_0_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/vof.h",380,"vof"});  
#line 50 "/home/pwachara/basilisk/src/two-phase-generic.h"
event_register((Event){0,1,tracer_advection_0,{tracer_advection_0_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/two-phase-generic.h",50,"tracer_advection"});  
#line 83
event_register((Event){0,1,properties_0,{properties_0_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/two-phase-generic.h",83,"properties"});  
#line 72 "/home/pwachara/basilisk/src/navier-stokes/conserving.h"
event_register((Event){0,1,stability_1,{stability_1_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/conserving.h",72,"stability"});  
#line 117
event_register((Event){0,1,vof_1,{vof_1_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/conserving.h",117,"vof"});  
#line 192
event_register((Event){0,1,tracer_advection_1,{tracer_advection_1_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/navier-stokes/conserving.h",192,"tracer_advection"});  
#line 45 "/home/pwachara/basilisk/src/iforce.h"
event_register((Event){0,1,acceleration_0,{acceleration_0_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/iforce.h",45,"acceleration"});  
#line 36 "/home/pwachara/basilisk/src/tension.h"
event_register((Event){0,1,stability_2,{stability_2_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/tension.h",36,"stability"});  
#line 72
event_register((Event){0,1,acceleration_1,{acceleration_1_expr0},((int *)0),((double *)0),"/home/pwachara/basilisk/src/tension.h",72,"acceleration"});  
#line 135 "CubicTest.c"
event_register((Event){0,1,acceleration_2,{acceleration_2_expr0},((int *)0),((double *)0),"CubicTest.c",135,"acceleration"});  
#line 24 "ast/init_solver.h"
}
  set_fpe();
}
